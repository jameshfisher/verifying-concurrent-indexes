%% FFS, why is there no vertical space between stuff,
%% and FFS, why does TeX not define the em?
\newcommand{\vvv}{\vspace{5 mm}}


In the above, why was `black' used?
To enforce that the root node is black,
  should we not use $\constant{red}$ as its parent color?

We can now express the pre- and postconditions of operations on the tree.
These are much the same as those on a set data type.

\vvv

\begin{tabular}{ r c l }
$\{ \mathsf{rbtree}(r, S) \}$ & $\mathsf{insert}(r, v) $         & $\{ \mathsf{rbtree}(r, S \union \Set{v} ) \}$ \\
$\{ \mathsf{rbtree}(r, S) \}$ & $\pas{e}{\mathsf{search}(r, v)}$ & $\{ \mathsf{rbtree}(r, S) \Fand (e = \truth \Fand v \in S \For e = \falsity \Fand v \notin S ) \}$ \\
$\{ \mathsf{rbtree}(r, S) \}$ & $\mathsf{remove}(r, v) $         & $\{ \mathsf{rbtree}(r, S - \Set{v} ) \}$ \\
\end{tabular}

\vvv

Here's insert:

\vvv

\[ \left\{ \mathsf{rbtree}(n, S) \vDash \right\} \]

\[ \left\{ \begin{array}{rrl}
\multicolumn{3}{l}{ \mathsf{tree}(n, S, pH, pC) \eqdef } \\
     & \multicolumn{2}{l}{ (n = \nullref \Fand S = \scemp \Fand pH = 1 \Fand \hemp) } \\
\For & (\exists l, r, v, c, h. & \Fcell{n}{l, r, v, c} \\
     &                   \Fsep & \mathsf{tree}(l, Q, h, c) \\
     &                   \Fsep & \mathsf{tree}(r, R, h, c) \\
     &                   \Fand & \forall v\prime. v\prime \in Q \IMPLIES v\prime < v \\
     &                   \Fand & \forall v\prime. v\prime \in R \IMPLIES v\prime > v \\
     &                   \Fand & Q \union R \union \Set{v} = S \\
     &                   \Fand &  \mathsf{rbCond}(c, pC, h, pH) \\
     &                         & )
\end{array}
\right\} \]

\begin{lstlisting}
e := search(n, val) {
  if(n == nil) {
\end{lstlisting}

\textcolor{blue}{ \begin{math} \{
\ldots n = \nullref \Fand S = \scemp \Fand pH = 1 \Fand \hemp \vDash val \notin S
\} \end{math}}

\begin{lstlisting}
    e = false;
\end{lstlisting}

\textcolor{blue}{ \begin{math} \{
\ldots n = \nullref \Fand S = \scemp \Fand pH = 1 \Fand \hemp \vDash val \notin S \Fand e = \falsity
\} \end{math}}

\begin{lstlisting}
  }
  else {
\end{lstlisting}

\textcolor{blue}{ \[ \left\{
\begin{array}{rl}
\exists l, r, v, c, h. & \Fcell{n}{l, r, v, c} \\
                 \Fsep & \mathsf{tree}(l, Q, h, c) \\
                 \Fsep & \mathsf{tree}(r, R, h, c) \\
                 \Fand & \forall v\prime. v\prime \in Q \IMPLIES v\prime < v \\
                 \Fand & \forall v\prime. v\prime \in R \IMPLIES v\prime > v \\
                 \Fand & Q \union R \union \Set{v} = S \\
                 \Fand & \mathsf{rbCond}(c, pC, h, pH) \\
\end{array}
\right\} \] }

\begin{lstlisting}
    rv := node->value;
\end{lstlisting}

\textcolor{blue}{ \begin{math} \{
\ldots
\Fand rv = v
\} \end{math}}

\begin{lstlisting}
    if(val == rv) {
\end{lstlisting}

\textcolor{blue}{ \begin{math} \{
\ldots
\Fand rv = v
\Fand val = rv
\vDash val = v
\vDash val \in S
\} \end{math}}

\begin{lstlisting}
      e = true;
\end{lstlisting}

\textcolor{blue}{ \begin{math} \{
\ldots
val \in S
\Fand e = \truth
\} \end{math}}

\begin{lstlisting}
    }
    else {
\end{lstlisting}

\textcolor{blue}{ \begin{math} \{
\ldots
\Fand rv = v
\Fand val \neq rv
\vDash val \neq v
\} \end{math}}

\begin{lstlisting}
      if(val < rv) {
\end{lstlisting}

\textcolor{blue}{ \begin{math} \{
\ldots
\Fand \mathsf{tree}(l, \Setb{v\prime}{v\prime \in S \Fand v\prime < v}, h, c) \\
\Fand \Setb{v\prime}{v\prime \in S \Fand v\prime < v} \union \Setb{v\prime}{v\prime \in S \Fand v\prime > v} \union \Set{v} = S \\
\Fand rv = v
\Fand val \neq v
\Fand val < rv
\vDash val < v \\
\vDash v \notin \Setb{v\prime}{v\prime \in S \Fand v\prime > v} \\
\Fand v \notin \Set{v} \vDash truthvalueof(v \in S) = truthvalueof(v \in \Setb{v\prime}{v\prime \in S \Fand v\prime < v}) \\
\vDash \mathsf{search}(r, val) = \mathsf{search}(l, val)
\} \end{math}}

\begin{lstlisting}
        e = search(node->left, val);
\end{lstlisting}

\textcolor{blue}{ \begin{math} \{
\ldots
\Fand rv = v
\Fand val \neq v
\Fand val < rv
\vDash val < v
\Fand \mathsf{tree}(l, \Setb{v\prime}{v\prime \in S \Fand v\prime < v}, h, c) \\
\Fand \mathsf{tree}(r, \Setb{v\prime}{v\prime \in S \Fand v\prime > v}, h, c) 
\vDash v \notin \Setb{v\prime}{v\prime \in S \Fand v\prime > v}
\vDash \mathsf{search}(r, val) = \mathsf{search}(l, val)
\} \end{math}}

\begin{lstlisting}
      }
      else {
        e = search(node->right, val);
      }
    }
  }
}
\end{lstlisting}

\begin{math}
\mathsf{rbtree}(node, S \union \Set{v} )
\end{math}

\vvv

In the above there's a \emph{lot} of text.
What I \emph{want} to do is have `scoped assertions',
  e.g. all the stuff saying that $r$ points to a valid node
  can be stated once, at the top of the main \texttt{else} branch.
There's the obvious problem that assertions don't necessarily remain valid,
  but can something like this be done?

Also I'm not sure how deductions should be made explicit.
In the above, I've lumped everything together.
Instead of e.g.

\textcolor{blue}{ \begin{math} \{
\ldots
\Fand rv = v
\Fand val = rv
\Fand val = v
\Fand val \in S
\} \end{math}}

can I instead say

\textcolor{blue}{ \begin{math} \{
\ldots
\Fand rv = v
\Fand val = rv
\vDash val = v
\vDash val \in S
\} \end{math}}


\subsection{Iterative search}


%% /* rbtree(n, S, ..) */
%% e := search(n, val) {
%%   e := false;
%%   /* rbtree(n, S, ..)  and  e = false */
%%   while(n != null && !e) {
%%     /* Loop invariant: n is null and e is false; or n isnt null
%%      */
%%     rv := n->value;
%%     if(val == rv) {
%%       e = true;
%%     }
%%     else {
%%       if(val < rv) {
%%         n = n->left;
%%       }
%%       else {
%%         n = n->right;
%%       }
%%     }
%%   }

%%   /*
%%    */
%% }

%% While rule:

%% {P and B} S {P}
%% ---
%% {P} S {P and ¬B}

%% B = (n != null && !e)
%% P = (val in S, and e || ¬e)
