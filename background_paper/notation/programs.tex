% Programs
% ========


\newsavebox{\myarraytmpstrutbox}
\newenvironment{myarray}{\sbox{\myarraytmpstrutbox}{\strutbox}\sbox{\strutbox}{\rule{0pt}{0pt}}\begin{array}}{\end{array}\sbox{\strutbox}{\myarraytmpstrutbox}}


% Program syntax
\newcommand{\psyntax}[1]{\textup{\texttt{#1}}}
% Program variable
\newcommand{\pvs}[1]{\texttt{\textit{#1}}\mspace{-1mu}}
% Procedure name
\newcommand{\pname}[1]{\textup{\texttt{\textbf{#1}}}}

%%%% Expressions

\newcommand{\eP}{\mathbin{\psyntax{+}}}
\newcommand{\eM}{\mathbin{\psyntax{-}}}
\newcommand{\eT}{\mathbin{\psyntax{*}}}
\newcommand{\eLT}{\mathrel{\psyntax{<}}}
\newcommand{\eEQ}{\mathrel{\psyntax{=}}}
\newcommand{\eIMP}{\mathbin{\psyntax{=>}}}
\newcommand{\eFALSE}{\psyntax{false}}


%%%% Programs

% Skip
\newcommand{\pskip}{\psyntax{skip}}
% Assign
\newcommand{\pas}[2]{#1 := #2}
% Sequential composition
\newcommand{\seq}{;}
% If-then-else
\newcommand{\pifelse}[3]{\psyntax{if } #1 \psyntax{ then } #2 \psyntax{ else } #3}
\newcommand{\pifelsev}[3]{\begin{array}{@{\hspace{2ex}}l}\hspace{-2ex}\psyntax{if } #1 \psyntax{ then} \\ #2 \\ \hspace{-2ex}\psyntax{else} \\ #3 \end{array}}
\newcommand{\pifv}[2]{\begin{array}{@{\hspace{2ex}}l}\hspace{-2ex}\psyntax{if } #1 \psyntax{ then} \\ #2 \end{array}}
% While-do
\newcommand{\pwhile}[2]{\psyntax{while } #1 \psyntax{ do } #2}
\newcommand{\pwhilev}[2]{\begin{array}{@{\hspace{2ex}}l}\hspace{-2ex}\psyntax{while } #1 \psyntax{ do } \\ #2 \end{array}}
% Procdef
\newcommand{\procdef}[4]{#1 := #2 ( #3 ) \ \{ #4 \}}
\newcommand{\procdefv}[4]{\begin{array}{@{\hspace{2ex}}l}\hspace{-2ex} #1 := #2 ( #3 ) \ \{ \\ #4 \\ \hspace{-2ex} \} \end{array}}
\newcommand{\procdefvb}[4]{\begin{array}{@{\hspace{2ex}}l}\hspace{-2ex} \pvs{#1} := \pname{#2} ( #3 ) \ \{ \\ #4 \\ \hspace{-2ex} \} \end{array}}
\newcommand{\procdefvc}[3]{\begin{array}{@{\hspace{2ex}}l}\hspace{-2ex} \pname{#1} ( #2 ) \ \{ \\ #3 \\ \hspace{-2ex} \} \end{array}}
% Procedures
\newcommand{\procs}[2]{\psyntax{procs } #1 \psyntax{ in } #2}
\newcommand{\procsv}[2]{\begin{array}{@{\hspace{2ex}}l}\hspace{-2ex}\psyntax{procs} \\ #1 \\ \hspace{-2ex}\psyntax{in} \\ #2 \end{array}}
% Procedure call
\newcommand{\pcall}[3]{\psyntax{call } #1 := #2(#3)}
\newcommand{\pcallo}[2]{\psyntax{call } #1(#2)}
% Local variable declaration
\newcommand{\plocal}[2]{\psyntax{local } #1 \psyntax{ in } #2}
\newcommand{\plocalv}[2]{\begin{array}{@{\hspace{2ex}}l}\hspace{-2ex} \psyntax{local } #1 \psyntax{ in} \\ #2 \end{array}}

% Allocate
\newcommand{\alloc}[2]{\pvs{#1} := \psyntax{alloc}(#2)}
% Dispose
\newcommand{\dispose}[2]{\psyntax{dispose}(#1,#2)}
% Store
\newcommand{\sto}[2]{\left[#1\right] := #2}
% Fetch
\newcommand{\fet}[2]{\pvs{#1} := \left[#2\right]}

%%%% Scope

 \newcommand{\hrpoonyatom}[1]{\vcenter{\offinterlineskip\hbox{$#1\rightharpoonup$}\vskip-.45ex\hbox{$#1\rightharpoondown$}}}

% Scope value
\newcommand{\sceq}{\mathrel{\mathchoice{\hrpoonyatom\displaystyle}{\hrpoonyatom\textstyle}{\hrpoonyatom\scriptstyle}{\hrpoonyatom\scriptscriptstyle}}}
\newcommand{\scval}[2]{ \pvs{#1} \sceq #2 }
% Scope combination
\newcommand{\scc}{\mathrel{\ast}}
% Empty scope
\newcommand{\scemp}{\varnothing}

%%%% Semantics

% $\Tstack \rightarrow \Tscope$
\newcommand{\tosco}[1]{\lfloor #1 \rfloor}

% $\Texpr \rightarrow (\Tscope \rightarrow \Tval)$
\newcommand{\esem}[1]{\mathcal{E}\sem{#1}}
% $\Tbexp \rightarrow \mathcal{P}(\Tscope)$
\newcommand{\psem}[1]{\mathcal{P}\sem{#1}}
% $\Tbexp \rightarrow (\Tscope \rightarrow 2)$
\newcommand{\bsem}[1]{\mathcal{B}\sem{#1}}
% $\Tcommand \rightarrow (\Tscope \rightarrow \powset{\Tscope} \union \Set{\fault})$
\newcommand{\csem}[1]{\mathcal{C}\sem{#1}}
% Big step
\newcommand{\bigto}{\leadsto}
\RequirePackage{centernot}
\newcommand{\nbigto}{\centernot\bigto}
% Fault
\newcommand{\fault}{\lightning}

\DeclareMathOperator{\writeVar}{writeVar}
\DeclareMathOperator{\writeVars}{writeVars}
\DeclareMathOperator{\lookup}{lookup}

\newcommand{\axioms}[1]{\textup{\textsc{Ax}}\sem{#1}}

%%%% Abstract modules
\newcommand{\am}[1]{\mathbb{#1}}
% Heap module
\newcommand{\amH}{\am{H}}
% Tree module
\newcommand{\amT}{\am{T}}
% List module
\newcommand{\amL}{\am{L}}

%%%% Module translations


% Translation
\newcommand{\trl}{\tau}
% Abstraction relation
\newcommand{\ar}{\mathrel{\alpha}}
% Implementation
\newcommand{\imp}[1]{\sem{#1}}
% Predicate translation
\newcommand{\prtr}[1]{\sem{#1}}

% Interface set
\newcommand{\TIF}{\mathcal{I}}
\newcommand{\TIFi}{\TIF_{\mathrm{in}}}
\newcommand{\TIFo}{\TIF_{\mathrm{out}}}
% Interface
\newcommand{\intf}{I}
\newcommand{\intfi}{\mathit{in}}
\newcommand{\intfo}{\mathit{out}}
% Crust parameter set
\newcommand{\TCP}{\mathcal{F}}
% Crust parameter
\newcommand{\crup}{F}
% Data rep
\newcommand{\drep}[2]{\langle\!\langle #1 \rangle\!\rangle^{#2}}
% Context rep
\newcommand{\crep}[3]{\langle\!\langle #1 \rangle\!\rangle^{#2}_{#3}}
% Crust
\newcommand{\crust}[2]{\mathord{\doublecap}_{#1}^{#2}}

\newcommand{\rsem}[1]{\left(\mspace{-4.0mu}\left| #1 \right|\mspace{-3.5mu}\right)}
% Intermediate Data Translation
\newcommand{\idpt}[2]{\rsem{#1}^{#2}}
% Intermediate Context Translation
\newcommand{\icpt}[3]{\rsem{#1}^{#2}_{#3}}


%%%% Predicates

\newcommand{\vsafe}{\mathit{vsafe}}
\newcommand{\bsafe}{\mathit{bsafe}}

%%%% Hoare logic
% Hoare triple
\newcommand{\triple}[3]{\left\{#1\middle\} \ #2 \ \middle\{#3 \right\}}
\newcommand{\vtriple}[3]{\begin{myarray}{@{}c@{}} \left\{#1\right\} \\[\smallskipamount] #2 \\[\smallskipamount] \left\{#3 \right\} \end{myarray}}

\newcommand{\pspec}[3]{#1 : #2 \rightarrowtail #3}


%%%% Hoare logic rules

\newcommand{\mkrule}[1]{\textsc{#1}}
% Axiom
\newcommand{\raxiom}{\mkrule{Axiom}}
% Frame
\newcommand{\rframe}{\mkrule{Frame}}
% Consequence
\newcommand{\rcons}{\mkrule{Cons}}
% Disjunction
\newcommand{\rdisj}{\mkrule{Disj}}
% Skip
\newcommand{\rskip}{\mkrule{Skip}}
% Sequencing
\newcommand{\rseq}{\mkrule{Seq}}
% If
\newcommand{\rif}{\mkrule{If}}
% While
\newcommand{\rwhile}{\mkrule{While}}
% Assignment
\newcommand{\rassgn}{\mkrule{Assgn}}
% Local variable
\newcommand{\rlocal}{\mkrule{Local}}
% Procedure definition
\newcommand{\rpdef}{\mkrule{PDef}}
% Procedure call
\newcommand{\rpcall}{\mkrule{PCall}}
% Procedure weakening
\newcommand{\rpwk}{\mkrule{PWk}}

% Conjunction
\newcommand{\rconj}{\mkrule{Conj}}
