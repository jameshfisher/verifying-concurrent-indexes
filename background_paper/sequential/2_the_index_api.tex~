\subsection{The Index API}

It isn't surprising, then, that
  almost every programming language has an index data type.\cite{wp_mapping}
(Indeed, in some languages, such as Javascript\footnotemark,
  all objects are indexes.)
With its appealingly intuitive interface,
  the programmer can memoize the results of a function,
  model the houses on her street,
  or describe a directed graph.
She might, for another example, cache the Web,
  simply with:\footnotemark

\footnotetext{\cite{ecmascript}, p.\ 2.}

\footnotetext{I use a syntax similar to C++ in my examples.}

\begin{minted}[]{c++}
typedef Index<Url, Page> Webcache;
Webcache cache;

Page get(Url u) {
  Page p = cache.search(u);

  if (p != null && !p.expired()) return p;

  p = http_get(u);

  if (p == null) cache.remove(u);
  else           cache.insert(u, p);

  return p;
}
\end{minted}

This small example illustrates the entire API.
Let's look at it a bit more formally.
An index is a \emph{container type};
  its type is specified by the type of the \emph{key} 
  and the type of the \emph{value}.
(In the above, a \texttt{Webcache} is an index
  with \texttt{Url}s as keys
  and \texttt{Page}s as values.)
We say that an index `maps \texttt{K}s onto \texttt{V}s'
  if its key type is \texttt{K}
  and its value type is \texttt{V}.
Given an index \texttt{i}
  that maps \texttt{K}s onto \texttt{V}s,
  we can specify what we can do with it
  (in the following,
    \IC{key} is of type \IC{K},
    and \IC{value} is of type \IC{V}):

\begin{description}

%%%%% search
\item[\texttt{value = i.search(key);}\footnotemark]
If there is a value associated with \IC{key} in \IC{i},
  \IC{value} will be that value.
Otherwise, \IC{value} will be \IC{null}.\footnotemark

\footnotetext{
The \IC{search} function is also called
  \IC{find}, \IC{fetch}, \IC{read}, and \IC{get}.
}

\footnotetext{
Note that with a \IC{null} type,
  an index can be seen as a \emph{total} function.
}

%%%%% add
\item[\texttt{i.insert(key, value);}\footnotemark]
Subsequent calls to \IC{i.search(key)} will return \IC{value}
  (until subsequent calls to \IC{i.insert(k, —)} or \IC{i.remove(k)},
   where \IC{k == key}).

\footnotetext{
The \IC{insert} function is also called
  \IC{store}, \IC{set}, \IC{save}, and \IC{add}.
}

%%%%% remove
\item[\texttt{i.remove(key);}\footnotemark]
Subsequent calls to \IC{i.read(key)} will return \IC{null}
  (until subsequent calls to \IC{i.insert(k, —)} or \IC{i.remove(k)},
   where \IC{k == key}).

\footnotetext{
The \IC{remove} function is also called
  \IC{delete}.
It may also be absent,
  in favour of \IC{insert(k, null)}
  (suggesting the `total function' interpretation).
}
\end{description}

Notice that the function calls do not reveal anything about
  what \IC{i} looks like inside:
  the \IC{Index} type is \emph{abstract},
  enabling the programmer to reason about it as a mathematical construction.
