\subsubsection{Formalizing index behavior}

A correct index implementation will satisfy the behavior described above.
To \emph{prove} that one does so, however,
  we shall have to describe the behavior more precisely.
The basic tool here is Hoare logic.

\VEm
\noindent
\begin{tabular*}{\textwidth}{l l l}

\Cond{\Pred{index}{\IC{i}, I} \Fand I(\IC{k}) = v\prime}       &  \IC{v = i->search(k);}  &  \Cond{\Pred{index}{\IC{i}, I} \Fand I(\IC{k}) = v\prime \Fand \IC{v} = v\prime}  \\[0.5em]
\Cond{\Pred{index}{\IC{i}, I} \Fand \IC{k} \notin \KeysOf{I}}  &  \IC{v = i->search(k);}  &  \Cond{\Pred{index}{\IC{i}, I} \Fand \IC{k} \notin \KeysOf{I} \Fand \IC{v} = \nullref}  \\[1em]

\Cond{\Pred{index}{\IC{i}, I} \Fand \IC{k} \notin \KeysOf{I}}  &  \IC{i->insert(k, v);}   &  \Cond{\Pred{index}{\IC{i}, \fupd{I}{\IC{k}}{\IC{v}}}}  \\[0.5em]
\Cond{\Pred{index}{\IC{i}, I} \Fand I(\IC{k}) = v\prime}       &  \IC{i->insert(k, v);}   &  \Cond{\Pred{index}{\IC{i}, I} \Fand I(\IC{k}) = v\prime}  \\[1em]

\Cond{\Pred{index}{\IC{i}, I} }                                &  \IC{i->remove(k);}      &  \Cond{\Pred{index}{\IC{i}, I \setminus \Set{\IC{k}} }} \\

\end{tabular*}
