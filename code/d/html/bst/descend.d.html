<section class='generated_listing' xmlns='http://www.w3.org/1999/xhtml' xmlns:xi='http://www.w3.org/2001/XInclude' xmlns:e='http://eegg.github.com/htmlx' xmlns:m='http://eegg.github.com/macro'><e:displaycode>module bst.descend;

import bst.node;


Node* descend(Node* root, in int value) {&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;</pre><div class='AssertionParagraph'><div class='expl'>Function precondition.
The tree is non-empty and value is not at the root
(so if it's in the set, it's in one of the two subtrees).</div>TopOfTree(root, v, S) ∧ v≠value</div></div>
<e:displaycode>
  int dir = value &gt; root.value;
&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;</pre><div class='AssertionParagraph'><div class='expl'>Either &gt; or &lt;.  C semantics render this as an integer.
v≠value is now implied.</div>TopOfTree(root, v, S) ∧ <br /><span class='assertionIndent'> &#160;&#160;</span>(value &lt; v ∧ dir = 0) ∨<br /><span class='assertionIndent'> &#160;&#160;</span>(value &gt; v ∧ dir = 1)</div></div>
<e:displaycode>
  Node* o = root.c[dir];
&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;</pre><div class='AssertionParagraph'><div class='expl'>Open TopOfTree.  Do both cases of value of `dir`.</div>∃v,l,r,L,R.<br /><span class='assertionIndent'> &#160;&#160;</span>root↦v,l,r ∗ Tree(l, L) ∗ Tree(r, R)<br /><span class='assertionIndent'> &#160;&#160;</span>∧ Compose(L, v, R, S)<br /><span class='assertionIndent'> &#160;&#160;</span>∧ (value &lt; v ∧ o = l) ∨ (value &gt; v ∧ o = r)</div></div>

<div class='section'><pre class='indent'>&#160;&#160;</pre><div class='AssertionParagraph'><div class='expl'>What is true of the subtree pointers is true of `o`.</div>∃v,l,r,L,R.<br /><span class='assertionIndent'> &#160;&#160;</span>root↦v,l,r ∗ Tree(l, L) ∗ Tree(r, R)<br /><span class='assertionIndent'> &#160;&#160;</span>∧ Compose(L, v, R, S)<br /><span class='assertionIndent'> &#160;&#160;</span>∧ (value &lt; v ∧ Tree(o, L)) ∨ (value &gt; v ∧ Tree(o, R))</div></div>

<div class='section'><pre class='indent'>&#160;&#160;</pre><div class='AssertionParagraph'><div class='expl'>From Compose and relation of value and v.</div>∃v,l,r,L,R.<br /><span class='assertionIndent'> &#160;&#160;</span>root↦v,l,r ∗ Tree(l, L) ∗ Tree(r, R)<br /><span class='assertionIndent'> &#160;&#160;</span>∧ Compose(L, v, R, S)<br /><span class='assertionIndent'> &#160;&#160;</span>∧ (Tree(o, L) ∧ (value∈L ↔ value∈S)) ∨ (Tree(o, R) ∧ (value∈R ↔ value∈S))</div></div>

<div class='section'><pre class='indent'>&#160;&#160;</pre><div class='AssertionParagraph'><div class='expl'>Introduce quantification.</div>∃v,l,r,L,R.<br /><span class='assertionIndent'> &#160;&#160;</span>root↦v,l,r ∗ Tree(l, L) ∗ Tree(r, R)<br /><span class='assertionIndent'> &#160;&#160;</span>∧ Compose(L, v, R, S)<br /><span class='assertionIndent'> &#160;&#160;</span>∧ (∃Q. Tree(o, Q) ∧ (value∈Q ↔ value∈S)) ∨ (∃Q. Tree(o, Q) ∧ (value∈Q ↔ value∈S))</div></div>

<div class='section'><pre class='indent'>&#160;&#160;</pre><div class='AssertionParagraph'><div class='expl'>a ∨ a implies a.</div>∃v,l,r,L,R.<br /><span class='assertionIndent'> &#160;&#160;</span>root↦v,l,r ∗ Tree(l, L) ∗ Tree(r, R)<br /><span class='assertionIndent'> &#160;&#160;</span>∧ Compose(L, v, R, S)<br /><span class='assertionIndent'> &#160;&#160;</span>∧ ∃Q. Tree(o, Q) ∧ (value∈Q ↔ value∈S))</div></div>

<div class='section'><pre class='indent'>&#160;&#160;</pre><div class='AssertionParagraph'><div class='expl'>Function postcondition.  Close TopOfTree.</div>TopOfTree(root, v, S)<br /><span class='assertionIndent'> </span>∧ ∃Q. Tree(o, Q) ∧ (value∈Q ↔ value∈S))</div></div>

<div class='section'><pre class='indent'>&#160;&#160;</pre><div class='CommentParagraph'>Note: we want |Q| &lt; |S|
to show termination of other functions.</div></div>
<e:displaycode>
  return o;
}&#160;</e:displaycode></section>