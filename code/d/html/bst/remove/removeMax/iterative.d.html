<section class='generated_listing' xmlns='http://www.w3.org/1999/xhtml' xmlns:xi='http://www.w3.org/2001/XInclude' xmlns:e='http://eegg.github.com/htmlx' xmlns:m='http://eegg.github.com/macro'><e:displaycode>module bst.remove.removeMax.iterative;

import bst.node;
import bst.remove.removeMax.RemoveMaxRet;

import std.stdio;

RemoveMaxRet removeMax(Node* root) {&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;</pre><div class='AssertionParagraph'><div class='expl'>We can only remove the maximum from a non-empty tree!</div>NonEmptyTree(root, S)</div></div>
<e:displaycode>
  assert(root != null);
&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;</pre><div class='CommentParagraph'>We're going to put the return values here.</div></div>
<e:displaycode>  int max;
  Node* newRoot;
&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;</pre><div class='AssertionParagraph'><div class='expl'>Open NonEmptyTree(root, S).</div>∃v. TopOfTree(root, v, S).</div></div>

<div class='section'><pre class='indent'>&#160;&#160;</pre><div class='AssertionParagraph'><div class='expl'>Open TopOfTree.</div>∃v,l,r,L,R.
  root↦v,l,r
  ∗ Tree(l, L)
  ∗ Tree(r, R)
  ∧ Compose(L, v, R, S).</div></div>
<e:displaycode>
  auto r = root.c[1];
&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;</pre><div class='AssertionParagraph'><div class='expl'>Take `r` out of quantification.</div>∃v,l,L,R.
  root↦v,l,r
  ∗ Tree(l, L)
  ∗ Tree(r, R)
  ∧ Compose(L, v, R, S).</div></div>
<e:displaycode>
  if(!r) {&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;</pre><div class='AssertionParagraph'><div class='expl'>Assert if-condition.  Discard EmptyTree.  The right child is null, so the maximum is at the root.  The rest of the set is in the LHS.</div>∃v,l,L.
  root↦v,l,null
  ∗ Tree(l, L)
  ∧ Compose(L, v, ∅, S).</div></div>

<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;</pre><div class='AssertionParagra