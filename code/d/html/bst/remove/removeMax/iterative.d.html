<section xmlns='http://www.w3.org/1999/xhtml' xmlns:xi='http://www.w3.org/2001/XInclude' xmlns:e='http://eegg.github.com/htmlx' xmlns:m='http://eegg.github.com/macro'><e:displaycode>module bst.remove.removeMax.iterative;

import bst.node;
import bst.remove.removeMax.RemoveMaxRet;

import std.stdio;

RemoveMaxRet removeMax(Node* root) {&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;</pre><div class='AssertionParagraph'><div class='expl'>We can only remove the maximum from a non-empty tree!</div>NonEmptyTree(root, S)</div></div>
<e:displaycode>
  assert(root != null);
&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;</pre><div class='CommentParagraph'>We're going to put the return values here.</div></div>
<e:displaycode>  int max;
  Node* newRoot;
&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;</pre><div class='AssertionParagraph'><div class='expl'>Open NonEmptyTree(root, S).</div>∃v. TopOfTree(root, v, S).</div></div>

<div class='section'><pre class='indent'>&#160;&#160;</pre><div class='AssertionParagraph'><div class='expl'>Open TopOfTree.</div>∃v,l,r,L,R.<br /><span class='assertionIndent'> &#160;&#160;</span>root↦v,l,r<br /><span class='assertionIndent'> &#160;&#160;</span>∗ Tree(l, L)<br /><span class='assertionIndent'> &#160;&#160;</span>∗ Tree(r, R)<br /><span class='assertionIndent'> &#160;&#160;</span>∧ Compose(L, v, R, S).</div></div>
<e:displaycode>
  auto r = root.c[1];
&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;</pre><div class='AssertionParagraph'><div class='expl'>Take `r` out of quantification.</div>∃v,l,L,R.<br /><span class='assertionIndent'> &#160;&#160;</span>root↦v,l,r<br /><span class='assertionIndent'> &#160;&#160;</span>∗ Tree(l, L)<br /><span class='assertionIndent'> &#160;&#160;</span>∗ Tree(r, R)<br /><span class='assertionIndent'> &#160;&#160;</span>∧ Compose(L, v, R, S).</div></div>
<e:displaycode>
  if(!r) {&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;</pre><div class='AssertionParagraph'><div class='expl'>Assert if-condition.  Discard EmptyTree.  The right child is null, so the maximum is at the root.  The rest of the set is in the LHS.</div>∃v,l,L.<br /><span class='assertionIndent'> &#160;&#160;</span>root↦v,l,null<br /><span class='assertionIndent'> &#160;&#160;</span>∗ Tree(l, L)<br /><span class='assertionIndent'> &#160;&#160;</span>∧ Compose(L, v, ∅, S).</div></div>

<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;</pre><div class='AssertionParagraph'><div class='expl'>Found-max (lemma on Compose).  Discard Compose.</div>∃v,l,L.<br /><span class='assertionIndent'> &#160;&#160;</span>root↦v,l,null<br /><span class='assertionIndent'> &#160;&#160;</span>∗ Tree(l, L)<br /><span class='assertionIndent'> &#160;&#160;</span>∧ v∈S ∧ ∀x∈L. x &lt; v ∧ L = S - {v}.</div></div>
<e:displaycode>
    max = root.value;
    newRoot = root.c[0];
&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;</pre><div class='AssertionParagraph'><div class='expl'>Assignment.</div>∃L.<br /><span class='assertionIndent'> &#160;&#160;</span>root↦max,newRoot,null<br /><span class='assertionIndent'> &#160;&#160;</span>∗ Tree(newRoot, L)<br /><span class='assertionIndent'> &#160;&#160;</span>∧ max∈S ∧ ∀x∈L. x &lt; max ∧ L = S - {max}.</div></div>
<e:displaycode>
    delete root;
&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;</pre><div class='AssertionParagraph'><div class='expl'>Deletion.  Rename variable.  This is our postcondition.</div>∃T.<br /><span class='assertionIndent'> &#160;&#160;</span>Tree(newRoot, T)<br /><span class='assertionIndent'> &#160;&#160;</span>∧ max∈S ∧ ∀x∈T. x &lt; max ∧ T = S - {max}.</div></div>
<e:displaycode>  }
  else {&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;</pre><div class='CommentParagraph'>We maintain a run of two nodes in the tree: current node i and its parent p.
This run moves down th