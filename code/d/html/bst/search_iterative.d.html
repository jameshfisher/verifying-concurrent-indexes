<!doctype html><html><head><meta charset='utf-8' /></head><link rel='stylesheet' type='text/css' href='google-code-prettify/prettify.css' /><link rel='stylesheet' type='text/css' href='main.css' /><script type='text/javascript' src='google-code-prettify/prettify.js'></script><script type='text/javascript'>window.onload = function() { prettyPrint(); }</script><body><pre class='prettyprint'>module bst.search_iterative;

import bst.node;
import bst.descend;


bool search(Node* root, in int value) {</pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;</pre><div class='AssertionParagraph'><div class='expl'>Function precondition.</div>Tree(root, S)</div><div class='clear'></div></div>
<pre class='prettyprint'>
  bool found = false;
</pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;</pre><div class='AssertionParagraph'><div class='expl'>Assignment.
We're going to return `found`.
That is, the following loop establishes `found ↔ (value ∈ S)`.</div>Tree(root, S) ∧ ¬found</div><div class='clear'></div></div>
<pre class='prettyprint'>
  Node* i = root;
</pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;</pre><div class='AssertionParagraph'><div class='expl'>Assignment.</div>Tree(root, S) ∧ ¬found ∧<br /><span class='assertionIndent'></span>Tree(i, S)</div><div class='clear'></div></div>
<pre class='prettyprint'></pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;</pre><div class='AssertionParagraph'><div class='expl'>a ↔ a</div>Tree(root, S) ∧ ¬found ∧<br /><span class='assertionIndent'></span>Tree(i, S) ∧ (value ∈ S) ↔ (value ∈ S)</div><div class='clear'></div></div>
<pre class='prettyprint'></pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;</pre><div class='AssertionParagraph'><div class='expl'>∃I</div>Tree(root, S) ∧ ¬found ∧<br /><span class='assertionIndent'></span>∃Q. Tree(i, Q) ∧ (value ∈ Q) ↔ (value ∈ S)</div><div class='clear'></div></div>
<pre class='prettyprint'></pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;</pre><div class='AssertionParagraph'><div class='expl'>false → anything (rule?).
This is our loop invariant.</div>Tree(root, S) ∧<br /><span class='assertionIndent'></span>∃Q. Tree(i, Q) ∧ (value ∈ Q) ↔ (value ∈ S)<br /><span class='assertionIndent'></span>∧ found → (value ∈ S)</div><div class='clear'></div></div>
<pre class='prettyprint'></pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;</pre><div class='CommentParagraph'>The size of Q strictly decreases with each iteration,
and the size of Q &gt;= 0, as the empty set is the smallest possible set.
This shows that the loop terminates.</div><div class='clear'></div></div>
<pre class='prettyprint'>
  while (i && !found) {</pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='AssertionParagraph'><div class='expl'>Loop invariant, and assert while-condition.</div>Tree(root, S) ∧<br /><span class='assertionIndent'></span>∃Q. Tree(i, Q) ∧ (value ∈ Q) ↔ (value ∈ S)<br /><span class='assertionIndent'></span>∧ found → (value ∈ S)<br /><span class='assertionIndent'></span>∧ root ∧ ¬found</div><div class='clear'></div></div>
<pre class='prettyprint'></pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='AssertionParagraph'><div class='expl'>Non-null pointer is non-empty tree (lemma)</div>Tree(root, S) ∧<br /><span class='assertionIndent'></span>∃Q. NonEmptyTree(i, Q) ∧ (value ∈ Q) ↔ (value ∈ S)<br /><span class='assertionIndent'></span>∧ found → (value ∈ S)<br /><span class='assertionIndent'></span>∧ ¬found</div><div class='clear'></div></div>
<pre class='prettyprint'></pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='AssertionParagraph'><div class='expl'>Open NonEmptyTree</div>Tree(root, S) ∧<br /><span class='assertionIndent'></span>∃Q, v. TopOfTree(i, v, Q) ∧ (value ∈ Q) ↔ (value ∈ S)<br /><span class='assertionIndent'></span>∧ found → (value ∈ S)<br /><span class='assertionIndent'></span>∧ ¬found</div><div class='clear'></div></div>
<pre class='prettyprint'>
    if (value == i.value) {</pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='AssertionParagraph'><div class='expl'>Assert if-condition.  Equality.</div>Tree(root, S) ∧<br /><span class='assertionIndent'></span>∃Q. TopOfTree(i, value, Q) ∧ (value ∈ Q) ↔ (value ∈ S)<br /><span class='assertionIndent'></span>∧ found → (value ∈ S)<br /><span class='assertionIndent'></span>∧ ¬found</div><div class='clear'></div></div>
<pre class='prettyprint'></pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='AssertionParagraph'><div class='expl'>Root value in set (lemma).</div>Tree(root, S) ∧<br /><span class='assertionIndent'></span>∃Q.<br /><span class='assertionIndent'>&nbsp;&nbsp;</span>TopOfTree(i, value, Q) ∧<br /><span class='assertionIndent'>&nbsp;&nbsp;</span>(value ∈ Q) ↔ (value ∈ S) ∧<br /><span class='assertionIndent'>&nbsp;&nbsp;</span>value ∈ Q<br /><span class='assertionIndent'></span>∧ found → (value ∈ S)<br /><span class='assertionIndent'></span>∧ ¬found</div><div class='clear'></div></div>
<pre class='prettyprint'></pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='AssertionParagraph'><div class='expl'>→.  Weaken TopOfTree.</div>Tree(root, S) ∧<br /><span class='assertionIndent'></span>∃Q. Tree(i, Q) ∧ (value ∈ Q) ↔ (value ∈ S)<br /><span class='assertionIndent'></span>value ∈ S ∧ ¬found</div><div class='clear'></div></div>
<pre class='prettyprint'>
      found = true;
</pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='AssertionParagraph'><div class='expl'>Assignment.</div>Tree(root, S) ∧<br /><span class='assertionIndent'></span>∃Q. Tree(i, Q) ∧ (value ∈ Q) ↔ (value ∈ S)<br /><span class='assertionIndent'></span>value ∈ S ∧ found</div><div class='clear'></div></div>
<pre class='prettyprint'></pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='AssertionParagraph'><div class='expl'>→.  Re-establish invariant.</div>Tree(root, S) ∧<br /><span class='assertionIndent'></span>∃Q. Tree(i, Q) ∧ (value ∈ Q) ↔ (value ∈ S)<br /><span class='assertionIndent'></span>∧ found → (value ∈ S)</div><div class='clear'></div></div>
<pre class='prettyprint'>    }
    else {
      Node* next = descend(i, value);
      i = next;
    }
  }
  return found;
}
</pre></body></html>