<!doctype html><html><head><meta charset='utf-8' /></head><link rel='stylesheet' type='text/css' href='google-code-prettify/prettify.css' /><link rel='stylesheet' type='text/css' href='main.css' /><script type='text/javascript' src='google-code-prettify/prettify.js'></script><script type='text/javascript'>window.onload = function() { prettyPrint(); }</script><body><pre class='prettyprint'>module rb.insert;

import std.stdio;

import rb.node;

import rb.rotate;

Node * insert_rec(Node * root, int value) {

  Node * o;</pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;</pre><div class='CommentParagraph'>We are going to return o.</div><div class='clear'></div></div>
<pre class='prettyprint'>
  if (root == null) {</pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='CommentParagraph'>insertion into the empty set is just a red node.</div><div class='clear'></div></div>
<pre class='prettyprint'>    o = new Node(value);
  }
  else if (value == root.value) {</pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='CommentParagraph'>the tree already contains the value. Already a valid tree. No adjustment required.</div><div class='clear'></div></div>
<pre class='prettyprint'>    o = root;
  }
  else {</pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='CommentParagraph'>We have to insert value into a subtree.</div><div class='clear'></div></div>
<pre class='prettyprint'>
    int dir = root.value < value;  // We need to insert in that subtree.

    Node ** into = &root.c[dir];
    *into = insert_rec(*into, value); // Do the insert.
</pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='CommentParagraph'>Now, insert may have passed up a red node.
If we have room, make a home for it here; otherwise pass up again.</div><div class='clear'></div></div>
<pre class='prettyprint'>
    if (red(*into)) {</pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='CommentParagraph'>A red node was passed up.  Make room, or pass it up again.</div><div class='clear'></div></div>
<pre class='prettyprint'>
      Node ** sibling = &root.c[!dir];

      if (red(*sibling)) {</pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='CommentParagraph'>The sibling is red at height N-1.  Implies root is black, at height N.</div><div class='clear'></div></div>
<pre class='prettyprint'>
        (*sibling).black = true;  // Turn sibling into black tree (height N).
        (*into).black = true;     // Set passed-up node black.  If it passed by an RV'd tree, that's fixed by it.  Is now BT(N).
        root.black = false;       // Then turn `root` into red tree at height N.  We've pushed the red up the tree.
      }
      else {</pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='CommentParagraph'>The sibling is black.  root maybe red.</div><div class='clear'></div></div>
<pre class='prettyprint'>        Node ** far_child = &(*into).c[dir];
        if (red(*far_child)) {</pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='CommentParagraph'>into is red, far child is red.  RV.  sibling is black.</div><div class='clear'></div></div>
<pre class='prettyprint'></pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='CommentParagraph'>        root, R/B  &lt;== was previously either BT(N) or RT(N-1)
      /           \
     /             \
sibling, B(N-1)   into, RVT(dir, N-1)
                   /       \
                  /         \
    near child, B(TN-1)    far child, R(N-1)</div><div class='clear'></div></div>
<pre class='prettyprint'>
          rb.rotate.single_ptr(&root, !dir);
</pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='CommentParagraph'>           --into, B(N)--
          /              \
         /                \
       root, R(N-1)    far child, R(N-1)
      /           \
     /             \
 sibling, B(N-1)   near child, BT(N-1)</div><div class='clear'></div></div>
<pre class='prettyprint'></pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='CommentParagraph'>Rebalancing stops here.</div><div class='clear'></div></div>
<pre class='prettyprint'>        }
        else {</pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='CommentParagraph'>far child is black.</div><div class='clear'></div></div>
<pre class='prettyprint'>          Node ** near_child = &(*into).c[!dir];
          if (red(*near_child)) {</pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='CommentParagraph'>near child is red.</div><div class='clear'></div></div>
<pre class='prettyprint'></pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='CommentParagraph'>        root, R/B  &lt;== was previously either BT(N) or RT(N-1)
      /           \
     /             \
sibling, B(N-1)   into, RVT(!dir, N-1)
                   /           \
                  /             \
       near_child, RT(N-1)     far child, BT(N-1)
         /             \
        /               \
 near_gc, BT(N-1)  far_gc, BT(N-1)</div><div class='clear'></div></div>
<pre class='prettyprint'>
            rb.rotate.dbl_ptr(&root, !dir);
</pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='CommentParagraph'>           near child, BT(N)
          /                \
         /                  \
    root, RT(N-1)        into, RT(N-1)
   /         \            /       \
sibling,   near gc,    far gc,     far child,
BT(N-1)    BT(N-1)     BT(N-1)     BT(N-1)</div><div class='clear'></div></div>
<pre class='prettyprint'></pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='CommentParagraph'>Rebalancing stops here.</div><div class='clear'></div></div>
<pre class='prettyprint'>          }
          else {</pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='CommentParagraph'>near child is black.</div><div class='clear'></div></div>
<pre class='prettyprint'></pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='CommentParagraph'>        root, RVT(dir, N-1) or BT(N)
      /           \
     /             \
sibling, B(N-1)   into, RT(N-1)
                   /           \
                  /             \
       near_child, BT(N-1)     far child, BT(N-1)</div><div class='clear'></div></div>
<pre class='prettyprint'></pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='CommentParagraph'>Either root is black, and rebalancing stops here, or root is red, and we have an RVT to pass up.</div><div class='clear'></div></div>
<pre class='prettyprint'>          }
        }
      }
    }
    else {</pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='CommentParagraph'>No red was passed up.  We're OK.</div><div class='clear'></div></div>
<pre class='prettyprint'>    }

    o = root;
  }

  return o;
}


Node* insert_top_down_iter(Node * root, int value) {
  Node * o;

  if (root == null) {</pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='CommentParagraph'>riteln("insertion into null");</div><div class='clear'></div></div>
<pre class='prettyprint'>    o = new Node(value);
  }
  else {</pre>
<div class='section'><pre class='indent'>&nbsp;&nbsp;&nbsp;&nbsp;</pre><div class='CommentParagraph'>riteln("insertion into non-null");</div><div class='clear'></div></div>
<pre class='prettyprint'>
    Node* superroot = new Node(0); superroot.black = true;
    superroot.c[1] = root;
    int dir = 0, last;

    Node* greatgp = superroot,
          grandparent = null,
          parent = null,
          node = root;

    bool done = false;

    while (!done) {
      if (node == null) {
        parent.c[dir] = node = new Node(value);
      }

      if (red(node.c[0]) && red(node.c[1])) {
        node.black = false;
        node.c[0].black = true;
        node.c[1].black = true;
      }

      if (red(node) && red(parent)) {
        int dir2 = (greatgp.c[1] == grandparent);
        if (node == parent.c[last]) {
          greatgp.c[dir2] = rb.rotate.single(grandparent, !last);
        }
        else {
          greatgp.c[dir2] = rb.rotate.dbl(grandparent, !last);
        }
      }

      if (node.value == value) {
        done = true;
      }
      else {
        last = dir;
        dir = node.value < value;

        if (grandparent != null) greatgp = grandparent;
        grandparent = parent;
        parent = node;
        node = node.c[dir];
      }
    }

    o = superroot.c[1];
  }

  return o;
}</pre></body></html>