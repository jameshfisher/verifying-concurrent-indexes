<section class='generated_listing' xmlns='http://www.w3.org/1999/xhtml' xmlns:xi='http://www.w3.org/2001/XInclude' xmlns:e='http://eegg.github.com/htmlx' xmlns:m='http://eegg.github.com/macro'><e:displaycode>module rb.insert.recursive;

import rb.node;
import rb.rotate;

import std.stdio;

Node* insert_aux(Node* root, int value) {

  Node* o;&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;</pre><div class='CommentParagraph'>We are going to return o.</div></div>
<e:displaycode>
  if (root == null) {&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;</pre><div class='CommentParagraph'>insertion into the empty set is just a red node.</div></div>
<e:displaycode>    o = new Node(value);
  }
  else if (value == root.value) {&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;</pre><div class='CommentParagraph'>the tree already contains the value. Already a valid tree. No adjustment required.</div></div>
<e:displaycode>    o = root;
  }
  else {&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;</pre><div class='CommentParagraph'>We have to insert value into a subtree.</div></div>
<e:displaycode>
    int dir = root.value &lt; value;  // We need to insert in that subtree.

    Node** into = &amp;root.c[dir];

    bool red_before = red(*into);
    *into = insert_aux(*into, value); // Do the insert.
    bool red_after = red(*into);

    if (red_before &amp;&amp; !red_after) {
      writeln("Red -&gt; Black!");
    }
&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;</pre><div class='CommentParagraph'>Now, insert may have passed up a red node.
If we have room, make a home for it here; otherwise pass up again.</div></div>
<e:displaycode>
    if (red(*into)) {&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;&#160;&#160;</pre><div class='CommentParagraph'>A red node was passed up.  Make room, or pass it up again.</div></div>
<e:displaycode>
      Node ** sibling = &amp;root.c[!dir];

      if (red(*sibling)) {&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</pre><div class='CommentParagraph'>The sibling is red at height N-1.  Implies root is black, at height N.</div></div>
<e:displaycode>
        (*sibling).black = true;  // Turn sibling into black tree (height N).
        (*into).black = true;     // Set passed-up node black.  If it passed by an RV'd tree, that's fixed by it.  Is now BT(N).
        root.black = false;       // Then turn `root` into red tree at height N.  We've pushed the red up the tree.
      }
      else {&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</pre><div class='CommentParagraph'>The sibling is black.  root maybe red.</div></div>
<e:displaycode>        Node** far_child = &amp;(*into).c[dir];
        if (red(*far_child)) {&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</pre><div class='CommentParagraph'>into is red, far child is red.  RV.  sibling is black.</div></div>

<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</pre><div class='CommentParagraph'>        root, R/B  <== was previously either BT(N) or RT(N-1)
      /           \
     /             \
sibling, B(N-1)   into, RVT(dir, N-1)
                   /       \
                  /         \
    near child, B(TN-1)    far child, R(N-1)</div></div>
<e:displaycode>
          assert(!red(root));   // WHY???

          rb.rotate.single_ptr(&amp;root, !dir);
&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</pre><div class='CommentParagraph'>           --into, B(N)--
          /              \
         /                \
       root, R(N-1)    far child, R(N-1)
      /           \
     /             \
 sibling, B(N-1)   near child, BT(N-1)</div></div>

<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</pre><div class='CommentParagraph'>Rebalancing stops here.</div></div>
<e:displaycode>        }
        else {&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</pre><div class='CommentParagraph'>far child is black.</div></div>
<e:displaycode>          Node** near_child = &amp;(*into).c[!dir];
          if (red(*near_child)) {

            assert(!red(root));   // WHY???
&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</pre><div class='CommentParagraph'>near child is red.</div></div>

<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</pre><div class='CommentParagraph'>        root, R/B  <== was previously either BT(N) or RT(N-1)
      /           \
     /             \
sibling, B(N-1)   into, RVT(!dir, N-1)
                   /           \
                  /             \
       near_child, RT(N-1)     far child, BT(N-1)
         /             \
        /               \
 near_gc, BT(N-1)  far_gc, BT(N-1)</div></div>
<e:displaycode>
            rb.rotate.dbl_ptr(&amp;root, !dir);
&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</pre><div class='CommentParagraph'>           near child, BT(N)
          /                \
         /                  \
    root, RT(N-1)        into, RT(N-1)
   /         \            /       \
sibling,   near gc,    far gc,     far child,
BT(N-1)    BT(N-1)     BT(N-1)     BT(N-1)</div></div>

<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</pre><div class='CommentParagraph'>Rebalancing stops here.</div></div>
<e:displaycode>          }
          else {&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</pre><div class='CommentParagraph'>near child is black.</div></div>

<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</pre><div class='CommentParagraph'>        root, RVT(dir, N-1) or BT(N)
      /           \
     /             \
sibling, B(N-1)   into, RT(N-1)
                   /           \
                  /             \
       near_child, BT(N-1)     far child, BT(N-1)</div></div>

<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;</pre><div class='CommentParagraph'>Either root is black, and rebalancing stops here, or root is red, and we have an RVT to pass up.</div></div>
<e:displaycode>          }
        }
      }
    }
    else {&#160;</e:displaycode>
<div class='section'><pre class='indent'>&#160;&#160;&#160;&#160;&#160;&#160;</pre><div class='CommentParagraph'>No red was passed up.  We're OK.</div></div>
<e:displaycode>    }

    o = root;
  }

  return o;
}


Node* insert(Node* root, int value) {
  Node* r = insert_aux(root, value);
  r.black = true;
  return r;
}&#160;</e:displaycode></section>