<section xmlns="http://www.w3.org/1999/xhtml"
	 xmlns:xi="http://www.w3.org/2001/XInclude"
	 xmlns:e="http://eegg.github.com/htmlx"
	 xmlns:m="http://eegg.github.com/macro">

  <h3>Lemmata used in <m:bst/> algorithms</h3>

  Here are the boring ones:

  <ul>
    <li>
      <e:logimpl>
	<e:fst><e:and>
            <e:fst><e:pred name="Tree"><code>root</code>, <e:st n="S"/></e:pred></e:fst>
            <e:snd><e:eq><e:fst><code>root</code></e:fst><e:snd><code>null</code></e:snd></e:eq></e:snd>
	</e:and></e:fst>
	<e:snd><e:pred name="EmptyTree"><code>root</code>, <e:st n="S"/></e:pred></e:snd>
      </e:logimpl>
    </li>

    <li>
      <e:logimpl>
	<e:fst><e:pred name="EmptyTree"><code>root</code>, <e:st n="S"/></e:pred></e:fst>
	<e:snd><e:eq><e:fst><e:st n="S"/></e:fst><e:snd><m:scemp/></e:snd></e:eq></e:snd>
      </e:logimpl>
    </li>

    <li>
      <e:logimpl>
	<e:fst><e:pred name="EmptyTree"><code>root</code>, <e:st n="S"/></e:pred></e:fst>
	<e:snd><e:pred name="Tree"><code>root</code>, <e:st n="S"/></e:pred></e:snd>
      </e:logimpl>
    </li>

    <li>
      <e:logimpl>
	<e:fst><e:and>
            <e:fst><e:pred name="Tree"><code>root</code>, <e:st n="S"/></e:pred></e:fst>
            <e:snd><e:noteq><e:fst><code>root</code></e:fst><e:snd><code>null</code></e:snd></e:noteq></e:snd>
	</e:and></e:fst>
	<e:snd><e:pred name="NonEmptyTree"><code>root</code>, <e:st n="S"/></e:pred></e:snd>
      </e:logimpl>
    </li>

    <li>
      <e:logimpl>
	<e:fst><e:pred name="TopOfTree"><code>root</code>, <code>value</code>, <e:st n="S"/></e:pred></e:fst>
	<e:snd><e:in><e:fst><code>value</code></e:fst><e:snd><e:st n="S"/></e:snd></e:in></e:snd>
      </e:logimpl>
    </li>

    <li>
      <e:logimpl>
	<e:fst><e:and>
            <e:fst><e:pred name="Compose"><e:st n="L"/>, <e:var n="v"/>, <e:st n="R"/>, <e:st n="S"/></e:pred></e:fst>
            <e:snd><e:lt><e:fst><code>value</code></e:fst><e:snd><e:var n="v"/></e:snd></e:lt></e:snd>
	</e:and></e:fst>
	<e:snd><e:doubleimpl>
            <e:fst><e:in><e:fst><code>value</code></e:fst><e:snd><e:st n="L"/></e:snd></e:in></e:fst>
            <e:snd><e:in><e:fst><code>value</code></e:fst><e:snd><e:st n="S"/></e:snd></e:in></e:snd>
	</e:doubleimpl></e:snd>
      </e:logimpl>
    </li>

    <li>
      <e:logimpl>
	<e:fst><e:and>
            <e:fst><e:pred name="Compose"><e:st n="L"/>, <e:var n="v"/>, <e:st n="R"/>, <e:st n="S"/></e:pred></e:fst>
            <e:snd><e:lt><e:fst><code>value</code></e:fst><e:snd><e:var n="v"/></e:snd></e:lt></e:snd>
	</e:and></e:fst>
	<e:snd><e:pred name="Compose">
            <e:union><e:fst><e:st n="L" /></e:fst><e:snd><e:set><code>value</code></e:set></e:snd></e:union>,
            <e:var n="v"/>, <e:st n="R"/>,
            <e:union><e:fst><e:st n="S" /></e:fst><e:snd><e:set><code>value</code></e:set></e:snd></e:union>
	</e:pred></e:snd>
      </e:logimpl>
    </li>

    <li>
      Symmetrical:
      <e:logimpl>
	<e:fst><e:and>
            <e:fst><e:pred name="Compose"><e:st n="L"/>, <e:var n="v"/>, <e:st n="R"/>, <e:st n="S"/></e:pred></e:fst>
            <e:snd><e:lt><e:fst><e:var n="v"/></e:fst><e:snd><code>value</code></e:snd></e:lt></e:snd>
	</e:and></e:fst>
	<e:snd><e:pred name="Compose">
            <e:st n="L"/>, <e:var n="v"/>, 
            <e:union><e:fst><e:st n="R" /></e:fst><e:snd><e:set><code>value</code></e:set></e:snd></e:union>,
            <e:union><e:fst><e:st n="S" /></e:fst><e:snd><e:set><code>value</code></e:set></e:snd></e:union>
	</e:pred></e:snd>
      </e:logimpl>
    </li>

    <li>
      <e:logimpl>
	<e:fst><e:pred name="Compose"><m:scemp/>, <e:var n="v"/>, <e:st n="R"/>, <e:st n="S"/></e:pred></e:fst>
	<e:snd><e:eq><e:fst><e:st n="R"/></e:fst><e:snd><e:setminus><e:fst><e:st n="S"/></e:fst><e:snd><e:set><e:var n="v"/></e:set></e:snd></e:setminus></e:snd></e:eq></e:snd>
      </e:logimpl>
    </li>
  </ul>
</section>

<!--
   <p>
     From a <e:predicate>Compose</e:predicate> assertion and some value <e:var n="w"/>,
     we know which subset <e:var n="w"/> is in, if any.
     For instance, if <e:eq><e:fst><e:var n="w"/></e:fst><e:snd><e:var n="v"/></e:snd></e:eq>,
     then <e:in><e:fst><e:var n="w"/></e:fst><e:snd><e:st n="S"/></e:snd></e:in>:

     <e:derivation>

       <e:step name="givenCompose">
	 <e:derive><e:pred name="Compose"><e:st n="L"/>, <e:var n="v"/>, <e:st n="R"/>, <e:st n="S"/></e:pred></e:derive>
	 <e:by>given</e:by>
       </e:step>

       <e:step name="givenLessThan">
	 <e:derive><e:eq><e:fst><e:var n="w"/></e:fst><e:snd><e:var n="v"/></e:snd></e:eq></e:derive>
	 <e:by>given</e:by>
       </e:step>

       <e:step name="wInSetOfw">
	 <e:derive>
	   <e:in>
	     <e:fst><e:var n="w"/></e:fst>
	     <e:snd><e:set><e:var n="w"/></e:set></e:snd>
	   </e:in>
	 </e:derive>
	 <e:by>some axiom presumably</e:by>
       </e:step>

       <e:step name="wInSetOfv">
	 <e:derive>
	   <e:in>
	     <e:fst><e:var n="w"/></e:fst>
	     <e:snd><e:set><e:var n="v"/></e:set></e:snd>
	   </e:in>
	 </e:derive>
	 <e:by>
	   <e:from name="givenLessThan"/>, <e:from name="wInSetOfw"/>, equality
	 </e:by>
       </e:step>

       <e:step name="openCompose">
	 <e:derive>
	   <e:eq>
	     <e:fst>
	       <e:union>
		 <e:fst><e:st n="L"/></e:fst>
		 <e:snd>
		   <e:union>
		     <e:fst><e:set><e:var n="v"/></e:set></e:fst>
		     <e:snd><e:st n="R"/></e:snd>
		   </e:union>
		 </e:snd>
	       </e:union>
	     </e:fst>
	     <e:snd><e:st n="S"/></e:snd>
	   </e:eq> ∧<br />

	   <e:forall>
	     <e:fst>
	       <e:in><e:fst><e:var n="l"/></e:fst><e:snd><e:st n="L"/></e:snd></e:in>
	     </e:fst>
	     <e:snd>
	       <e:lt><e:fst><e:var n="l"/></e:fst><e:snd><e:var n="v"/></e:snd></e:lt>
	     </e:snd>
	   </e:forall> ∧<br />

	   <e:forall>
	     <e:fst>
	       <e:in>
		 <e:fst><e:var n="r"/></e:fst>
		 <e:snd><e:st n="R"/></e:snd>
	       </e:in>
	     </e:fst>
	     <e:snd>
	       <e:lt>
		 <e:fst><e:var n="v"/></e:fst>
		 <e:snd><e:var n="r"/></e:snd>
	       </e:lt>
	     </e:snd>
	   </e:forall>
	 </e:derive>
	 <e:by>
	   <e:from name="givenCompose"/>, open predicate
	 </e:by>
       </e:step>

       <e:step name="LuvuR">
	 <e:derive>
	   <e:eq>
	     <e:fst>
	       <e:union>
		 <e:fst><e:st n="L"/></e:fst>
		 <e:snd>
		   <e:union>
		     <e:fst><e:set><e:var n="v"/></e:set></e:fst>
		     <e:snd><e:st n="R"/></e:snd>
		   </e:union>
		 </e:snd>
	       </e:union>
	     </e:fst>
	     <e:snd><e:st n="S"/></e:snd>
	   </e:eq>
	 </e:derive>

	 <e:by>
	   <e:from name="openCompose"/>, ∧E
	 </e:by>
       </e:step>

       <e:step name="SetOfVInS">
	 <e:derive>
	   <e:subset>
	     <e:fst><e:set><e:var n="v"/></e:set></e:fst>
	     <e:snd><e:st n="S"/></e:snd>
	   </e:subset>
	 </e:derive>
	 <e:by><e:from name="LuvuR"/>, subset</e:by>
       </e:step>

       <e:step name="qed">
	 <e:derive><e:in><e:fst><e:var n="w"/></e:fst><e:snd><e:st n="S"/></e:snd></e:in></e:derive>
	 <e:by><e:from name="wInSetOfv"/>, <e:from name="SetOfVInS"/>, ?</e:by>
       </e:step>
     </e:derivation>

   </p>

<p>
  If <e:lt><e:fst><e:var n="w"/></e:fst><e:snd><e:var n="v"/></e:snd></e:lt>,
  then if <e:var n="w"/> is in <e:st n="S"/> then it must be in <e:st n="L"/>,
  and <i>vice versa</i>:
  <e:note>The case for <e:lt><e:fst><e:var n="v"/></e:fst><e:snd><e:var n="w"/></e:snd></e:lt> is obviously symmetrical.</e:note>

  <e:derivation>
    <e:step name="given">
      <e:derive>
	<e:and>
	  <e:fst>
	    <e:pred name="Compose"><e:st n="L"/>, <e:var n="v"/>, <e:st n="R"/>, <e:st n="S"/></e:pred>
	  </e:fst>
	  <e:snd>
	    <e:lt><e:fst><e:var n="w"/></e:fst><e:snd><e:var n="v"/></e:snd></e:lt>
	  </e:snd>
	</e:and>
      </e:derive>
      <e:by>given</e:by>
    </e:step>

    <e:step name="compose">
      <e:derive><e:pred name="Compose"><e:st n="L"/>, <e:var n="v"/>, <e:st n="R"/>, <e:st n="S"/></e:pred></e:derive>
      <e:by><e:from name="given"/>, ∧E</e:by>
    </e:step>

    <e:step name="lt">
      <e:derive><e:lt><e:fst><e:var n="w"/></e:fst><e:snd><e:var n="v"/></e:snd></e:lt></e:derive>
      <e:by><e:from name="given"/>, ∧E</e:by>
    </e:step>

    <e:step name="open">
      <e:derive>
	<e:eq>
	  <e:fst>
	    <e:union>
	      <e:fst><e:st n="L"/></e:fst>
	      <e:snd>
		<e:union>
		  <e:fst><e:set><e:var n="v"/></e:set></e:fst>
		  <e:snd><e:st n="R"/></e:snd>
		</e:union>
	      </e:snd>
	    </e:union>
	  </e:fst>
	  <e:snd><e:st n="S"/></e:snd>
	</e:eq> ∧<br />

	<e:forall>
	  <e:fst>
	    <e:in><e:fst><e:var n="l"/></e:fst><e:snd><e:st n="L"/></e:snd></e:in>
	  </e:fst>
	  <e:snd>
	    <e:lt><e:fst><e:var n="l"/></e:fst><e:snd><e:var n="v"/></e:snd></e:lt>
	  </e:snd>
	</e:forall> ∧<br />

	<e:forall>
	  <e:fst>
	    <e:in>
	      <e:fst><e:var n="r"/></e:fst>
	      <e:snd><e:st n="R"/></e:snd>
	    </e:in>
	  </e:fst>
	  <e:snd>
	    <e:lt>
	      <e:fst><e:var n="v"/></e:fst>
	      <e:snd><e:var n="r"/></e:snd>
	    </e:lt>
	  </e:snd>
	</e:forall>
      </e:derive>
      <e:by><e:from name="compose"/>, open predicate</e:by>
    </e:step>

    <e:step name="LuvuR">
      <e:derive>
	<e:eq>
	  <e:fst>
	    <e:union>
	      <e:fst><e:st n="L"/></e:fst>
	      <e:snd>
		<e:union>
		  <e:fst><e:set><e:var n="v"/></e:set></e:fst>
		  <e:snd><e:st n="R"/></e:snd>
		</e:union>
	      </e:snd>
	    </e:union>
	  </e:fst>
	  <e:snd><e:st n="S"/></e:snd>
	</e:eq>
      </e:derive>
      <e:by><e:from name="open"/>, ∧E</e:by>
    </e:step>

    <e:step name="LsubsetS">
      <e:derive>
	<e:subset>
	  <e:fst><e:st n="L"/></e:fst>
	  <e:snd><e:st n="S"/></e:snd>
	</e:subset>
      </e:derive>
      <e:by><e:from name="LuvuR"/>, subset</e:by>
    </e:step>

    <e:step name="assumewInL" indent="indent1">
      <e:derive>
	<e:in>
	  <e:fst><e:var n="w"/></e:fst>
	  <e:snd><e:st n="L"/></e:snd>
	</e:in>
      </e:derive>
      <e:by>assume</e:by>
    </e:step>

    <e:step name="thenwInS" indent="indent1">
      <e:derive>
	<e:in>
	  <e:fst><e:var n="w"/></e:fst>
	  <e:snd><e:st n="S"/></e:snd>
	</e:in>
      </e:derive>
      <e:by><e:from name="LsubsetS"/>, <e:from name="assumewInL"/>, member of subset in set</e:by>
    </e:step>

    <e:step name="wInLImplieswInS">
      <e:derive>
	<e:impl>
	  <e:fst><e:in><e:fst><e:var n="w"/></e:fst><e:snd><e:st n="L"/></e:snd></e:in></e:fst>
	  <e:snd><e:in><e:fst><e:var n="w"/></e:fst><e:snd><e:st n="S"/></e:snd></e:in></e:snd>
	</e:impl>
      </e:derive>
      <e:by><e:from name="assumewInL"/>, <e:from name="thenwInS"/>, →I</e:by>
    </e:step>

    <e:step name="noteq">
      <e:derive>
	<e:noteq>
	  <e:fst><e:var n="w"/></e:fst>
	  <e:snd><e:var n="v"/></e:snd>
	</e:noteq>
      </e:derive>
      <e:by><e:from name="lt" />, weakening</e:by>
    </e:step>

    <e:step name="wNotInSetOfV">
      <e:derive>
	<e:notin>
	  <e:fst><e:var n="w"/></e:fst>
	  <e:snd><e:set><e:var n="v"/></e:set></e:snd>
	</e:notin>
      </e:derive>
      <e:by><e:from name="noteq"/>, ?</e:by>
    </e:step>

    <e:step name="allInRGreaterThanv">
      <e:derive>
	<e:forall>
	  <e:fst>
	    <e:in>
	      <e:fst><e:var n="r"/></e:fst>
	      <e:snd><e:st n="R"/></e:snd>
	    </e:in>
	  </e:fst>
	  <e:snd>
	    <e:lt>
	      <e:fst><e:var n="v"/></e:fst>
	      <e:snd><e:var n="r"/></e:snd>
	    </e:lt>
	  </e:snd>
	</e:forall>
      </e:derive>
      <e:by><e:from name="open"/>, ∧E</e:by>
    </e:step>

    <e:step name="wNotInR">
      <e:derive>
	<e:notin>
	  <e:fst><e:var n="w"/></e:fst>
	  <e:snd><e:st n="R"/></e:snd>
	</e:notin>
      </e:derive>
      <e:by><e:from name="lt"/>, <e:from name="allInRGreaterThanv"/>, <e:var n="w"/> cannot satisfy membership criterion</e:by>
    </e:step>

    <e:step name="wNotInvOrR">
      <e:derive>
	<e:notin>
	  <e:fst><e:var n="w"/></e:fst>
	  <e:snd>(<e:union><e:fst><e:set><e:var n="v"/></e:set></e:fst><e:snd><e:st n="R"/></e:snd></e:union>)</e:snd>
	</e:notin>
      </e:derive>
      <e:by><e:from name="wNotInSetOfv"/>, <e:from name="wNotInR" />, not in union</e:by>
    </e:step>

    <e:step name="assumewInS" indent="indent1">
      <e:derive>
	<e:in>
	  <e:fst><e:var n="w"/></e:fst>
	  <e:snd><e:st n="S"/></e:snd>
	</e:in>
      </e:derive>
      <e:by>assume</e:by>
    </e:step>

    <e:step name="thenwInL" indent="indent1">
      <e:derive>
	<e:in>
	  <e:fst><e:var n="w"/></e:fst>
	  <e:snd><e:st n="L"/></e:snd>
	</e:in>
      </e:derive>
      <e:by><e:from name="LuvuR"/>, <e:from name="wNotInvOrR" />, <e:from name="assumewInS"/>, ??</e:by>
    </e:step>

    <e:step name="wInSImplieswInL">
      <e:derive>
	<e:impl>
	  <e:fst>
	    <e:in>
	      <e:fst><e:var n="w"/></e:fst>
	      <e:snd><e:st n="S"/></e:snd>
	    </e:in>
	  </e:fst>
	  <e:snd>
	    <e:in>
	      <e:fst><e:var n="w"/></e:fst>
	      <e:snd><e:st n="L"/></e:snd>
	    </e:in>
	  </e:snd>
	</e:impl>
      </e:derive>
      <e:by><e:from name="assumewInS"/>, <e:from name="thenwInL"/>, →I</e:by>
    </e:step>

    <e:step name="qed">
      <e:derive>
	<e:doubleimpl>
	  <e:fst>
	    <e:in>
	      <e:fst><e:var n="w"/></e:fst>
	      <e:snd><e:st n="L"/></e:snd>
	    </e:in>
	  </e:fst>
	  <e:snd>
	    <e:in>
	      <e:fst><e:var n="w"/></e:fst>
	      <e:snd><e:st n="S"/></e:snd>
	    </e:in>
	  </e:snd>
	</e:doubleimpl>
      </e:derive>
      <e:by><e:from name="wInLImplieswInS" />, <e:from name="wInSImplieswInL" />, ↔I</e:by>
    </e:step>
  </e:derivation>
</p>

<p>
  If <e:var n="R"/> is the empty set, then <e:var n="v"/> is the maximum in the set:

  <e:derivation>
    <e:step name="given">
      <e:derive>
	<e:pred name="Compose"><e:st n="L"/>, <e:var n="v"/>, <m:empty/>, <e:st n="S"/></e:pred>
      </e:derive>
      <e:by>given</e:by>
    </e:step>

    <e:step name="qed">
      <e:derive>
	<e:and>
	  <e:fst>
	    <e:in><e:fst><e:var n="v"/></e:fst><e:snd><e:st n="S"/></e:snd></e:in>
	  </e:fst>
	  <e:snd>∀x∈L. x &lt; v ∧ L = S - {v}</e:snd>
	</e:and>
      </e:derive>
      <e:by></e:by>
    </e:step>
  </e:derivation>

</p>



<p>
  Given a <e:predicate>Tree</e:predicate> pointer,
  we can find out whether it is an <e:predicate>EmptyTree</e:predicate> or an <e:predicate>NonEmptyTree</e:predicate>
  by testing whether the pointer is <code>null</code>.
  That is,
  <e:impl>
    <e:fst>
      <e:and>
	<e:fst><e:pred name="Tree"><code>n</code>, <e:st n="S"/></e:pred></e:fst>
	<e:snd><e:eq><e:fst><code>n</code></e:fst><e:snd><code>null</code></e:snd></e:eq></e:snd>
      </e:and>
    </e:fst>
    <e:snd><e:pred name="EmptyTree"><code>n</code>, <e:st n="S"/></e:pred></e:snd>
  </e:impl>, and
  <e:impl>
    <e:fst>
      <e:and>
	<e:fst><e:pred name="Tree"><code>n</code>, <e:st n="S"/></e:pred></e:fst>
	<e:snd><e:noteq><e:fst><code>n</code></e:fst><e:snd><code>null</code></e:snd></e:noteq></e:snd>
      </e:and>
    </e:fst>
    <e:snd><e:pred name="NonEmptyTree"><code>n</code>, <e:st n="S"/></e:pred></e:snd>
  </e:impl>.
  This follows from <code>null</code> not being in the domain of the heap; <m:ie/>,
  <e:impl>
    <e:fst><e:fcell><e:fst><code>n</code></e:fst><e:snd>…</e:snd></e:fcell></e:fst>
    <e:snd><e:noteq><e:fst><code>n</code></e:fst><e:snd><code>null</code></e:snd></e:noteq></e:snd>
  </e:impl>.
</p>
-->


