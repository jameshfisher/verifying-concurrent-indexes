<section xmlns="http://www.w3.org/1999/xhtml"
	 xmlns:xi="http://www.w3.org/2001/XInclude"
	 xmlns:e="http://eegg.github.com/htmlx"
	 xmlns:m="http://eegg.github.com/macro">

  <e:h><e:logimpl>
      <e:pred name="TCompose"><e:st n="L"/>, <e:var n="v"/>, <m:empty/>, <e:st n="S"/></e:pred>
      <e:pred name="Max"><e:var n="v"/>, <e:st n="S"/></e:pred>
  </e:logimpl></e:h>

  <p>
    This is used by <code>removeMax</code> to identify the maximum element:
    if the right subtree is empty, then the root holds the maximum element in the set.
  </p>

  <div class="display"><xi:include href="RightIsEmptyRootIsMax.svg"/></div>

  <e:derivation>
    <e:step name="given">
      <e:derive><e:pred name="TCompose"><e:st n="L"/>, <e:var n="v"/>, <m:empty/>, <e:st n="S"/></e:pred></e:derive>
      <e:by>given</e:by>
    </e:step>

    <e:step name="openCompose">
      <e:derive>
	<e:eq>
	  
	    <e:union>
	      <e:st n="L"/>
	      
		<e:union>
		  <e:set><e:var n="v"/></e:set>
		  <m:empty/>
		</e:union>
	      
	    </e:union>
	  
	  <e:st n="S"/>
	</e:eq> ∧
	<e:forall>
	  <e:vars>
	    <e:in><e:var n="l"/><e:st n="L"/></e:in>
	  </e:vars>
	  <e:expr>
	    <e:lt><e:var n="l"/><e:var n="v"/></e:lt>
	  </e:expr>
	</e:forall> ∧
	<e:forall>
	  <e:vars>
	    <e:in>
	      <e:var n="r"/>
	      <m:empty/>
	    </e:in>
	  </e:vars>
	  <e:expr>
	    <e:lt>
	      <e:var n="v"/>
	      <e:var n="r"/>
	    </e:lt>
	  </e:expr>
	</e:forall>
      </e:derive>
      <e:by><e:from name="given"/>, open predicate</e:by>
    </e:step>

    <e:step name="LUvURIsS">
      <e:derive><e:eq>
	  
	    <e:union>
	      <e:st n="L"/>
	      
		<e:union>
		  <e:set><e:var n="v"/></e:set>
		  <m:empty/>
		</e:union>
	      
	    </e:union>
	  
	  <e:st n="S"/>
      </e:eq></e:derive>
      <e:by><e:from name="openCompose"/>, <m:andElim/></e:by>
    </e:step>

    <e:step name="AllInLltv">
      <e:derive><e:forall>
	  <e:vars>
	    <e:in><e:var n="l"/><e:st n="L"/></e:in>
	  </e:vars>
	  <e:expr>
	    <e:lt><e:var n="l"/><e:var n="v"/></e:lt>
	  </e:expr>
      </e:forall></e:derive>
      <e:by><e:from name="openCompose"/>, <m:andElim/></e:by>
    </e:step>

    <e:step name="vSubsetS">
      <e:derive><e:subset>
	  <e:set><e:var n="v"/></e:set>
	  <e:st n="S"/>
      </e:subset></e:derive>
      <e:by><e:from name="LUvURIsS"/></e:by>
    </e:step>

    <e:step name="vInSetOfv">
      <e:derive><e:in>
	  <e:var n="v"/>
	  <e:set><e:var n="v"/></e:set>
      </e:in></e:derive>
      <e:by></e:by>
    </e:step>

    <e:step name="vInS">
      <e:derive><e:in>
	  <e:var n="v"/>
	  <e:st n="S"/>
      </e:in></e:derive>
      <e:by><e:from name="vInSetOfv"/>, <e:from name="vSubsetS"/>, member of subset member of set</e:by>
    </e:step>

    <e:step name="vEqv">
      <e:derive><e:eq>
	  <e:var n="v"/>
	  <e:var n="v"/>
      </e:eq></e:derive>
      <e:by></e:by>
    </e:step>

    <e:step name="vLeqv">
      <e:derive><e:leq>
	  <e:var n="v"/>
	  <e:var n="v"/>
      </e:leq></e:derive>
      <e:by><e:from name="vEqv"/>, weakening</e:by>
    </e:step>

    <e:step name="AllInvLeqv">
      <e:derive><e:forall>
	  <e:vars><e:in>
	      <e:var n="s"/>
	      <e:set><e:var n="v"/></e:set>
	  </e:in></e:vars>
	  <e:expr><e:leq>
	      <e:var n="s"/>
	      <e:var n="v"/>
	  </e:leq></e:expr>
      </e:forall></e:derive>
      <e:by><e:from name="vLeqv"/>, ??</e:by>
    </e:step>

    <e:step name="AllInLleqv">
      <e:derive><e:forall>
	  <e:vars>
	    <e:in><e:var n="s"/><e:st n="L"/></e:in>
	  </e:vars>
	  <e:expr>
	    <e:leq><e:var n="s"/><e:var n="v"/></e:leq>
	  </e:expr>
      </e:forall></e:derive>
      <e:by><e:from name="AllInLltv"/>, weakening</e:by>
    </e:step>

    <e:step name="AllinLUvleqv">
      <e:derive><e:forall>
	  <e:vars><e:in>
	      <e:var n="s"/>
	      (<e:union>
		  <e:st n="L"/>
		  <e:set><e:var n="v"/></e:set>
	      </e:union>)
	  </e:in></e:vars>
	  <e:expr><e:leq>
	      <e:var n="s"/>
	      <e:var n="v"/>
	  </e:leq></e:expr>
      </e:forall></e:derive>
      <e:by><e:from name="AllInvLeqv"/>, <e:from name="AllInLleqv"/>, <m:trueOfSubsetMembersTrueOfSetMembers/></e:by>
    </e:step>

    <e:step name="LUvIsS">
      <e:derive><e:eq>
	  
	    <e:union>
	      <e:st n="L"/>
	      <e:set><e:var n="v"/></e:set>
	    </e:union>
	  
	  <e:st n="S"/>
      </e:eq></e:derive>
      <e:by><e:from name="LUvURIsS"/>, <m:unionWithEmptyIsSet/></e:by>
    </e:step>

    <e:step name="AllInSLeqv">
      <e:derive><e:forall>
	  <e:vars><e:in>
	      <e:var n="s"/>
	      <e:st n="S"/>
	  </e:in></e:vars>
	  <e:expr><e:leq>
	      <e:var n="s"/>
	      <e:var n="v"/>
	  </e:leq></e:expr>
      </e:forall></e:derive>
      <e:by><e:from name="AllinLUvleqv"/>, <e:from name="LUvIsS"/>, substitution</e:by>
    </e:step>

    <e:step name="maxParts">
      <e:derive><e:and>
	  <e:in>
	      <e:var n="v"/>
	      <e:st n="S"/>
	  </e:in>
	  <e:forall>
	      <e:vars><e:in>
		  <e:var n="s"/>
		  <e:st n="S"/>
	      </e:in></e:vars>
	      <e:expr><e:leq>
		  <e:var n="s"/>
		  <e:var n="v"/>
	      </e:leq></e:expr>
	  </e:forall>
      </e:and></e:derive>
      <e:by><e:from name="vInS"/>, <e:from name="AllInSLeqv"/>, <m:andIntro/></e:by>
    </e:step>

    <e:step name="qed">
      <e:derive><e:pred name="Max"><e:var n="v"/>, <e:st n="S"/></e:pred></e:derive>
      <e:by><e:from name="maxParts"/>, close predicate</e:by>
    </e:step>
  </e:derivation>

</section>
