<section xmlns="http://www.w3.org/1999/xhtml"
	 xmlns:xi="http://www.w3.org/2001/XInclude"
	 xmlns:e="http://eegg.github.com/htmlx"
	 xmlns:m="http://eegg.github.com/macro">

  <e:h><e:logimpl>
      <e:fst><e:pred name="TreeCompose"><e:st n="L"/>, <e:var n="v"/>, <m:scemp/>, <e:st n="S"/></e:pred></e:fst>
      <e:snd><e:pred name="Max"><e:var n="v"/>, <e:st n="S"/></e:pred></e:snd>
  </e:logimpl></e:h>

  <p>
    This is used by <code>removeMax</code> to identify the maximum element:
    if the right subtree is empty, then the root holds the maximum element in the set.
  </p>

  <div class="display"><xi:include href="RightIsEmptyRootIsMax.svg"/></div>

  <e:derivation>
    <e:step name="given">
      <e:derive><e:pred name="TreeCompose"><e:st n="L"/>, <e:var n="v"/>, <m:scemp/>, <e:st n="S"/></e:pred></e:derive>
      <e:by>given</e:by>
    </e:step>

    <e:step name="openCompose">
      <e:derive>
	<e:eq>
	  <e:fst>
	    <e:union>
	      <e:fst><e:st n="L"/></e:fst>
	      <e:snd>
		<e:union>
		  <e:fst><e:set><e:var n="v"/></e:set></e:fst>
		  <e:snd><m:scemp/></e:snd>
		</e:union>
	      </e:snd>
	    </e:union>
	  </e:fst>
	  <e:snd><e:st n="S"/></e:snd>
	</e:eq> ∧
	<e:forall>
	  <e:fst>
	    <e:in><e:fst><e:var n="l"/></e:fst><e:snd><e:st n="L"/></e:snd></e:in>
	  </e:fst>
	  <e:snd>
	    <e:lt><e:fst><e:var n="l"/></e:fst><e:snd><e:var n="v"/></e:snd></e:lt>
	  </e:snd>
	</e:forall> ∧
	<e:forall>
	  <e:fst>
	    <e:in>
	      <e:fst><e:var n="r"/></e:fst>
	      <e:snd><m:scemp/></e:snd>
	    </e:in>
	  </e:fst>
	  <e:snd>
	    <e:lt>
	      <e:fst><e:var n="v"/></e:fst>
	      <e:snd><e:var n="r"/></e:snd>
	    </e:lt>
	  </e:snd>
	</e:forall>
      </e:derive>
      <e:by><e:from name="given"/>, open predicate</e:by>
    </e:step>

    <e:step name="LUvURIsS">
      <e:derive><e:eq>
	  <e:fst>
	    <e:union>
	      <e:fst><e:st n="L"/></e:fst>
	      <e:snd>
		<e:union>
		  <e:fst><e:set><e:var n="v"/></e:set></e:fst>
		  <e:snd><m:scemp/></e:snd>
		</e:union>
	      </e:snd>
	    </e:union>
	  </e:fst>
	  <e:snd><e:st n="S"/></e:snd>
      </e:eq></e:derive>
      <e:by><e:from name="openCompose"/>, <m:andElim/></e:by>
    </e:step>

    <e:step name="AllInLltv">
      <e:derive><e:forall>
	  <e:fst>
	    <e:in><e:fst><e:var n="l"/></e:fst><e:snd><e:st n="L"/></e:snd></e:in>
	  </e:fst>
	  <e:snd>
	    <e:lt><e:fst><e:var n="l"/></e:fst><e:snd><e:var n="v"/></e:snd></e:lt>
	  </e:snd>
      </e:forall></e:derive>
      <e:by><e:from name="openCompose"/>, <m:andElim/></e:by>
    </e:step>

    <e:step name="vSubsetS">
      <e:derive><e:subset>
	  <e:fst><e:set><e:var n="v"/></e:set></e:fst>
	  <e:snd><e:st n="S"/></e:snd>
      </e:subset></e:derive>
      <e:by><e:from name="LUvURIsS"/></e:by>
    </e:step>

    <e:step name="vInSetOfv">
      <e:derive><e:in>
	  <e:fst><e:var n="v"/></e:fst>
	  <e:snd><e:set><e:var n="v"/></e:set></e:snd>
      </e:in></e:derive>
      <e:by></e:by>
    </e:step>

    <e:step name="vInS">
      <e:derive><e:in>
	  <e:fst><e:var n="v"/></e:fst>
	  <e:snd><e:st n="S"/></e:snd>
      </e:in></e:derive>
      <e:by><e:from name="vInSetOfv"/>, <e:from name="vSubsetS"/>, member of subset member of set</e:by>
    </e:step>

    <e:step name="vEqv">
      <e:derive><e:eq>
	  <e:fst><e:var n="v"/></e:fst>
	  <e:snd><e:var n="v"/></e:snd>
      </e:eq></e:derive>
      <e:by></e:by>
    </e:step>

    <e:step name="vLeqv">
      <e:derive><e:leq>
	  <e:fst><e:var n="v"/></e:fst>
	  <e:snd><e:var n="v"/></e:snd>
      </e:leq></e:derive>
      <e:by><e:from name="vEqv"/>, weakening</e:by>
    </e:step>

    <e:step name="AllInvLeqv">
      <e:derive><e:forall>
	  <e:fst><e:in>
	      <e:fst><e:var n="s"/></e:fst>
	      <e:snd><e:set><e:var n="v"/></e:set></e:snd>
	  </e:in></e:fst>
	  <e:snd><e:leq>
	      <e:fst><e:var n="s"/></e:fst>
	      <e:snd><e:var n="v"/></e:snd>
	  </e:leq></e:snd>
      </e:forall></e:derive>
      <e:by><e:from name="vLeqv"/>, ??</e:by>
    </e:step>

    <e:step name="AllInLleqv">
      <e:derive><e:forall>
	  <e:fst>
	    <e:in><e:fst><e:var n="s"/></e:fst><e:snd><e:st n="L"/></e:snd></e:in>
	  </e:fst>
	  <e:snd>
	    <e:leq><e:fst><e:var n="s"/></e:fst><e:snd><e:var n="v"/></e:snd></e:leq>
	  </e:snd>
      </e:forall></e:derive>
      <e:by><e:from name="AllInLltv"/>, weakening</e:by>
    </e:step>

    <e:step name="AllinLUvleqv">
      <e:derive><e:forall>
	  <e:fst><e:in>
	      <e:fst><e:var n="s"/></e:fst>
	      <e:snd>(<e:union>
		  <e:fst><e:st n="L"/></e:fst>
		  <e:snd><e:set><e:var n="v"/></e:set></e:snd>
	      </e:union>)</e:snd>
	  </e:in></e:fst>
	  <e:snd><e:leq>
	      <e:fst><e:var n="s"/></e:fst>
	      <e:snd><e:var n="v"/></e:snd>
	  </e:leq></e:snd>
      </e:forall></e:derive>
      <e:by><e:from name="AllInvLeqv"/>, <e:from name="AllInLleqv"/>, <m:trueOfSubsetMembersTrueOfSetMembers/></e:by>
    </e:step>

    <e:step name="LUvIsS">
      <e:derive><e:eq>
	  <e:fst>
	    <e:union>
	      <e:fst><e:st n="L"/></e:fst>
	      <e:snd><e:set><e:var n="v"/></e:set></e:snd>
	    </e:union>
	  </e:fst>
	  <e:snd><e:st n="S"/></e:snd>
      </e:eq></e:derive>
      <e:by><e:from name="LUvURIsS"/>, <m:unionWithEmptyIsSet/></e:by>
    </e:step>

    <e:step name="AllInSLeqv">
      <e:derive><e:forall>
	  <e:fst><e:in>
	      <e:fst><e:var n="s"/></e:fst>
	      <e:snd><e:st n="S"/></e:snd>
	  </e:in></e:fst>
	  <e:snd><e:leq>
	      <e:fst><e:var n="s"/></e:fst>
	      <e:snd><e:var n="v"/></e:snd>
	  </e:leq></e:snd>
      </e:forall></e:derive>
      <e:by><e:from name="AllinLUvleqv"/>, <e:from name="LUvIsS"/>, substitution</e:by>
    </e:step>

    <e:step name="maxParts">
      <e:derive><e:and>
	  <e:fst><e:in>
	      <e:fst><e:var n="v"/></e:fst>
	      <e:snd><e:st n="S"/></e:snd>
	  </e:in></e:fst>
	  <e:snd><e:forall>
	      <e:fst><e:in>
		  <e:fst><e:var n="s"/></e:fst>
		  <e:snd><e:st n="S"/></e:snd>
	      </e:in></e:fst>
	      <e:snd><e:leq>
		  <e:fst><e:var n="s"/></e:fst>
		  <e:snd><e:var n="v"/></e:snd>
	      </e:leq></e:snd>
	  </e:forall></e:snd>
      </e:and></e:derive>
      <e:by><e:from name="vInS"/>, <e:from name="AllInSLeqv"/>, <m:andIntro/></e:by>
    </e:step>

    <e:step name="qed">
      <e:derive><e:pred name="Max"><e:var n="v"/>, <e:st n="S"/></e:pred></e:derive>
      <e:by><e:from name="maxParts"/>, close predicate</e:by>
    </e:step>
  </e:derivation>

</section>
