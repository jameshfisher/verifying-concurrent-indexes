<section xmlns="http://www.w3.org/1999/xhtml"
	 xmlns:xi="http://www.w3.org/2001/XInclude"
	 xmlns:e="http://eegg.github.com/htmlx"
	 xmlns:m="http://eegg.github.com/macro">

  <h4><e:logimpl>
      <e:fst><e:and>
          <e:fst><e:pred name="Compose"><e:var n="v"/>, <e:st n="T"/>, <e:st n="S"/></e:pred></e:fst>
          <e:snd><e:lt><e:fst><e:var n="w"/></e:fst><e:snd><e:var n="v"/></e:snd></e:lt></e:snd>
      </e:and></e:fst>
      <e:snd><e:pred name="Compose"><e:var n="w"/>, <e:st n="S"/>, <e:union><e:fst><e:st n="S"/></e:fst><e:snd><e:set><e:var n="w"/></e:set></e:snd></e:union></e:pred></e:snd>
  </e:logimpl></h4>

  <p>
    Prepending a smaller value than that at the head of the list
    yields the desired new list in valid order.
  </p>

  <e:derivation>
    <e:step name="given">
      <e:derive><e:and>
          <e:fst><e:pred name="Compose"><e:var n="v"/>, <e:st n="T"/>, <e:st n="S"/></e:pred></e:fst>
          <e:snd><e:lt><e:fst><e:var n="w"/></e:fst><e:snd><e:var n="v"/></e:snd></e:lt></e:snd>
      </e:and></e:derive>
      <e:by>given</e:by>
    </e:step>

    <e:step name="givenCompose">
      <e:derive><e:pred name="Compose"><e:var n="v"/>, <e:st n="T"/>, <e:st n="S"/></e:pred></e:derive>
      <e:by><e:from name="given"/>, <m:andElim/></e:by>
    </e:step>

    <e:step name="givenlt">
      <e:derive><e:lt><e:fst><e:var n="w"/></e:fst><e:snd><e:var n="v"/></e:snd></e:lt></e:derive>
      <e:by><e:from name="given"/>, <m:andElim/></e:by>
    </e:step>

    <e:step name="openCompose">
      <e:derive>
	<e:eq>
	  <e:fst>
	    <e:union>
	      <e:fst><e:set><e:var n="v"/></e:set></e:fst>
	      <e:snd><e:st n="T"/></e:snd>
	    </e:union>
	  </e:fst>
	  <e:snd><e:st n="S"/></e:snd>
	</e:eq> âˆ§
	<e:forall>
	  <e:fst>
	    <e:in>
	      <e:fst><e:var n="t"/></e:fst>
	      <e:snd><e:st n="T"/></e:snd>
	    </e:in>
	  </e:fst>
	  <e:snd>
	    <e:lt>
	      <e:fst><e:var n="v"/></e:fst>
	      <e:snd><e:var n="t"/></e:snd>
	    </e:lt>
	  </e:snd>
	</e:forall>
      </e:derive>
      <e:by><e:from name="givenCompose"/>, open predicate</e:by>
    </e:step>

    <e:step name="vUTIsS">
      <e:derive><e:eq>
	  <e:fst>
	    <e:union>
	      <e:fst><e:set><e:var n="v"/></e:set></e:fst>
	      <e:snd><e:st n="T"/></e:snd>
	    </e:union>
	  </e:fst>
	  <e:snd><e:st n="S"/></e:snd>
      </e:eq></e:derive>
      <e:by><e:from name="openCompose"/>, <m:andElim/></e:by>
    </e:step>

    <e:step name="allInTGreaterThanv">
      <e:derive><e:forall>
	  <e:fst>
	    <e:in>
	      <e:fst><e:var n="t"/></e:fst>
	      <e:snd><e:st n="T"/></e:snd>
	    </e:in>
	  </e:fst>
	  <e:snd>
	    <e:lt>
	      <e:fst><e:var n="v"/></e:fst>
	      <e:snd><e:var n="t"/></e:snd>
	    </e:lt>
	  </e:snd>
      </e:forall></e:derive>
      <e:by><e:from name="openCompose"/>, <m:andElim/></e:by>
    </e:step>

    <e:step name="allInTGreaterThanvalue">
      <e:derive><e:forall>
	  <e:fst>
	    <e:in>
	      <e:fst><e:var n="t"/></e:fst>
	      <e:snd><e:st n="T"/></e:snd>
	    </e:in>
	  </e:fst>
	  <e:snd>
	    <e:lt>
	      <e:fst><e:var n="w"/></e:fst>
	      <e:snd><e:var n="t"/></e:snd>
	    </e:lt>
	  </e:snd>
      </e:forall></e:derive>
      <e:by><e:from name="allInTGreaterThanv"/>, <e:from name="givenlt"/>, transitivity of &lt; relation</e:by>
    </e:step>

    <e:step name="valueUSIsSUvalue">
      <e:derive>
	<e:eq>
	  <e:fst>
	    <e:union>
	      <e:fst><e:set><e:var n="w"/></e:set></e:fst>
	      <e:snd><e:st n="S"/></e:snd>
	    </e:union>
	  </e:fst>
	  <e:snd><e:union><e:fst><e:st n="S"/></e:fst><e:snd><e:set><e:var n="w"/></e:set></e:snd></e:union></e:snd>
	</e:eq>
      </e:derive>
      <e:by>Commutativity of set union</e:by>
    </e:step>

    <e:step name="allInvGreaterThanvalue">
      <e:derive>
	<e:forall>
	  <e:fst>
	    <e:in>
	      <e:fst><e:var n="t"/></e:fst>
	      <e:snd><e:set><e:var n="v"/></e:set></e:snd>
	    </e:in>
	  </e:fst>
	  <e:snd>
	    <e:lt>
	      <e:fst><e:var n="w"/></e:fst>
	      <e:snd><e:var n="t"/></e:snd>
	    </e:lt>
	  </e:snd>
	</e:forall>
      </e:derive>
      <e:by><e:from name="givenlt"/>, ??</e:by>
    </e:step>

    <e:step name="allInvUTGreaterThanvalue">
      <e:derive>
	<e:forall>
	  <e:fst>
	    <e:in>
	      <e:fst><e:var n="t"/></e:fst>
	      <e:snd>(<e:union>
		  <e:fst><e:set><e:var n="v"/></e:set></e:fst>
		  <e:snd><e:st n="T"/></e:snd>
	      </e:union>)</e:snd>
	    </e:in>
	  </e:fst>
	  <e:snd>
	    <e:lt>
	      <e:fst><e:var n="w"/></e:fst>
	      <e:snd><e:var n="t"/></e:snd>
	    </e:lt>
	  </e:snd>
	</e:forall>
      </e:derive>
      <e:by><e:from name="allInTGreaterThanvalue"/>, <e:from name="allInvGreaterThanvalue"/>, ?? </e:by>
    </e:step>

    <e:step name="allInSGreaterThanvalue">
      <e:derive>
	<e:forall>
	  <e:fst>
	    <e:in>
	      <e:fst><e:var n="t"/></e:fst>
	      <e:snd><e:st n="S"/></e:snd>
	    </e:in>
	  </e:fst>
	  <e:snd>
	    <e:lt>
	      <e:fst><e:var n="w"/></e:fst>
	      <e:snd><e:var n="t"/></e:snd>
	    </e:lt>
	  </e:snd>
	</e:forall>
      </e:derive>
      <e:by><e:from name="allInvUTGreaterThanvalue"/>, <e:from name="vUTIsS"/>, substitution</e:by>
    </e:step>

    <e:step name="qed">
      <e:derive><e:pred name="Compose"><e:var n="w"/>, <e:st n="S"/>, <e:union><e:fst><e:st n="S"/></e:fst><e:snd><e:set><e:var n="w"/></e:set></e:snd></e:union></e:pred></e:derive>
      <e:by><e:from name="valueUSIsSUvalue"/>, <e:from name="allInSGreaterThanvalue"/>, close predicate</e:by>
    </e:step>
  </e:derivation>
</section>
