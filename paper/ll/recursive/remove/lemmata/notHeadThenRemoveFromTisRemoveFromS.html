<e:lemma name="prependLessThanGivesNewList"
	 xmlns="http://www.w3.org/1999/xhtml"
	 xmlns:xi="http://www.w3.org/2001/XInclude"
	 xmlns:e="http://eegg.github.com/htmlx"
	 xmlns:m="http://eegg.github.com/macro">

  <e:caption><e:logimpl>
      <e:and>
          <e:pred name="ListCompose"><e:var n="v"/>, <e:st n="T"/>, <e:st n="S"/></e:pred>
          <e:noteq>
              <e:var n="v"/>
              <e:var n="w"/>
          </e:noteq>
      </e:and>
      <e:pred name="ListCompose"><e:var n="v"/>, <e:setminus><e:st n="T"/><e:set><e:var n="w"/></e:set></e:setminus>, <e:setminus><e:st n="S" /><e:set><e:var n="w"/></e:set></e:setminus></e:pred>
  </e:logimpl></e:caption>

  <e:contents>
    <e:derivation>
      <e:step name="given">
	<e:derive><e:and>
            <e:pred name="ListCompose"><e:var n="v"/>, <e:st n="T"/>, <e:st n="S"/></e:pred>
            <e:noteq>
		<e:var n="v"/>
		<e:var n="w"/>
            </e:noteq>
	</e:and></e:derive>
	<e:by>given</e:by>
      </e:step>

      <e:step name="givenCompose">
	<e:derive><e:pred name="ListCompose"><e:var n="v"/>, <e:st n="T"/>, <e:st n="S"/></e:pred></e:derive>
	<e:by><e:from name="given"/>, <m:andElim/></e:by>
      </e:step>

      <e:step name="vNotw">
	<e:derive><e:noteq>
            <e:var n="v"/>
            <e:var n="w"/>
	</e:noteq></e:derive>
	<e:by><e:from name="given"/>, <m:andElim/></e:by>
      </e:step>

      <e:step name="openCompose">
	<e:derive>
	  <e:eq>
	    
	      <e:union>
		<e:set><e:var n="v"/></e:set>
		<e:st n="T"/>
	      </e:union>
	    
	    <e:st n="S"/>
	  </e:eq> ∧
	  <e:forall>
	    <e:vars>
	      <e:in>
		<e:var n="t"/>
		<e:st n="T"/>
	      </e:in>
	    </e:vars>
	    <e:expr>
	      <e:lt>
		<e:var n="v"/>
		<e:var n="t"/>
	      </e:lt>
	    </e:expr>
	  </e:forall>
	</e:derive>
	<e:by><e:from name="givenCompose"/>, open predicate</e:by>
      </e:step>

      <e:step name="vUTIsS">
	<e:derive><e:eq>
	    
	      <e:union>
		<e:set><e:var n="v"/></e:set>
		<e:st n="T"/>
	      </e:union>
	    
	    <e:st n="S"/>
	</e:eq></e:derive>
	<e:by><e:from name="openCompose"/>, <m:andElim/></e:by>
      </e:step>

      <e:step name="allInTGreaterThanv">
	<e:derive><e:forall>
	    <e:vars>
	      <e:in>
		<e:var n="t"/>
		<e:st n="T"/>
	      </e:in>
	    </e:vars>
	    <e:expr>
	      <e:lt>
		<e:var n="v"/>
		<e:var n="t"/>
	      </e:lt>
	    </e:expr>
	  </e:forall>
	</e:derive>
	<e:by><e:from name="openCompose"/>, <m:andElim/></e:by>
      </e:step>

      <e:step name="(vUT)minuswIsSminusw">
	<e:derive><e:eq>
	    
	      <e:setminus>
		(<e:union>
		    <e:set><e:var n="v"/></e:set>
		    <e:st n="T"/>
		  </e:union>)
		<e:set><e:var n="w"/></e:set>
	      </e:setminus>
	    
	    <e:setminus><e:st n="S" /><e:set><e:var n="w"/></e:set></e:setminus>
	</e:eq></e:derive>
	<e:by><e:from name="vUTIsS"/>, equal operations</e:by>
      </e:step>

      <e:step name="vminuswUTminuswIsSminusw">
	<e:derive><e:eq>
	    
	      <e:union>
		(<e:setminus>
		    <e:set><e:var n="v"/></e:set>
		    <e:set><e:var n="w"/></e:set>
		  </e:setminus>)
		(<e:setminus>
		    <e:st n="T"/>
		    <e:set><e:var n="w"/></e:set>
		  </e:setminus>)
	      </e:union>
	    
	    <e:setminus><e:st n="S" /><e:set><e:var n="w"/></e:set></e:setminus>
	</e:eq></e:derive>
	<e:by><e:from name="(vUT)minuswIsSminusw"/>, distributivity of set minus over set union</e:by>
      </e:step>

      <e:step name="vminuswIsv">
	<e:derive><e:eq>
	    <e:setminus>
		<e:set><e:var n="v"/></e:set>
		<e:set><e:var n="w"/></e:set>
	    </e:setminus>
	    <e:set><e:var n="v"/></e:set>
	</e:eq></e:derive>
	<e:by><e:from name="vNotw"/>, ??</e:by>
      </e:step>

      <e:step name="vUTminuswIsSminusw">
	<e:derive><e:eq>
	    
	      <e:union>
		<e:set><e:var n="v"/></e:set>
		(<e:setminus><e:st n="T"/><e:set><e:var n="w"/></e:set></e:setminus>)
	      </e:union>
	    
	    (<e:setminus><e:st n="S" /><e:set><e:var n="w"/></e:set></e:setminus>)
	</e:eq></e:derive>
	<e:by><e:from name="vminuswUTminuswIsSminusw"/>, <e:from name="vminuswIsv"/>, substitution</e:by>
      </e:step>

      <e:step name="AllInTminuswGreaterThanv">
	<e:derive><e:forall>
	    <e:vars>
	      <e:in>
		<e:var n="t"/>
		(<e:setminus><e:st n="T"/><e:set><e:var n="w"/></e:set></e:setminus>)
	      </e:in>
	    </e:vars>
	    <e:expr>
	      <e:lt>
		<e:var n="v"/>
		<e:var n="t"/>
	      </e:lt>
	    </e:expr>
	</e:forall></e:derive>
	<e:by><e:from name="allInTGreaterThanv"/>, for all in set then for all in subset</e:by>
      </e:step>

      <e:step name="composeParts">
	<e:derive>
	  <e:eq>
	    
	      <e:union>
		<e:set><e:var n="v"/></e:set>
		(<e:setminus><e:st n="T"/><e:set><e:var n="w"/></e:set></e:setminus>)
	      </e:union>
	    
	    (<e:setminus><e:st n="S" /><e:set><e:var n="w"/></e:set></e:setminus>)
	  </e:eq> ∧
	  <e:forall>
	    <e:vars>
	      <e:in>
		<e:var n="t"/>
		(<e:setminus><e:st n="T"/><e:set><e:var n="w"/></e:set></e:setminus>)
	      </e:in>
	    </e:vars>
	    <e:expr>
	      <e:lt>
		<e:var n="v"/>
		<e:var n="t"/>
	      </e:lt>
	    </e:expr>
	  </e:forall>
	</e:derive>
	<e:by><e:from name="vUTminuswIsSminusw"/>, <e:from name="AllInTminuswGreaterThanv"/>, <m:andIntro/></e:by>
      </e:step>

      <e:step name="qed">
	<e:derive><e:pred name="ListCompose"><e:var n="v"/>, <e:setminus><e:st n="T"/><e:set><e:var n="w"/></e:set></e:setminus>, <e:setminus><e:st n="S" /><e:set><e:var n="w"/></e:set></e:setminus></e:pred></e:derive>
	<e:by><e:from name="composeParts"/>, close predicate</e:by>
      </e:step>
    </e:derivation>
  </e:contents>
</e:lemma>
