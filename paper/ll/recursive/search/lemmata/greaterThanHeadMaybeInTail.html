<e:lemma name="greaterThanHeadMaybeInTail"
	 xmlns="http://www.w3.org/1999/xhtml"
	 xmlns:xi="http://www.w3.org/2001/XInclude"
	 xmlns:e="http://eegg.github.com/htmlx"
	 xmlns:m="http://eegg.github.com/macro">

  <e:caption><e:logimpl>
      <e:fst><e:and>
          <e:fst><e:pred name="Compose"><e:var n="v"/>, <e:st n="T"/>, <e:st n="S"/></e:pred></e:fst>
          <e:snd><e:noteq>
	      <e:fst><e:var n="v"/></e:fst>
	      <e:snd><code>value</code></e:snd>
          </e:noteq></e:snd>
      </e:and></e:fst>
      <e:snd><e:doubleimpl>
          <e:fst><e:in>
	      <e:fst><code>value</code></e:fst>
	      <e:snd><e:st n="T"/></e:snd>
          </e:in></e:fst>
          <e:snd><e:in>
	      <e:fst><code>value</code></e:fst>
	      <e:snd><e:st n="S"/></e:snd>
          </e:in></e:snd>
      </e:doubleimpl></e:snd>
  </e:logimpl></e:caption>

  <e:contents>
    <e:derivation>
      <e:step name="given">
	<e:derive><e:and>
            <e:fst><e:pred name="Compose"><e:var n="v"/>, <e:st n="T"/>, <e:st n="S"/></e:pred></e:fst>
            <e:snd><e:noteq>
		<e:fst><e:var n="v"/></e:fst>
		<e:snd><code>value</code></e:snd>
            </e:noteq></e:snd>
	</e:and></e:derive>
	<e:by>given</e:by>
      </e:step>

      <e:step name="Compose">
	<e:derive><e:pred name="Compose"><e:var n="v"/>, <e:st n="T"/>, <e:st n="S"/></e:pred></e:derive>
	<e:by><e:from name="given"/>, ∧E</e:by>
      </e:step>

      <e:step name="noteq">
	<e:derive><e:noteq>
	    <e:fst><e:var n="v"/></e:fst>
	    <e:snd><code>value</code></e:snd>
	</e:noteq></e:derive>
	<e:by><e:from name="given"/>, ∧E</e:by>
      </e:step>

      <e:step name="openCompose">
	<e:derive>
	  <e:eq>
	    <e:fst>
	      <e:union>
		<e:fst><e:set><code>value</code></e:set></e:fst>
		<e:snd><e:st n="T"/></e:snd>
	      </e:union>
	    </e:fst>
	    <e:snd><e:st n="S"/></e:snd>
	  </e:eq> ∧
	  <e:forall>
	    <e:fst>
	      <e:in>
		<e:fst><e:var n="t"/></e:fst>
		<e:snd><e:st n="T"/></e:snd>
	      </e:in>
	    </e:fst>
	    <e:snd>
	      <e:lt>
		<e:fst><code>value</code></e:fst>
		<e:snd><e:var n="t"/></e:snd>
	      </e:lt>
	    </e:snd>
	  </e:forall>
	</e:derive>
	<e:by><e:from name="Compose"/>, open predicate</e:by>
      </e:step>

      <e:step name="valueUTIsS">
	<e:derive>
	  <e:eq>
	    <e:fst>
	      <e:union>
		<e:fst><e:set><code>value</code></e:set></e:fst>
		<e:snd><e:st n="T"/></e:snd>
	      </e:union>
	    </e:fst>
	    <e:snd><e:st n="S"/></e:snd>
	  </e:eq>
	</e:derive>
	<e:by><e:from name="openCompose"/>, ∧E</e:by>
      </e:step>

      <e:step name="allInTBiggerThanValue">
	<e:derive>
	  <e:forall>
	    <e:fst>
	      <e:in>
		<e:fst><e:var n="t"/></e:fst>
		<e:snd><e:st n="T"/></e:snd>
	      </e:in>
	    </e:fst>
	    <e:snd>
	      <e:lt>
		<e:fst><code>value</code></e:fst>
		<e:snd><e:var n="t"/></e:snd>
	      </e:lt>
	    </e:snd>
	  </e:forall>
	</e:derive>
	<e:by><e:from name="openCompose"/>, ∧E</e:by>
      </e:step>

      <e:step name="TsubsetS">
	<e:derive><e:subset>
	    <e:fst><e:st n="T"/></e:fst>
	    <e:snd><e:st n="S"/></e:snd>
	</e:subset></e:derive>
	<e:by><e:from name="valueUTIsS"/></e:by>
      </e:step>

      <e:step name="assumeValueInT" indent="indent1">
	<e:derive><e:in>
	    <e:fst><code>value</code></e:fst>
	    <e:snd><e:st n="T"/></e:snd>
	</e:in></e:derive>
	<e:by>assume</e:by>
      </e:step>

      <e:step name="thenValueInS" indent="indent1">
	<e:derive><e:in>
	    <e:fst><code>value</code></e:fst>
	    <e:snd><e:st n="S"/></e:snd>
	</e:in></e:derive>
	<e:by><e:from name="TsubsetS"/>, <e:from name="assumeValueInT"/>, member of subset is member of set</e:by>
      </e:step>

      <e:step name="impliesForwards">
	<e:derive>
	  <e:impl>
            <e:fst><e:in>
		<e:fst><code>value</code></e:fst>
		<e:snd><e:st n="T"/></e:snd>
            </e:in></e:fst>
            <e:snd><e:in>
		<e:fst><code>value</code></e:fst>
		<e:snd><e:st n="S"/></e:snd>
            </e:in></e:snd>
	  </e:impl>
	</e:derive>
	<e:by><e:from name="assumeValueInT"/>, <e:from name="themValueInS"/>, →I</e:by>
      </e:step>

      <e:step name="valueNotInv">
	<e:derive><e:notin>
	    <e:fst><code>value</code></e:fst>
	    <e:snd><e:set><e:var n="v"/></e:set></e:snd>
	</e:notin></e:derive>
	<e:by><e:from name="noteq"/></e:by>
      </e:step>

      <e:step name="assumeValueInS" indent="indent1">
	<e:derive><e:in>
	    <e:fst><code>value</code></e:fst>
	    <e:snd><e:st n="S"/></e:snd>
	</e:in></e:derive>
	<e:by>assume</e:by>
      </e:step>

      <e:step name="inSetOfValueOrT" indent="indent1">
	<e:derive><e:or>
	    <e:fst><e:in>
		<e:fst><code>value</code></e:fst>
		<e:snd><e:set><e:var n="v"/></e:set></e:snd>
	    </e:in></e:fst>
	    <e:snd><e:in>
		<e:fst><code>value</code></e:fst>
		<e:snd><e:st n="T"/></e:snd>
	    </e:in></e:snd>
	</e:or></e:derive>
	<e:by><e:from name="assumeValueInS"/>, <e:from name="valueUTIsS"/>, ??</e:by>
      </e:step>

      <e:step name="valueInT" indent="indent1">
	<e:derive><e:in>
	    <e:fst><code>value</code></e:fst>
	    <e:snd><e:st n="T"/></e:snd>
	</e:in></e:derive>
	<e:by><e:from name="inSetOfValueOrT"/>, <e:from name="valueNotInv"/>, <m:orelim/></e:by>
      </e:step>

      <e:step name="impliesBackwards">
	<e:derive>
	  <e:impl>
            <e:fst><e:in>
		<e:fst><code>value</code></e:fst>
		<e:snd><e:st n="S"/></e:snd>
            </e:in></e:fst>
            <e:snd><e:in>
		<e:fst><code>value</code></e:fst>
		<e:snd><e:st n="T"/></e:snd>
            </e:in></e:snd>
	  </e:impl>
	</e:derive>
	<e:by><e:from name="assumeValueInS"/>, <e:from name="valueInT"/>, <m:impliesIntro/></e:by>
      </e:step>

      <e:step name="qed">
	<e:derive>
	  <e:doubleimpl>
            <e:fst><e:in>
		<e:fst><code>value</code></e:fst>
		<e:snd><e:st n="T"/></e:snd>
            </e:in></e:fst>
            <e:snd><e:in>
		<e:fst><code>value</code></e:fst>
		<e:snd><e:st n="S"/></e:snd>
            </e:in></e:snd>
	  </e:doubleimpl>
	</e:derive>
	<e:by><e:from name="impliesForwards"/>, <e:from name="impliesBackwards"/>, ↔I</e:by>
      </e:step>
    </e:derivation>
  </e:contents>
</e:lemma>
