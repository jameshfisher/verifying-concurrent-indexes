<section xmlns="http://www.w3.org/1999/xhtml"
	 xmlns:xi="http://www.w3.org/2001/XInclude"
	 xmlns:e="http://eegg.github.com/htmlx"
	 xmlns:m="http://eegg.github.com/macro">

  <h2>A recursive <m:ll/> <code>search</code> algorithm</h2>

  <p>
    The purpose of a <code>search</code> algorithm is to
    determine whether a given element from the domain
    is a member of the set represented by a particular <m:ll/>.
    Our first task is to formally encode this purpose in a <e:jargon>specification</e:jargon>.
    Our basic tool here is the concept of pre- and post-conditions:
    given that <em>A</em> (some description of the program state) is true before the <code>search</code>,
    <em>B</em> will be true afterwards.
    Our task then is to establish first what is necessary before execution of <code>search</code>
    in order for that execution to be meaningful,
    and secondly what (given that this pre-condition is satisfied)
    the <code>search</code> function guarantees will be true afterwards.
  </p>

  <p>
    The <code>search</code> function takes two parameters:
    <code>head</code>, a pointer into a <m:ll/>,
    and <code>value</code>, the element we are searching for.
    The value of the <code>value</code> parameter is arbitrary,
    and so we need not concern ourselves with it in the precondition: all values are valid.
    The <code>head</code> variable, on the other hand, is not arbitrary:
    it must point to a valid <m:ll/>.
    We can express that: <e:pred name="List"><code>head</code>, <e:st n="S"/></e:pred>.
  </p>

  <p>
    The execution of <code>search</code> will return a boolean value,
    so the function will be called like so:
    <code>o = search(head, value)</code>.
    The value <code>o</code> will express whether
    <e:in>
      <e:fst><e:var n="value"/></e:fst>
      <e:snd><e:st n="S"/></e:snd>
    </e:in>;
    <m:ie/>,
    <e:doubleimpl>
      <e:fst><code>o</code></e:fst>
      <e:snd><e:in>
	  <e:fst><e:var n="value"/></e:fst>
	  <e:snd><e:st n="S"/></e:snd>
      </e:in></e:snd>
    </e:doubleimpl>.
    There is an additional post-condition: <code>search</code> leaves the <m:ll/> intact,
    and so <e:pred name="List"><code>head</code>, <e:st n="S"/></e:pred> continues to be true after execution.
    (Notice this specification in fact allows the algorithm to alter memory
    as long as it leaves it in a state that represents the abstract set <e:st n="S"/>.
    For our purposes this makes the specification simpler.)
  </p>

  <p>
    Our specification for <code>search</code> is:

    <div class="display">
      <e:triple>
	<e:pre><e:pred name="List"><code>tail</code>, <e:st n="S"/></e:pred></e:pre>
	<e:command><code>o = search(tail, value)</code></e:command>
	<e:post>
	  <e:and>
	    <e:fst><e:pred name="List"><code>tail</code>, <e:st n="S"/></e:pred></e:fst>
	    <e:snd><e:doubleimpl>
		<e:fst>o</e:fst>
		<e:snd><e:in><e:fst><code>value</code></e:fst><e:snd><e:st n="S"/></e:snd></e:in></e:snd>
	    </e:doubleimpl></e:snd>
	  </e:and>
	</e:post>
      </e:triple>
    </div>
  </p>

  <p>
    The recursive method to search a list closely follows the recursive data structure that we have defined.
    Given a <e:pred name="List"><code>head</code>, <e:st n="S"/></e:pred>, either it is empty or it is not.
    If it is empty (as indicated by <e:eq><e:fst><code>head</code></e:fst><e:snd><code>null</code></e:snd></e:eq>),
    then it does not contain <code>value</code>, so we can return <code>false</code>.
    Otherwise, we look at the first value in the list, <e:var n="v"/>, and compare it to <code>value</code>.
    Three relations are possible:
    <e:lt><e:fst><code>value</code></e:fst><e:snd><e:var n="v"/></e:snd></e:lt>, or
    <e:eq><e:fst><code>value</code></e:fst><e:snd><e:var n="v"/></e:snd></e:eq>, or
    <e:lt><e:fst><e:var n="v"/></e:fst><e:snd><code>value</code></e:snd></e:lt>.
    Most trivially, if <e:eq><e:fst><code>value</code></e:fst><e:snd><e:var n="v"/></e:snd></e:eq>
    then <code>value</code> is in <e:st n="S"/>, so we can return <code>true</code>.
    Next, if <e:lt><e:fst><code>value</code></e:fst><e:snd><e:var n="v"/></e:snd></e:lt>,
    then <code>value</code> is not in <e:st n="S"/>, because the list is in ascending order.
    Finally, if <e:lt><e:fst><e:var n="v"/></e:fst><e:snd><code>value</code></e:snd></e:lt>,
    then <code>value</code> could be in <e:st n="S"/> if and only if it is in <e:st n="T"/>,
    so we call <code>search(tail, value)</code>, and return that value.
    Diagrammatically, our recursive search algorithm works as follows:

    <div class="display">
      <xi:include href="./search.svg" />
    </div>
  </p>

  <p>
    A full annotation of our recursive search algorithm follows.

    <xi:include href="../../../../code/d/html/ll/search/recursive.d.html"/>
  </p>
</section>
