<section xmlns="http://www.w3.org/1999/xhtml"
	 xmlns:xi="http://www.w3.org/2001/XInclude"
	 xmlns:e="http://eegg.github.com/htmlx"
	 xmlns:m="http://eegg.github.com/macro">
  
  <h3>The <m:bst/> data structure</h3>

  <p>
    Here is the module defining the structure of a node in the tree:

    <div class="display">
      <xi:include href="../../code/d/html/bst/node.d.html" />
    </div>
  </p>

  <p>
    Notice the use of a <q>link array</q>:
    rather than separate named <code>left</code> and <code>right</code> pointers,
    these two pointers are held in a two-element array,
    addressed respectively as <code>c[0]</code> and <code>c[1]</code>.
    This enables us to parameterize procedures by the index
    where the symmetry of the tree would otherwise demand two symmetrical blocks of code.
  </p>

  <p>
    We now wish to describe how such a data structure enables us to represent a set.
    Let's start with the easy case: the empty set.
    This is represented simply by a null pointer.
    We can describe that tree like so:

    <table class="displaymath">
      <tbody>
	<tr>
	  <td><e:pred name="EmptyTree"><e:var n="n"/>, <e:var n="S"/></e:pred> ≝</td>
	  <td><e:eq><e:fst><e:var n="n"/></e:fst><e:snd><code>null</code></e:snd></e:eq> ∧</td>
	  <td>An empty tree is indicated by a null pointer, </td>
	</tr>
	<tr>
	  <td></td>
	  <td><m:hemp/> ∧</td>
	  <td>uses no space on the heap, and</td>
	</tr>
	<tr>
	  <td></td>
	  <td><e:eq><e:fst><e:var n="S"/></e:fst><e:snd><m:scemp/></e:snd></e:eq>.</td>
	  <td>represents the empty set.</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    To describe a tree containing more than zero elements,
    we need to describe the ordering on those elements.
    I choose to do this in a separate predicate.
    For some node at location <code>n</code>, call the element stored there <e:var n="v"/>,
    the set stored in its left subtree <e:st n="L"/>,
    and the set stored in its right subtree <e:st n="R"/>.
    The set <e:st n="S"/> stored by the subtree rooted at <code>n</code> is the union of those elements.
    Because the tree is ordered, all elements in <e:var n="L"/> are less than <e:var n="v"/>
    and all elements in <e:st n="R"/> are greater than <e:var n="v"/>.
    We can express the relation between these elements by a predicate
    <e:pred name="Compose"><e:st n="L"/>, <e:var n="v"/>, <e:st n="R"/>, <e:st n="S"/></e:pred>:
    
    <table class="displaymath">
      <tbody>
	<tr>
	  <td><e:pred name="Compose"><e:st n="L"/>, <e:var n="v"/>, <e:st n="R"/>, <e:st n="S"/></e:pred> ≝</td>
	  <td>
	    <e:eq>
	      <e:fst>
	      <e:union>
		<e:fst><e:st n="L"/></e:fst>
		<e:snd>
		  <e:union>
		    <e:fst><e:set><e:var n="v"/></e:set></e:fst>
		    <e:snd><e:st n="R"/></e:snd>
		  </e:union>
		</e:snd>
	      </e:union>
	      </e:fst>
	      <e:snd><e:st n="S"/></e:snd>
	    </e:eq> ∧
	  </td>
	  <td><e:st n="L"/>, <e:var n="v"/>, and <e:st n="R"/> make up the set <e:st n="S"/>,</td>
	</tr>
	<tr>
	  <td></td>
	  <td>
	    <e:forall>
	      <e:fst>
		<e:in><e:fst><e:var n="l"/></e:fst><e:snd><e:st n="L"/></e:snd></e:in>
	      </e:fst>
	      <e:snd>
		<e:lt><e:fst><e:var n="l"/></e:fst><e:snd><e:var n="v"/></e:snd></e:lt>
	      </e:snd>
	    </e:forall> ∧
	  </td>
	  <td>all values in <e:st n="L"/> are less than <e:var n="v"/>, and</td>
	</tr>
	<tr>
	  <td></td>
	  <td>
	    <e:forall>
	      <e:fst>
		<e:in>
		  <e:fst><e:var n="r"/></e:fst>
		  <e:snd><e:st n="R"/></e:snd>
		</e:in>
	      </e:fst>
	      <e:snd>
		<e:lt>
		  <e:fst><e:var n="v"/></e:fst>
		  <e:snd><e:var n="r"/></e:snd>
		</e:lt>
	      </e:snd>
	    </e:forall>.
	  </td>
	  <td>conversely for <e:st n="R"/>.</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    From a <e:predicate>Compose</e:predicate> assertion and some value <e:var n="w"/>,
    we know which subset <e:var n="w"/> is in, if any.
    For instance, if <e:eq><e:fst><e:var n="w"/></e:fst><e:snd><e:var n="v"/></e:snd></e:eq>,
    then <e:in><e:fst><e:var n="w"/></e:fst><e:snd><e:st n="S"/></e:snd></e:in>:

    <e:derivation>

      <e:step name="givenCompose">
	<e:derive><e:pred name="Compose"><e:st n="L"/>, <e:var n="v"/>, <e:st n="R"/>, <e:st n="S"/></e:pred></e:derive>
	<e:by>given</e:by>
      </e:step>

      <e:step name="givenLessThan">
	<e:derive><e:eq><e:fst><e:var n="w"/></e:fst><e:snd><e:var n="v"/></e:snd></e:eq></e:derive>
	<e:by>given</e:by>
      </e:step>

      <e:step name="wInSetOfw">
	<e:derive>
	  <e:in>
	    <e:fst><e:var n="w"/></e:fst>
	    <e:snd><e:set><e:var n="w"/></e:set></e:snd>
	  </e:in>
	</e:derive>
	<e:by>some axiom presumably</e:by>
      </e:step>

      <e:step name="wInSetOfv">
	<e:derive>
	  <e:in>
	    <e:fst><e:var n="w"/></e:fst>
	    <e:snd><e:set><e:var n="v"/></e:set></e:snd>
	  </e:in>
	</e:derive>
	<e:by>
	  <e:from name="givenLessThan"/>, <e:from name="wInSetOfw"/>, equality
	</e:by>
      </e:step>

      <e:step name="openCompose">
	<e:derive>
	  <e:eq>
	    <e:fst>
	      <e:union>
		<e:fst><e:st n="L"/></e:fst>
		<e:snd>
		  <e:union>
		    <e:fst><e:set><e:var n="v"/></e:set></e:fst>
		    <e:snd><e:st n="R"/></e:snd>
		  </e:union>
		</e:snd>
	      </e:union>
	    </e:fst>
	    <e:snd><e:st n="S"/></e:snd>
	  </e:eq> ∧<br />

	  <e:forall>
	    <e:fst>
	      <e:in><e:fst><e:var n="l"/></e:fst><e:snd><e:st n="L"/></e:snd></e:in>
	    </e:fst>
	    <e:snd>
	      <e:lt><e:fst><e:var n="l"/></e:fst><e:snd><e:var n="v"/></e:snd></e:lt>
	    </e:snd>
	  </e:forall> ∧<br />

	  <e:forall>
	    <e:fst>
	      <e:in>
		<e:fst><e:var n="r"/></e:fst>
		<e:snd><e:st n="R"/></e:snd>
	      </e:in>
	    </e:fst>
	    <e:snd>
	      <e:lt>
		<e:fst><e:var n="v"/></e:fst>
		<e:snd><e:var n="r"/></e:snd>
	      </e:lt>
	    </e:snd>
	  </e:forall>
	</e:derive>
	<e:by>
	  <e:from name="givenCompose"/>, open predicate
	</e:by>
      </e:step>

      <e:step name="LuvuR">
	<e:derive>
	  <e:eq>
	    <e:fst>
	      <e:union>
		<e:fst><e:st n="L"/></e:fst>
		<e:snd>
		  <e:union>
		    <e:fst><e:set><e:var n="v"/></e:set></e:fst>
		    <e:snd><e:st n="R"/></e:snd>
		  </e:union>
		</e:snd>
	      </e:union>
	    </e:fst>
	    <e:snd><e:st n="S"/></e:snd>
	  </e:eq>
	</e:derive>

	<e:by>
	  <e:from name="openCompose"/>, ∧E
	</e:by>
      </e:step>

      <e:step name="SetOfVInS">
	<e:derive>
	  <e:subset>
	    <e:fst><e:set><e:var n="v"/></e:set></e:fst>
	    <e:snd><e:st n="S"/></e:snd>
	  </e:subset>
	</e:derive>
	<e:by><e:from name="LuvuR"/>, subset</e:by>
      </e:step>

      <e:step name="qed">
	<e:derive><e:in><e:fst><e:var n="w"/></e:fst><e:snd><e:st n="S"/></e:snd></e:in></e:derive>
	<e:by><e:from name="wInSetOfv"/>, <e:from name="SetOfVInS"/>, ?</e:by>
      </e:step>
    </e:derivation>

  </p>

  <p>
    If <e:lt><e:fst><e:var n="w"/></e:fst><e:snd><e:var n="v"/></e:snd></e:lt>,
    then if <e:var n="w"/> is in <e:st n="S"/> then it must be in <e:st n="L"/>,
    and <i>vice versa</i>:
    <e:note>The case for <e:lt><e:fst><e:var n="v"/></e:fst><e:snd><e:var n="w"/></e:snd></e:lt> is obviously symmetrical.</e:note>

    <e:derivation>
      <e:step name="given">
	<e:derive>
	  <e:and>
	    <e:fst>
	      <e:pred name="Compose"><e:st n="L"/>, <e:var n="v"/>, <e:st n="R"/>, <e:st n="S"/></e:pred>
	    </e:fst>
	    <e:snd>
	      <e:lt><e:fst><e:var n="w"/></e:fst><e:snd><e:var n="v"/></e:snd></e:lt>
	    </e:snd>
	  </e:and>
	</e:derive>
	<e:by>given</e:by>
      </e:step>

      <e:step name="compose">
	<e:derive><e:pred name="Compose"><e:st n="L"/>, <e:var n="v"/>, <e:st n="R"/>, <e:st n="S"/></e:pred></e:derive>
	<e:by><e:from name="given"/>, ∧E</e:by>
      </e:step>

      <e:step name="lt">
	<e:derive><e:lt><e:fst><e:var n="w"/></e:fst><e:snd><e:var n="v"/></e:snd></e:lt></e:derive>
	<e:by><e:from name="given"/>, ∧E</e:by>
      </e:step>

      <e:step name="open">
	<e:derive>
	  <e:eq>
	    <e:fst>
	      <e:union>
		<e:fst><e:st n="L"/></e:fst>
		<e:snd>
		  <e:union>
		    <e:fst><e:set><e:var n="v"/></e:set></e:fst>
		    <e:snd><e:st n="R"/></e:snd>
		  </e:union>
		</e:snd>
	      </e:union>
	    </e:fst>
	    <e:snd><e:st n="S"/></e:snd>
	  </e:eq> ∧<br />

	  <e:forall>
	    <e:fst>
	      <e:in><e:fst><e:var n="l"/></e:fst><e:snd><e:st n="L"/></e:snd></e:in>
	    </e:fst>
	    <e:snd>
	      <e:lt><e:fst><e:var n="l"/></e:fst><e:snd><e:var n="v"/></e:snd></e:lt>
	    </e:snd>
	  </e:forall> ∧<br />

	  <e:forall>
	    <e:fst>
	      <e:in>
		<e:fst><e:var n="r"/></e:fst>
		<e:snd><e:st n="R"/></e:snd>
	      </e:in>
	    </e:fst>
	    <e:snd>
	      <e:lt>
		<e:fst><e:var n="v"/></e:fst>
		<e:snd><e:var n="r"/></e:snd>
	      </e:lt>
	    </e:snd>
	  </e:forall>
	</e:derive>
	<e:by><e:from name="compose"/>, open predicate</e:by>
      </e:step>

      <e:step name="LuvuR">
	<e:derive>
	  <e:eq>
	    <e:fst>
	      <e:union>
		<e:fst><e:st n="L"/></e:fst>
		<e:snd>
		  <e:union>
		    <e:fst><e:set><e:var n="v"/></e:set></e:fst>
		    <e:snd><e:st n="R"/></e:snd>
		  </e:union>
		</e:snd>
	      </e:union>
	    </e:fst>
	    <e:snd><e:st n="S"/></e:snd>
	  </e:eq>
	</e:derive>
	<e:by><e:from name="open"/>, ∧E</e:by>
      </e:step>

      <e:step name="LsubsetS">
	<e:derive>
	  <e:subset>
	    <e:fst><e:st n="L"/></e:fst>
	    <e:snd><e:st n="S"/></e:snd>
	  </e:subset>
	</e:derive>
	<e:by><e:from name="LuvuR"/>, subset</e:by>
      </e:step>

      <e:step name="assumewInL" indent="indent1">
	<e:derive>
	  <e:in>
	    <e:fst><e:var n="w"/></e:fst>
	    <e:snd><e:st n="L"/></e:snd>
	  </e:in>
	</e:derive>
	<e:by>assume</e:by>
      </e:step>

      <e:step name="thenwInS" indent="indent1">
	<e:derive>
	  <e:in>
	    <e:fst><e:var n="w"/></e:fst>
	    <e:snd><e:st n="S"/></e:snd>
	  </e:in>
	</e:derive>
	<e:by><e:from name="LsubsetS"/>, <e:from name="assumewInL"/>, member of subset in set</e:by>
      </e:step>

      <e:step name="wInLImplieswInS">
	<e:derive>
	  <e:impl>
	    <e:fst><e:in><e:fst><e:var n="w"/></e:fst><e:snd><e:st n="L"/></e:snd></e:in></e:fst>
	    <e:snd><e:in><e:fst><e:var n="w"/></e:fst><e:snd><e:st n="S"/></e:snd></e:in></e:snd>
	  </e:impl>
	</e:derive>
	<e:by><e:from name="assumewInL"/>, <e:from name="thenwInS"/>, →I</e:by>
      </e:step>

      <e:step name="noteq">
	<e:derive>
	  <e:noteq>
	    <e:fst><e:var n="w"/></e:fst>
	    <e:snd><e:var n="v"/></e:snd>
	  </e:noteq>
	</e:derive>
	<e:by><e:from name="lt" />, weakening</e:by>
      </e:step>

      <e:step name="wNotInSetOfV">
	<e:derive>
	  <e:notin>
	    <e:fst><e:var n="w"/></e:fst>
	    <e:snd><e:set><e:var n="v"/></e:set></e:snd>
	  </e:notin>
	</e:derive>
	<e:by><e:from name="noteq"/>, ?</e:by>
      </e:step>

      <e:step name="allInRGreaterThanv">
	<e:derive>
	  <e:forall>
	    <e:fst>
	      <e:in>
		<e:fst><e:var n="r"/></e:fst>
		<e:snd><e:st n="R"/></e:snd>
	      </e:in>
	    </e:fst>
	    <e:snd>
	      <e:lt>
		<e:fst><e:var n="v"/></e:fst>
		<e:snd><e:var n="r"/></e:snd>
	      </e:lt>
	    </e:snd>
	  </e:forall>
	</e:derive>
	<e:by><e:from name="open"/>, ∧E</e:by>
      </e:step>

      <e:step name="wNotInR">
	<e:derive>
	  <e:notin>
	    <e:fst><e:var n="w"/></e:fst>
	    <e:snd><e:st n="R"/></e:snd>
	  </e:notin>
	</e:derive>
	<e:by><e:from name="lt"/>, <e:from name="allInRGreaterThanv"/>, <e:var n="w"/> cannot satisfy membership criterion</e:by>
      </e:step>

      <e:step name="wNotInvOrR">
	<e:derive>
	  <e:notin>
	    <e:fst><e:var n="w"/></e:fst>
	    <e:snd>(<e:union><e:fst><e:set><e:var n="v"/></e:set></e:fst><e:snd><e:st n="R"/></e:snd></e:union>)</e:snd>
	  </e:notin>
	</e:derive>
	<e:by><e:from name="wNotInSetOfv"/>, <e:from name="wNotInR" />, not in union</e:by>
      </e:step>

      <e:step name="assumewInS" indent="indent1">
	<e:derive>
	  <e:in>
	    <e:fst><e:var n="w"/></e:fst>
	    <e:snd><e:st n="S"/></e:snd>
	  </e:in>
	</e:derive>
	<e:by>assume</e:by>
      </e:step>

      <e:step name="thenwInL" indent="indent1">
	<e:derive>
	  <e:in>
	    <e:fst><e:var n="w"/></e:fst>
	    <e:snd><e:st n="L"/></e:snd>
	  </e:in>
	</e:derive>
	<e:by><e:from name="LuvuR"/>, <e:from name="wNotInvOrR" />, <e:from name="assumewInS"/>, ??</e:by>
      </e:step>

      <e:step name="wInSImplieswInL">
	<e:derive>
	  <e:impl>
	    <e:fst>
	      <e:in>
		<e:fst><e:var n="w"/></e:fst>
		<e:snd><e:st n="S"/></e:snd>
	      </e:in>
	    </e:fst>
	    <e:snd>
	      <e:in>
		<e:fst><e:var n="w"/></e:fst>
		<e:snd><e:st n="L"/></e:snd>
	      </e:in>
	    </e:snd>
	  </e:impl>
	</e:derive>
	<e:by><e:from name="assumewInS"/>, <e:from name="thenwInL"/>, →I</e:by>
      </e:step>

      <e:step name="qed">
	<e:derive>
	  <e:doubleimpl>
	    <e:fst>
	      <e:in>
		<e:fst><e:var n="w"/></e:fst>
		<e:snd><e:st n="L"/></e:snd>
	      </e:in>
	    </e:fst>
	    <e:snd>
	      <e:in>
		<e:fst><e:var n="w"/></e:fst>
		<e:snd><e:st n="S"/></e:snd>
	      </e:in>
	    </e:snd>
	  </e:doubleimpl>
	</e:derive>
	<e:by><e:from name="wInLImplieswInS" />, <e:from name="wInSImplieswInL" />, ↔I</e:by>
      </e:step>
    </e:derivation>
  </p>

  <p>
    If <e:var n="R"/> is the empty set, then <e:var n="v"/> is the maximum in the set:

    <e:derivation>
      <e:step name="given">
	<e:derive>
	  <e:pred name="Compose"><e:st n="L"/>, <e:var n="v"/>, <m:empty/>, <e:st n="S"/></e:pred>
	</e:derive>
	<e:by>given</e:by>
      </e:step>

      <e:step name="qed">
	<e:derive>
	  <e:and>
	    <e:fst>
	      <e:in><e:fst><e:var n="v"/></e:fst><e:snd><e:st n="S"/></e:snd></e:in>
	    </e:fst>
	    <e:snd>∀x∈L. x &lt; v ∧ L = S - {v}</e:snd>
	  </e:and>
	</e:derive>
	<e:by></e:by>
      </e:step>
    </e:derivation>

  </p>

  <p>
    Using our <e:predicate>Compose</e:predicate> predicate,
    we can describe the top of some tree at <code>n</code>
    that stores the value <e:var n="v"/> at the root and represents the set <e:var n="S"/>.
    (Notice this uses the <e:predicate>Tree</e:predicate> predicate,
    to be introduced shortly,
    and which describes a tree with any number of nodes):

    <table class="displaymath">
      <tbody>
	<tr>
	  <td><e:pred name="TopOfTree"><code>n</code>, <e:var n="v"/>, <e:st n="S"/></e:pred> ≝</td>
	  <td>∃<e:var n="l"/>,<e:var n="r"/>,<e:st n="L"/>,<e:st n="R"/>.</td>
	  <td><code>n</code> represents the set <e:st n="S"/> with <e:var n="v"/> at the root if</td>
	</tr>
	<tr>
	  <td></td>
	  <td>
	    <e:fcell>
	      <e:fst><code>n</code></e:fst>
	      <e:snd><e:var n="v"/>,<e:var n="l"/>,<e:var n="r"/></e:snd>
	    </e:fcell>
	  </td>
	  <td><code>n</code> points to a node with value <e:var n="v"/> and pointers <e:var n="l"/> and <e:var n="r"/></td>
	</tr>
	<tr>
	  <td></td>
	  <td>∗ <e:pred name="Tree"><e:var n="l"/>, <e:st n="L"/></e:pred></td>
	  <td>where <e:var n="l"/> points to a tree representing the set <e:st n="L"/>, and</td>
	</tr>
	<tr>
	  <td></td>
	  <td>∗ <e:pred name="Tree"><e:var n="r"/>, <e:st n="R"/></e:pred></td>
	  <td><e:var n="r"/> points to a tree representing <e:st n="R"/>, and</td>
	</tr>
	<tr>
	  <td></td>
	  <td>∧ <e:pred name="Compose"><e:st n="L"/>, <e:var n="v"/>, <e:st n="R"/>, <e:st n="S"/></e:pred>.</td>
	  <td>the values in the <e:st n="S"/> are totally ordered.</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    Often, though, we don't know the value at the top of the tree—we just know it's non-empty:

    <table class="displaymath">
      <tbody>
	<tr>
	  <td><e:pred name="NonEmptyTree"><code>n</code>, <e:st n="S"/></e:pred> ≝</td>
	  <td>∃<e:var n="v"/>. <e:pred name="TopOfTree"><code>n</code>, <e:var n="v"/>, <e:st n="S"/></e:pred>.</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    The <e:predicate>Tree</e:predicate> predicate describes
    a tree that has any number of nodes.
    That is, it's an <e:predicate>EmptyTree</e:predicate> or a <e:predicate>NonEmptyTree</e:predicate>:

    <table class="displaymath">
      <tbody>
	<tr>
	  <td>
	    <e:pred name="Tree"><code>n</code>, <e:st n="S"/></e:pred> ≝
	  </td>
	  <td>
	    <e:pred name="EmptyTree"><code>n</code>, <e:st n="S"/></e:pred> ∨
	  </td>
	</tr>
	<tr>
	  <td></td>
	  <td><e:pred name="NonEmptyTree"><code>n</code>, <e:st n="S"/></e:pred>.</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    Given a <e:predicate>Tree</e:predicate> pointer,
    we can find out whether it is an <e:predicate>EmptyTree</e:predicate> or an <e:predicate>NonEmptyTree</e:predicate>
    by testing whether the pointer is <code>null</code>.
    That is,
    <e:impl>
      <e:fst>
	<e:and>
	  <e:fst><e:pred name="Tree"><code>n</code>, <e:st n="S"/></e:pred></e:fst>
	  <e:snd><e:eq><e:fst><code>n</code></e:fst><e:snd><code>null</code></e:snd></e:eq></e:snd>
	</e:and>
      </e:fst>
      <e:snd><e:pred name="EmptyTree"><code>n</code>, <e:st n="S"/></e:pred></e:snd>
    </e:impl>, and
    <e:impl>
      <e:fst>
	<e:and>
	  <e:fst><e:pred name="Tree"><code>n</code>, <e:st n="S"/></e:pred></e:fst>
	  <e:snd><e:noteq><e:fst><code>n</code></e:fst><e:snd><code>null</code></e:snd></e:noteq></e:snd>
	</e:and>
      </e:fst>
      <e:snd><e:pred name="NonEmptyTree"><code>n</code>, <e:st n="S"/></e:pred></e:snd>
    </e:impl>.
    This follows from <code>null</code> not being in the domain of the heap; <m:ie/>,
    <e:impl>
      <e:fst><e:fcell><e:fst><code>n</code></e:fst><e:snd>…</e:snd></e:fcell></e:fst>
      <e:snd><e:noteq><e:fst><code>n</code></e:fst><e:snd><code>null</code></e:snd></e:noteq></e:snd>
    </e:impl>.
  </p>
</section>
