<section xmlns="http://www.w3.org/1999/xhtml"
	 xmlns:xi="http://www.w3.org/2001/XInclude"
	 xmlns:e="http://eegg.github.com/htmlx"
	 xmlns:m="http://eegg.github.com/macro">

  <h3>Some predicate definitions</h3>

  <p>
    Earlier, in our index API specification,
    we introduced the predicate <e:pred name="Index"><code>i</code>, <e:const n="I" /></e:pred>.
    This simply says that <q><code>i</code> represents the index <e:const n="I"/></q>.
    This was deliberately <em>abstract</em>,
    so that individual index implementations could define it themselves.
    Now we've looked at a few index data structures,
    how can we formally describe them?
  </p>

  <p>
    Our main tool here is <e:jargon>separation logic</e:jargon>,
    an extension of <e:jargon>Hoare logic</e:jargon> with practical operators to describe the state of the heap.
    Here, I only specify the set versions of the data structures.
  </p>

  <section>
    <h4>Linked list</h4>

    <p>
      I have chosen to start with the linked list,
      as it is the simplest non-trivial data structure
      and is easy to specify.
      The linked list is a recursive data structure—the structure contains itself.
      We might  define it in C as:
    </p>

    <pre>
struct List {
  int value;
  struct list * tail;
};
    </pre>

    <p>
      An instance of <code>List</code> is interpreted as representing a non-empty set.
      The <code>value</code> field is one of the members of that set,
      and all other members are held in the list pointed at by the <code>tail</code> field.
      An empty set is represented by the <code>null</code> pointer.
      We use a pointer to represent an arbitrary set, empty or not.
      Therefore, for any pointer <code>s</code>,
      we should be able to define a predicate <e:pred name="Set"><code>s</code>, <e:const n="S" /></e:pred>.
    </p>

    <p>
      Translating these statements to separation logic is fairly straightforward.
      Either <code>s</code> is <code>null</code>, or it is not.
      If it is <code>null</code>, then
      <e:const n="S"/> = <m:scemp /> (the empty set),
      and the heap pertinent to the linked list is empty (represented by <m:hemp/>).
      If <code>s</code> is not <code>null</code>,
      then it points to a valid <code>list</code> node:
      <e:fcell><e:fst><code>s</code></e:fst><e:snd><code>tail</code>, <e:var n="value" /></e:snd></e:fcell>.
      As <code>tail</code> is a list pointer,
      we can recursively apply the predicate to it:
      <e:pred name="Set"><code>tail</code>, <e:const n="R"/></e:pred>.
      The node description and the <code>tail</code> description
      are joined with the separating conjunction,
      because the tail does not contain the node pointed at by <code>s</code>
      (if it did, we would be in trouble!).
      Finally, <code>value</code> and the set <e:const n="R" />
      together make up the set <e:const n="S" />:
      <e:eq><e:fst><e:union><e:fst>R</e:fst><e:snd><e:set><e:var n="value" /></e:set></e:snd></e:union></e:fst><e:snd>S</e:snd></e:eq>.
      Here's the formal definition:

      <table class="displaymath">
	<tr>
	  <td><e:pred name="Set"><code>s</code>, S</e:pred> ≝</td>
	  <td>(<e:eq><e:fst><code>s</code></e:fst><e:snd><code>null</code></e:snd></e:eq> ∧ <e:eq><e:fst>S</e:fst><e:snd><m:scemp /></e:snd></e:eq> ∧ <m:hemp/>) ∨</td>
	</tr>
	<tr>
	  <td></td>
	  <td>
	    (∃<e:var n="tail"/>, <e:var n="value"/>.
	    <e:fcell><e:fst><code>s</code></e:fst><e:snd><e:var n="tail"/>, <e:var n="value"/></e:snd></e:fcell>
	    ∗ <e:pred name="Set"><code>tail</code>, <e:setminus><e:fst>S</e:fst><e:snd><e:set><e:var n="value"/></e:set></e:snd></e:setminus></e:pred>
	  </td>
	</tr>
      </table>
    </p>
  </section>


  <section>
    <h4>Binary Search Tree</h4>

    <p>
      Here's an unordered binary tree representing a set:
    </p>

    <p>
      Here's the ordered <m:bst />:
    </p>

    <table class="displaymath">
      <tbody>
	<tr>
	  <td><e:pred name="Set"><code>s</code>, S</e:pred> ≝</td>
	  <td>(<code>s</code> = <code>null</code> ∧ S = <m:scemp/> ∧ <m:hemp/>) ∨</td>
	</tr>
	<tr>
	  <td></td>
	  <td>
	    ∃<e:var n="l"/>, <e:var n="r"/>, <e:var n="v"/>.<br />
	    <e:fcell><e:fst>s</e:fst><e:snd><e:var n="l"/>, <e:var n="r"/>, <e:var n="v"/></e:snd></e:fcell><br />
	    ∧ <e:in><e:fst>v</e:fst><e:snd>S</e:snd></e:in><br />
	    ∗ <e:pred name="Set"><e:var n="l"/>, <e:setb><e:fst>v′</e:fst><e:snd><e:in><e:fst>v′</e:fst><e:snd>S</e:snd></e:in> ∧ v′ &lt; v</e:snd></e:setb></e:pred><br />
	    ∗ <e:pred name="Set">r, <e:setb><e:fst>v′</e:fst><e:snd><e:in><e:fst>v′</e:fst><e:snd>S</e:snd></e:in> ∧ v′ &gt; v</e:snd></e:setb></e:pred>
	  </td>
	</tr>
      </tbody>
    </table>
  </section>

  <section>
    <h4>Red-Black tree</h4>

    <p>
      The defining feature of the <m:rbt/> is
      the restriction that it places on the colors and black-heights of nodes.
      Before we even look at the tree structure,
      we can actually encode these restrictions on four variables:
      the color and black-height of a node,
      and the color and black-height of its parent.
      Let&#x2019;s start by defining a predicate on these
      (as well as making the description more intelligible,
      this also makes the full description shorter,
      and makes proofs shorter where they are unconcerned with the <m:rbt/> conditions).
    </p>

    <p>
      This says that:

      <ul>
	<li>the color is either <e:const n="red"/> or <e:const n="black"/></li>
	<li>if the node is <e:const n="red"/>, its parent has the same black-height</li>
	<li>if the node is <e:const n="black"/>, its parent has a greater black-height by 1</li>
	<li>if the node is <e:const n="red"/>, its parent is <e:const n="black"/></li>
	<li>a negative black-height is disallowed</li>
      </ul>
    </p>

    <p>
      We now want to define the <m:rbt /> recursively.
      We can then describe a node pointer.
    </p>
  </section>
</section>
