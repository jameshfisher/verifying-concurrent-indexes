<section xmlns="http://www.w3.org/1999/xhtml"
	 xmlns:xi="http://www.w3.org/2001/XInclude">
  <h3>Formalizing behavior: a Set \ADT</h3>

  <p>
    A correct index implementation will satisfy the behavior described above.
    To \emph{prove} that one does so, however,
    we shall have to describe the behavior more precisely.
  </p>

  <p>
    The basic tool we use to do this is the concept of of \emph{pre- and post-conditions}.\footnotemark
    In the context of writing a specification,
    these let us specify the possible valid states of the program before executing a command,
    and what the state of the program will be after execution of it.
    For example, we might state that if $x=2$ prior to executing \IC{x=square(x)},
    then $x=4$ afterwards.
    This would be written as the \enquote{Hoare triple}
    \Triple{x=2}{x=square(x)}{x=4}.\footnotemark
    More complex \enquote{commands},
    such as the operations on an index,
    can be specified in the same way:
    \Triple{\ldots}{i->insert(k, v)}{\ldots}.
    For an operation like this,
    the precondition must capture
    the valid states of the variables \IC{i}, \IC{k} and \IC{v}.
  </p>

\footnotetext{
This is a central concept of Hoare logic.\cite{hoare}
There is a lot more to basic Hoare logic,
  but here I am only specifying behaviour,
  not proving that anything satisfies it.
}

\footnotetext{
Actually, the triple makes no assertions as to whether the command terminates,
  so the assertion made is strictly that
  the postcondition will hold \emph{if and when} the command terminates.
A second syntax is used for assertions that the command terminates:
  \TermTriple{x=2}{x=square(x)}{x=4}.
I do not concern myself with this here or in the specification.
}

  <p>
    However, \IC{i}, a pointer to a valid index in memory,
    can be a problematic thing to capture.
    First, we don't actually \emph{know} what a valid index looks like,
    because, as in the above descriptions,
    we do not want to concern ourselves with these low-level details
    when describing behavior.
    Second, even if we did want to describe memory layout,
    the details of this would be too complex to be practicable in a specification.
  </p>

  <p>
    The solution is simply to skip over this problem at this stage,
    and instead use an \NewTerm{abstract predicate}
    to describe what \IC{i} represents to the programmer using it,
    namely, \enquote{a pointer to something representing an index containingâ€¦}.
    This predicate over \IC{i} is written as $\Pred{index}{\IC{i}, I}$.
  </p>

  <p>
    A bit more notation is necessary to describe the mappings in an index.
    However, at this point and with familiar set notation,
    we can already fully specify a similar abstract data type: the \emph{set}.
    This will be useful, because a data structure representing an index
    can be constructed by minimal modification of a set data structure.
  </p>

  <p>
    The following functions for a Set \ADT, and their specifications, should be intuitive.
    We can \IC{search} for, \IC{insert}, and \IC{remove} elements from the set,
    just as we can do with mappings in an index.
    The pre- and postconditions simply describe
    how and whether the functions mutate the set,
    and how information is extracted from the structure.
  </p>

  <table>
    <tbody>
      <tr>
	<!-- search where key is in the set -->
	<td>\Cond{\Pred{set}{\IC{s}, S} \Fand \IC{el} \in S}</td>
	<td>\IC{exists = s->search(el);}</td>
	<td>\Cond{\Pred{set}{\IC{s}, S} \Fand \IC{el} \in S \Fand \IC{exists} = \truth}</td>
      </tr>
      <tr>
	<!-- search where key is not in the set -->
	<td>\Cond{\Pred{set}{\IC{s}, S} \Fand \IC{el} \notin S}</td>
	<td>\IC{exists = s->search(el);}</td>
	<td>\Cond{\Pred{set}{\IC{s}, S} \Fand \IC{el} \notin S \Fand \IC{exists} = \falsity}</td>
      </tr>
      <tr>
	<!-- insert -->
	<td>\Cond{\Pred{set}{\IC{s}, S}}</td>
	<td>\IC{s->insert(el);}</td>
	<td>\Cond{\Pred{set}{\IC{s}, S \union \Set{\IC{el}}}}</td>
      </tr>
      <tr>
	<!-- remove -->
	<td>\Cond{\Pred{set}{\IC{s}, S}}</td>
	<td>\IC{s->remove(el);}</td>
	<td>\Cond{\Pred{set}{\IC{s}, S \setminus \Set{\IC{el}}}}</td>
      </tr>
    </tbody>
  </table>

</section>
