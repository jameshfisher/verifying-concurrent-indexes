<section xmlns="http://www.w3.org/1999/xhtml"
	 xmlns:xi="http://www.w3.org/2001/XInclude"
	 xmlns:e="http://eegg.github.com/htmlx"
	 xmlns:m="http://eegg.github.com/macro">

  <h4>The index <m:api /></h4>

  <p>
    It isn't surprising, then, that
    almost every programming language has an index data type.<e:cite>wp_mapping</e:cite>
    (Indeed, in some languages, such as Javascript,
    all objects are indexes.<e:cite>ecmascript, p.\ 2.</e:cite>)
    With its appealingly intuitive interface,
    the programmer can memoize the results of a function,
    model the houses on her street,
    or describe a directed graph.
    She might, for another example, cache the Web,
    simply with:<e:note>I use a syntax similar to C++ in my examples.</e:note>
  </p>

  <e:displaycode><xi:include href="example.cc" parse="text" /></e:displaycode>

  <p>
    This small example illustrates the entire <abbr>API</abbr>.
    Let's look at it a bit more formally.
    The index is an <em>abstract</em> data type,<e:note>Also called a <em>container type</em>.</e:note>
    and cannot be used as-is;
    the <em>key</em> and the <em>value</em> must first be given a type.
    The resulting <em>concrete data type</em> can then be instantiated.
    (In the above,
    <code>Index</code> is the abstract data type,
    and <code>Webcache</code> is the concrete data type,
    with <code>Url</code>s as keys
    and <code>Page</code>s as values.)
    We say that an index <q>maps <code>K</code>s onto <code>V</code>s</q>
    if its key type is <code>K</code>
    and its value type is <code>V</code>.
    Given an index <code>i</code>
    that maps <code>K</code>s onto <code>V</code>s,
    we can specify the semantics of operations on it.
    In the following,
    the variable <code>key</code> is of type <code>K</code>,
    and the variable <code>value</code> is of type <code>V</code>:
  </p>

  <e:descriptionlist>
    <e:li>
      <e:item><code>value = i.search(key)</code></e:item>
      <e:description>
	If there is a value associated with <code>key</code> in <code>i</code>,
	<code>value</code> will be that value.
	Otherwise, <code>value</code> will be <code>null</code>.
	Note that with a <code>null</code> type, an index can be seen as a <em>total</em> function.
	The <code>search</code> function is also called <code>find</code>, <code>fetch</code>, <code>read</code>, and <code>get</code>.
      </e:description>
    </e:li>
    <e:li>
      <e:item>
	<code>i->insert(key, value);</code>
      </e:item>
      <e:description>
	Subsequent calls to <code>i->search(key)</code> will return <code>value</code>
	(until subsequent calls to <code>i->insert(k, —)</code> or <code>i->remove(k)</code>,
	where <code>k == key</code>).
	The <code>insert</code> function is also called <code>store</code>, <code>set</code>, <code>save</code>, and <code>add</code>.
      </e:description>
    </e:li>
    <e:li>
      <e:item>
	<code>i->remove(key);</code>
      </e:item>
      <e:description>
	Subsequent calls to <code>i.read(key)</code> will return <code>null</code>
	(until subsequent calls to <code>i->insert(k, —)</code> or <code>i->remove(k)</code>,
	where <code>k == key</code>).
	  The <code>remove</code> function is also called <code>delete</code>.
	  It may also be absent,
	  in favour of <code>insert(k, null)</code>
	  (suggesting the <q>total function</q> interpretation).
      </e:description>
    </e:li>
  </e:descriptionlist>

</section>
