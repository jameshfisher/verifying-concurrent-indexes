<section xmlns="http://www.w3.org/1999/xhtml"
	 xmlns:xi="http://www.w3.org/2001/XInclude"
	 xmlns:e="http://eegg.github.com/htmlx"
	 xmlns:m="http://eegg.github.com/macro">

  <h2>Verifying linked lists</h2>

  <p>
    I have chosen to start with the linked list,
    as it is the simplest non-trivial data structure
    and is easy to specify.
    The linked list is a recursive data structure—the structure contains itself.
    We might  define it in C as:
  </p>

  <pre>
    struct List {
    int value;
    struct list * tail;
    };
  </pre>

  <p>
    An instance of <code>List</code> is interpreted as representing a non-empty set.
    The <code>value</code> field is one of the members of that set,
    and all other members are held in the list pointed at by the <code>tail</code> field.
    An empty set is represented by the <code>null</code> pointer.
    We use a pointer to represent an arbitrary set, empty or not.
    Therefore, for any pointer <code>s</code>,
    we should be able to define a predicate <e:pred name="Set"><code>s</code>, <e:const n="S" /></e:pred>.
  </p>

  <p>
    Translating these statements to separation logic is fairly straightforward.
    Either <code>s</code> is <code>null</code>, or it is not.
    If it is <code>null</code>, then
    <e:const n="S"/> = <m:scemp /> (the empty set),
    and the heap pertinent to the linked list is empty (represented by <m:hemp/>).
    If <code>s</code> is not <code>null</code>,
    then it points to a valid <code>list</code> node:
    <e:fcell><e:fst><code>s</code></e:fst><e:snd><code>tail</code>, <e:var n="value" /></e:snd></e:fcell>.
    As <code>tail</code> is a list pointer,
    we can recursively apply the predicate to it:
    <e:pred name="Set"><code>tail</code>, <e:const n="R"/></e:pred>.
    The node description and the <code>tail</code> description
    are joined with the separating conjunction,
    because the tail does not contain the node pointed at by <code>s</code>
    (if it did, we would be in trouble!).
    Finally, <code>value</code> and the set <e:const n="R" />
    together make up the set <e:const n="S" />:
    <e:eq><e:fst><e:union><e:fst>R</e:fst><e:snd><e:set><e:var n="value" /></e:set></e:snd></e:union></e:fst><e:snd>S</e:snd></e:eq>.
    Here's the formal definition:

    <table class="displaymath">
      <tr>
	<td><e:pred name="Set"><code>s</code>, S</e:pred> ≝</td>
	<td>(<e:eq><e:fst><code>s</code></e:fst><e:snd><code>null</code></e:snd></e:eq> ∧ <e:eq><e:fst>S</e:fst><e:snd><m:scemp /></e:snd></e:eq> ∧ <m:hemp/>) ∨</td>
      </tr>
      <tr>
	<td></td>
	<td>
	  (∃<e:var n="tail"/>, <e:var n="value"/>.
	  <e:fcell><e:fst><code>s</code></e:fst><e:snd><e:var n="tail"/>, <e:var n="value"/></e:snd></e:fcell>
	  ∗ <e:pred name="Set"><code>tail</code>, <e:setminus><e:fst>S</e:fst><e:snd><e:set><e:var n="value"/></e:set></e:snd></e:setminus></e:pred>
	</td>
      </tr>
    </table>
  </p>
</section>
