<?xml version="1.0"?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:e="http://eegg.github.com/htmlx" xmlns:m="http://eegg.github.com/macro">


  <head>
    <meta charset="utf-8"/>

    <link rel="stylesheet" type="text/css" href="http://eegg.github.com/style/css/common.css"/>
    <link rel="stylesheet" type="text/css" href="css/style.css"/>

    <link rel="stylesheet" type="text/css" href="css/google-code-prettify/prettify.css"/>
    <link rel="stylesheet" type="text/css" href="css/main.css"/>

    <script type="text/javascript" src="css/google-code-prettify/prettify.js"> </script>
    <script type="text/javascript">window.addEventListener("load", function() { prettyPrint(); });</script>

    <title>Progress report: verifying concurrent indexes</title>
  </head>
  <body>
    <section class="content">
      <hgroup>
	<h1>Progress report: verifying concurrent indexes</h1>
	<h2>James Fisher</h2>
	<h2>2011, July 19</h2>
      </hgroup>
      <section xml:base="introduction/introduction.html">
  <h2>Introduction</h2>

  <section>
  <h3>What is an index?</h3>

  An index<span class="note">The same data type also goes by the names <em>map</em>, <em>dictionary</em>, <em>associative array</em>, <em>table</em>, and <em>hash</em>.</span> stores values,
  where each value has a distinct name.
  Many data sets fit this description.
  For example,
  your mobile's contact list stores <em>phone numbers</em>,
  and each number is accessed with a person's <em>name</em>.
  At a larger scale,
  the Web can be seen as a store of <em>pages</em>,
  where each page has a <abbr title="Uniform Resource Locator" class="smallcaps">URL</abbr>.
  Even a language can be seen as an index:
  a store of <em>concepts</em>,
  where each concept can be accessed by a <em>word</em>.
  More fundamentally,
  any function stores elements from a <em>range</em>,
  where each element is accessed by a unique number from a <em>domain</em>.

  <section xml:base="what_is_an_index/the_index_api.html">

  <h4>The index <abbr title="Application Programming Interface" class="smallcaps">API</abbr></h4>

  <p>
    It isn't surprising, then, that
    almost every programming language has an index data type.<span class="note">wp_mapping</span>
    (Indeed, in some languages, such as Javascript,
    all objects are indexes.<span class="note">ecmascript, p.\ 2.</span>)
    With its appealingly intuitive interface,
    the programmer can memoize the results of a function,
    model the houses on her street,
    or describe a directed graph.
    She might, for another example, cache the Web,
    simply with:<span class="note">I use a syntax similar to C++ in my examples.</span>
  </p>

  <pre class="prettyprint">typedef Index&lt;Url, Page&gt; Webcache;
Webcache cache;

Page get(Url u) {
  Page p = cache.search(u);

  if (p != null &amp;&amp; !p.expired()) return p;

  p = http_get(u);

  if (p == null) cache.remove(u);
  else           cache.insert(u, p);

  return p;
}
</pre>

  <p>
    This small example illustrates the entire <abbr>API</abbr>.
    Let's look at it a bit more formally.
    The index is an <em>abstract</em> data type,<span class="note">Also called a <em>container type</em>.</span>
    and cannot be used as-is;
    the <em>key</em> and the <em>value</em> must first be given a type.
    The resulting <em>concrete data type</em> can then be instantiated.
    (In the above,
    <code>Index</code> is the abstract data type,
    and <code>Webcache</code> is the concrete data type,
    with <code>Url</code>s as keys
    and <code>Page</code>s as values.)
    We say that an index <q>maps <code>K</code>s onto <code>V</code>s</q>
    if its key type is <code>K</code>
    and its value type is <code>V</code>.
    Given an index <code>i</code>
    that maps <code>K</code>s onto <code>V</code>s,
    we can specify the semantics of operations on it.
    In the following,
    the variable <code>key</code> is of type <code>K</code>,
    and the variable <code>value</code> is of type <code>V</code>:
  </p>

  <ul>
    <li><strong class="item"><code>value = i.search(key)</code></strong>
	If there is a value associated with <code>key</code> in <code>i</code>,
	<code>value</code> will be that value.
	Otherwise, <code>value</code> will be <code>null</code>.
	Note that with a <code>null</code> type, an index can be seen as a <em>total</em> function.
	The <code>search</code> function is also called <code>find</code>, <code>fetch</code>, <code>read</code>, and <code>get</code>.
      </li>
    <li><strong class="item">
	<code>i-&gt;insert(key, value);</code>
      </strong>
	Subsequent calls to <code>i-&gt;search(key)</code> will return <code>value</code>
	(until subsequent calls to <code>i-&gt;insert(k, —)</code> or <code>i-&gt;remove(k)</code>,
	where <code>k == key</code>).
	The <code>insert</code> function is also called <code>store</code>, <code>set</code>, <code>save</code>, and <code>add</code>.
      </li>
    <li><strong class="item">
	<code>i-&gt;remove(key);</code>
      </strong>
	Subsequent calls to <code>i.read(key)</code> will return <code>null</code>
	(until subsequent calls to <code>i-&gt;insert(k, —)</code> or <code>i-&gt;remove(k)</code>,
	where <code>k == key</code>).
	  The <code>remove</code> function is also called <code>delete</code>.
	  It may also be absent,
	  in favour of <code>insert(k, null)</code>
	  (suggesting the <q>total function</q> interpretation).
      </li>
  </ul>

</section>
  <section xml:base="what_is_an_index/formalizing_behavior_a_set_adt.html">
  <h3>Formalizing behavior: a Set <abbr title="Abstract Data Type" class="smallcaps">ADT</abbr></h3>

  <p>
    A correct index implementation will satisfy the behavior described above.
    To <em>prove</em> that one does so, however,
    we shall have to describe the behavior more precisely.
  </p>

  <p>
    The basic tool we use to do this is the concept of of <em>pre- and post-conditions</em>.
    <span class="note">
      This is a central concept of Hoare logic.<span class="note">hoare</span>
      There is a lot more to basic Hoare logic,
      but here I am only specifying behaviour,
      not proving that anything satisfies it.
    </span>
    In the context of writing a specification,
    these let us specify the possible valid states of the program before executing a command,
    and what the state of the program will be after execution of it.
    For example, we might state that if <span class="math">x=<span class="constant">2</span></span> prior to executing <code>x=square(x)</code>,
    then <span class="math">x=<span class="constant">4</span></span> afterwards.
    This would be written as the <q>Hoare triple</q>
    <span class="triple"><span class="cond math">x=<span class="constant">2</span></span><span class="command code">x=square(x)</span><span class="cond math">x=<span class="constant">4</span></span></span>.
    <span class="note">
      Actually, the triple makes no assertions as to whether the command terminates,
      so the assertion made is strictly that
      the postcondition will hold <em>if and when</em> the command terminates.
      A second syntax is used for assertions that the command terminates:
      \TermTriple{x=<span class="constant">2</span>}{x=square(x)}{x=<span class="constant">4</span>}.
      I do not concern myself with this here or in the specification.
    </span>
    More complex <q>commands</q>,
    such as the operations on an index,
    can be specified in the same way:
    <span class="triple"><span class="cond math">…</span><span class="command code">i-&gt;insert(k, v)</span><span class="cond math">…</span></span>.
    For an operation like this,
    the precondition must capture
    the valid states of the variables <code>i</code>, <code>k</code> and <code>v</code>.
  </p>

  <p>
    However, <code>i</code>, a pointer to a valid index in memory,
    can be a problematic thing to capture.
    First, we don't actually <em>know</em> what a valid index looks like,
    because, as in the above descriptions,
    we do not want to concern ourselves with these low-level details
    when describing behavior.
    Second, even if we did want to describe memory layout,
    the details of this would be too complex to be practicable in a specification.
  </p>

  <p>
    The solution is simply to skip over this problem at this stage,
    and instead use an <em>abstract predicate</em>
    to describe what <code>i</code> represents to the programmer using it,
    namely, <q>a pointer to something representing an index containing…</q>.
    This predicate over <code>i</code> is written as <span class="pred_name">Index</span>(<code>i</code>, <span class="constant">I</span>).
  </p>

  <p>
    A bit more notation is necessary to describe the mappings in an index.
    However, at this point and with familiar set notation,
    we can already fully specify a similar abstract data type: the <em>set</em>.
    This will be useful, because a data structure representing an index
    can be constructed by minimal modification of a set data structure.
  </p>

  <p>
    The following functions for a Set <abbr title="Abstract Data Type" class="smallcaps">ADT</abbr>, and their specifications, should be intuitive.
    We can <code>search</code> for, <code>insert</code>, and <code>remove</code> elements from the set,
    just as we can do with mappings in an index.
    The pre- and postconditions simply describe
    how and whether the functions mutate the set,
    and how information is extracted from the structure.
  </p>

  <table>
    <tbody>
      <tr>
	<!-- search where key is in the set -->
	<td><span class="cond math"><span class="pred_name">Set</span>(<code>s</code>, <span class="constant">S</span>) ∧ <code>el</code> ∈ <span class="constant">S</span></span></td>
	<td><code>exists = s-&gt;search(el);</code></td>
	<td><span class="cond math"><span class="pred_name">Set</span>(<code>s</code>, <span class="constant">S</span>) ∧ <code>el</code> ∈ <span class="constant">S</span> ∧ <code>exists</code> = <span class="constant">T</span></span></td>
      </tr>
      <tr>
	<!-- search where key is not in the set -->
	<td><span class="cond math"><span class="pred_name">Set</span>(<code>s</code>, <span class="constant">S</span>) ∧ <code>el</code> ∉ <span class="constant">S</span></span></td>
	<td><code>exists = s-&gt;search(el);</code></td>
	<td><span class="cond math"><span class="pred_name">Set</span>(<code>s</code>, <span class="constant">S</span>) ∧ <code>el</code> ∉ <span class="constant">S</span> ∧ <code>exists</code> = <span class="constant">F</span></span></td>
      </tr>
      <tr>
	<!-- insert -->
	<td><span class="cond math"><span class="pred_name">Set</span>(<code>s</code>, <span class="constant">S</span>)</span></td>
	<td><code>s-&gt;insert(el);</code></td>
	<td><span class="cond math"><span class="pred_name">Set</span>(<code>s</code>, <span class="constant">S</span> ∪ { <code>el</code> })</span></td>
      </tr>
      <tr>
	<!-- remove -->
	<td><span class="cond math"><span class="pred_name">Set</span>(<code>s</code>, <span class="constant">S</span>)</span></td>
	<td><code>s-&gt;remove(el);</code></td>
	<td><span class="cond math"><span class="pred_name">Set</span>(<code>s</code>, <span class="constant">S</span> − { <code>el</code> })</span></td>
      </tr>
    </tbody>
  </table>
</section>
  <section xml:base="what_is_an_index/formalizing_index_behavior.html">
  <h3>An index <e:api/> specification</h3>

  <p>
    Specifying an index <e:adt/> is only marginally more complex.
    As with the set <span class="constant">S</span>, the index <span class="constant">I</span> is now purely logical,
    and we can describe it mathematically without concern for memory layout or local variables.
    <span class="constant">I</span> is a mapping from a set of keys
    (which is a subset of the universe of keys)
    to a universe of values.
    In other words it is a <em>finite partial function</em>,
    written as
    <span class="math"><span class="constant">I</span> : <e:fst><span class="constant">Keys</span></e:fst> ⇀<sub>fin</sub> <e:snd><span class="constant">Values</span></e:snd></span>.
  </p>

  <p>
    As <span class="constant">Keys</span> is just a set,
    we can express whether or not a key is in the index
    using ordinary set notation:
    <span class="math"><span class="var">x</span> ∈ KeysOf(I)</span> states that
    there is a mapping in the index from <span class="var">x</span> to some value.
    As <span class="constant">I</span> is a function,
    we can express a specific mapping
    using ordinary function notation:
    <span class="math">I(x) = y</span> states that
    there is a mapping in the index from <span class="var">x</span> to <span class="var">y</span>.
  </p>

  <p>
    With just a couple more shorthand notations,
    we can then express the desired behavior of the index.
    First, the <em>function update</em> notation,
    <e:fst>I</e:fst> [ <e:snd>k</e:snd> ↦ <e:thd>v</e:thd>],
    denotes the finite partial function <e:fun>I</e:fun> with the modification that <span class="math">I(k) = v</span>.
    Second, the <em>set difference</em> notation <e:fst><span class="constant">I</span></e:fst> ∖ <e:snd>{ <span class="var">k</span> }</e:snd>
    is a shorthand for <span class="constant">I</span> with the removal of the key <span class="var">k</span> from KeysOf(I).
  </p>

  <p>
    The specification of the desired index behavior follows.
  </p>

  <table>
    <tbody>
      <tr>
	<!-- search where key is in the index -->
	<td><span class="cond math"><span class="pred_name">Index</span>(<code>i</code>, <span class="constant">I</span>) ∧ I(<code>k</code>) = <span class="var">v′</span></span></td>
	<td><code>v = i-&gt;search(k);</code></td>
	<td><span class="cond math"><span class="pred_name">Index</span>(<code>i</code>, <span class="constant">I</span>) ∧ I(<code>k</code>) = <span class="var">v′</span> ∧ <code>v</code> = <span class="var">v′</span></span></td>
      </tr>
      <tr>
	<!-- search where key is not in the index -->
	<td>
	  <span class="cond math">
	    <span class="pred_name">Index</span>(<code>i</code>, <span class="constant">I</span>)
	    ∧ <e:fst><code>k</code></e:fst> ∉ <e:snd><span class="keysof">Keys</span>(<span class="constant">I</span>)</e:snd>
	  </span>
	</td>
	<td><code>v = i-&gt;search(k);</code></td>
	<td>
	  <span class="cond math">
	    <span class="pred_name">Index</span>(<code>i</code>, <span class="constant">I</span>) ∧
	    <e:fst><code>k</code></e:fst> ∉ <e:snd><span class="keysof">Keys</span>(<span class="constant">I</span>)</e:snd> ∧
	    <code>v</code> = <code>null</code>
	  </span>
	</td>
      </tr>
      <tr>
	<!-- insert where key is in the index -->
	<td><span class="cond math"><span class="pred_name">Index</span>(<code>i</code>, <span class="constant">I</span>) ∧ I(<code>k</code>) = <span class="var">v′</span></span></td>
	<td><code>i-&gt;insert(k, v);</code></td>
	<td><span class="cond math"><span class="pred_name">Index</span>(<code>i</code>, <span class="constant">I</span>) ∧ I(<code>k</code>) = <span class="var">v′</span></span></td>
      </tr>
      <tr>
	<!-- insert where key is not in the index -->
	<td><span class="cond math"><span class="pred_name">Index</span>(<code>i</code>, <span class="constant">I</span>) ∧ <e:fst><code>k</code></e:fst> ∉ <e:snd><span class="keysof">Keys</span>(<span class="constant">I</span>)</e:snd></span></td>
	<td><code>i-&gt;insert(k, v);</code></td>
	<td><span class="cond math"><span class="pred_name">Index</span>(<code>i</code>, <span class="constant">J</span>) ∧ <e:fst><span class="constant">I</span></e:fst> [ <e:snd><code>k</code></e:snd> ↦ <e:thd><code>v</code></e:thd>]</span></td>
      </tr>
      <tr>
	<!-- remove -->
	<td><span class="cond math"><span class="pred_name">Index</span>(<code>i</code>, <span class="constant">I</span>)</span></td>
	<td><code>\IC{i-&gt;remove(k);</code></td>
	<td><span class="cond math"><span class="pred_name">Index</span>(<code>i</code>, <e:fst><span class="constant">I</span></e:fst> ∖ <e:snd>{ <code>k</code> }</e:snd>)</span></td>
      </tr>
    </tbody>
  </table>
</section>
</section>
  <section>
  <h3>Index and set algorithms</h3>

  <p>
    In the previous section,
    the function calls, and their specifications,
    did not reveal anything about
    what <code>i</code> looks like <q>inside</q>:
    we don't know how memory is laid out,
    or even what <em>parts</em> of memory are allocated for this.
    Nor did we specify what a call to <code>search</code> (for example) actually <em>does</em>,
    and nor did we specify how long it might take
    (nor even if it halts at all!).
  </p>

  <p>
    This was necessary and desirable.
    It was desirable because it enables the programmer to
    reason about the index as a mathematical construct.<span class="note">In various terminologies, our <code>Index</code> <e:api/> uses <q>information hiding</q>, also called <q>encapsulation</q>.</span>
    It was necessary in order to separate specification from implementation.
    This is particularly important in the case of indexes and sets,
    where a large number of data structures exist that satisfy our <e:api/>.
    The following is a very partial list:

    <ul class="listTable listTable4">
      <li>Array</li>
      <li>Association list</li>
      <li>Radix tree</li>
      <li>van Emde Boas tree</li>
      <li>Skip list</li>
      <li>Hash table</li>
      <li>Binary tree</li>
      <li>Splay tree</li>
      <li>AVL tree</li>
      <li>Bloomier filter</li>
      <li>Red-Black Tree</li>
      <li>AA-tree</li>
      <li>LLRB-tree</li>
      <li>B-tree</li>
      <li>B<sup>+</sup>-tree</li>
      <li>B<sup>*</sup>-tree</li>
    </ul>
  </p>

  <p>
    After examining of a few of these,
    it will become quickly evident that
    most <em>index</em> data structures are simply <em>set</em> structures
    with values <q>plugged in</q> next to the key.
    An index <span class="constant">I</span> : <e:fst>K</e:fst> ⇀<sub>fin</sub> <e:snd>V</e:snd> can be represented by
    a set of tuples <span class="math">(k, v)</span>
    (where <e:fst><span class="var">k</span></e:fst> ∈ <e:snd><span class="constant">K</span></e:snd> and <e:fst><span class="var">v</span></e:fst> ∈ <e:snd><span class="constant">V</span></e:snd>),
    with the restriction that no two elements have the same <span class="var">k</span> value.
    Where the algorithms take this approach,
    for simplicity I instead describe them as implementing a set.
  </p>

  <p>
    Each approach has its own performance and memory characteristics.
    Some have certain restrictions and changes in semantics:
    that the universe of keys must be finite, for instance;
    or that multiple values of the same key can exist.
    A good implementation of a <em>generic</em> index—one
    that implements the API we described,
    for any universe of keys with an ordering—requires O(<span class="var">n</span>) memory
    and guarantees O(log(<span class="var">n</span>)) time, or better, for each operation
    (where <span class="var">n</span> is the number of keys in the index).
  </p>

  <p>
    Let's now run through the features of a few index data structures.
    We will then look at specifying a few more formally.
  </p>

  <section>
    <h4>Array</h4>

    <p>
      The array is undoubtedly the simplest index algorithm:
      we allocate memory for all members of the universe of keys,
      and initialize all associated values to <code>null</code>.
      It has O(<span class="constant">1</span>) complexity for all operations
      as the location of the key in memory is a simple offset operation.
      This is (heavily) paid for in terms of memory,
      the use of which is O(<span class="var">u</span>), where <span class="var">u</span> is the size of the universe of keys.
      The array is most commonly used where the key type is <code>int</code>,
      but can be used with other types if each key maps to a unique integer.
      Additionally, the array is only possible where the universe of keys is finite—strings,
      for example, are off-limits.
      An array is sensible where
      there is a small allowed key range
      and most or all keys are expected to have a value,
      <i>e.g.</i> a map <e:fst><code>char</code></e:fst> ⇀<sub>fin</sub> <e:snd><code>char</code></e:snd> for use in a function <code>string toUpper(string)</code>.
      Otherwise, an algorithm with a memory complexity of O(<span class="var">n</span>) is better.
    </p>
  </section>

  <section>
    <h4>Hash table</h4>

    <p>
      The hash table attempts to solve the array's O(<span class="var">u</span>) memory use
      by choosing an array size
      and storing more than one key at each location.
      The key's location in the array (its <q>bucket</q>)
      is decided by a hash function <span class="var">h</span>.
      Keys in the same bucket are typically chained in a linked list.
      The function $h$ varies from extremely simple
      (<i>e.g.</i>, h(k) = k % n)
      to complex (<i>e.g.</i>, cryptographic functions).
      The hash table has O(<span class="var">n</span>) worst-case behavior
      in the case that all keys map to the same bucket.
      By design, it has poor locality of reference—a good hash function
      spreads similar keys evenly over buckets.
      There is no obvious ordered iteration algorithm.
    </p>
  </section>

  <section>
    <h4>Association list</h4>

    <p>
      The association list is a linked list of values of type <code>(K, V)</code>.
      It removes the two disadvantages of the array:
      its size is O(<span class="var">n</span>),
      and the key universe does not have to be finite.
      It pays for this with O(<span class="var">n</span>) time complexity
      (except for <code>insert</code>, where the new element may be appended to the head of the list).
      The association list might be desirable for its simplicity,
      and where the number of elements is expected to be short;
      it is ofted used, for example, in more complex structures including hash tables.
    </p>

    <p>
      There are many modifications to the basic linked list,
      and these apply to the association list too.
      The <q>linking</q> can be done in both directions
      to allow bidirectional traversal.
    </p>
  </section>


  <section>
    <h4>Binary search tree</h4>

    <p>
      The <abbr title="Binary Search Tree" class="smallcaps">BST</abbr> can be seen as an improvement of the linked list,
      arising from the observation that the nodes of an linked list
      can be generalized to contain any number of links.
      Following a link in a linked list
      only reduces the set being searched by one element;
      following one link out of a possible two, however,
      potentially halves the number of elements in the candidate set.
    </p>

    <p>
      The division made at each node is into
      elements smaller than the element being looked at
      and elements larger than it.
      Therefore, the key type of a <abbr title="Binary Search Tree" class="smallcaps">BST</abbr>
      must have an <em>ordering</em>;
      in practise this does not pose a real problem
      as arbitrary data can always be lexicographically ordered.
    </p>

    <p>
      The division that takes place at every step
      gives the <abbr title="Binary Search Tree" class="smallcaps">BST</abbr> a best-case complexity
      of Ω(log(<span class="var">n</span>)) for all operations.
      <span class="note">
	The skip list is another, which does this by <q>skipping over</q> more than one node at a time.
	<q>Balancing</q> is done by randomizing the height of nodes.
	I ignore it because it uses randomization, which is ugly.
      </span>
      However, the worst-case scenario,
      in which one of the two sets at every node is the empty set,
      is equivalent to a linked list,
      and thus the <abbr title="Binary Search Tree" class="smallcaps">BST</abbr> still has O(<span class="var">n</span>) complexity.
    </p>
  </section>


  <section>
    <h4>Splay tree</h4>

    <p>
      One way to tackle the worst-case of the <abbr title="Binary Search Tree" class="smallcaps">BST</abbr>
      is simply to reduce its relevance
      by ensuring it is a practical corner-case.
      This is by no means the case with the standard <abbr title="Binary Search Tree" class="smallcaps">BST</abbr>:
      data is often inserted in an <q>almost-sorted</q> order;
      In a worst-case <abbr title="Binary Search Tree" class="smallcaps">BST</abbr> with the smallest value at the root,
      accessing the largest value still exhibits O(<span class="var">n</span>) time complexity.
    </p>

    <p>
      The Splay tree tries to make the worst-case less relevant
      by ensuring it does not happen repeatedly.
      It does this by, on every operation,
      restructuring the tree to move the latest-accessed element to the root.
      This does not change the complexity of the <abbr title="Binary Search Tree" class="smallcaps">BST</abbr> operations,
      <span class="note">Unlike the <abbr title="Binary Search Tree" class="smallcaps">BST</abbr>, it does perform all operations in <em>amortized</em> O(log(<span class="var">n</span>)); but its worst-cases are still O(log(<span class="var">n</span>)).</span>
      and instead makes use of the same principle as caching: locality of reference.
      The worst-case is still exhibited in other situations:
      after <code>search</code>ing for all elements in order,
      the tree will be perfectly unbalanced.
    </p>

    <p>
      The Splay tree has the advantage that it is (relatively) simple:
      the data structure is the same as the <abbr title="Binary Search Tree" class="smallcaps">BST</abbr>,
      and the algorithms are the same except for the addition of the <code>splay</code> method.
      Its disadvantages are significant though:
      it does not provide any worst-case improvement,
      and, unlike other index data structures here,
      its <code>search</code> algorithm mutates the tree.
    </p>
  </section>

  <section>
    <h4>AVL tree</h4>

    <p>
      The AVL tree improves on the <abbr title="Binary Search Tree" class="smallcaps">BST</abbr>,
      finally reducing all operations to Θ(log(<span class="var">n</span>)).
      It does this by ensuring that the height of the two subtrees of any node
      differ by at most one.<span class="note">cormen, p. 296.</span>
      We first define the <em>height</em> of a node n as

      <table class="displaymath">
	<tbody>
	  <tr><td>height(n) = </td>  <td>0</td>                                         <td>if <span class="var">n</span> is null,</td></tr>
	  <tr><td/>              <td>max(height(n.left), height(n.right)) + 1</td>  <td>otherwise.</td></tr>
	</tbody>
      </table>
    </p>

    <p>
      We then define <em>balance factor</em> of a node <span class="var">n</span> as

      <table class="displaymath">
	<tbody>
	  <tr><td>bf(n) = </td>  <td>0</td>                                 <td>if <span class="var">n</span> is null,</td></tr>
	  <tr><td/>          <td>height(n.left) - height(n.right)</td>  <td>otherwise.</td></tr>
	</tbody>
      </table>
    </p>

    <p>
      We can then define an AVL tree recursively as

      <div class="displaymath">
	<span class="pred_name">AVLTree</span>(<code>n</code>) = -1 ≤ bf(<code>n</code>) ≤ 1 ∧ <span class="pred_name">AVLTree</span>(<code>n.left</code>) ∧ <span class="pred_name">AVLTree</span>(<code>n.right</code>).
      </div>

      It is the node's balance factor,
      rather than the height,
      that is stored in the node.<span class="note">\cite{haskell_avl}, the most-documented and -commented AVL tree source I know of.</span>
      (As, by the definition of the AVL tree,
      the balance factor only ever has one of three possible values,
      this can take up only two bits.)
    </p>
  </section>

  <section>
    <h4>B-tree</h4>

    <p>
      The B-tree is primarily motivated by a different problem with the <abbr title="Binary Search Tree" class="smallcaps">BST</abbr>:
      the number of storage reads is Ω(log<sub>2</sub>(<span class="var">n</span>)).
      For media with slow seek times and low granularity
      (such as your hard disk),
      this is too high, and wasteful.
      The B-tree's improvement starts by generalizing the binary tree to a <span class="var">k</span>-ary tree,
      reducing the number of reads to Ω(log<sub>k</sub>(<span class="var">n</span>)) (where <span class="var">k</span> &gt; 2).
      The full solution, however, naturally leads to
      another method to bound the height of the tree in the order of log(<span class="var">n</span>).
    </p>

    <p>
      A <span class="var">k</span>-ary search tree holds <span class="var">k</span>−1 elements at each node.
      But it is infeasible to demand that each node holds this maximum amount—for
      one thing, we could only store multiples of <span class="var">k</span>−1 elements!
      This must be relaxed so a node can be less than <q>full</q>.
      However, this must not be relaxed so far that
      a node can hold just one (or zero!) elements,
      because the Ω(log<sub>2</sub>(<span class="var">n</span>)) storage reads then reappears.
      The B-tree approach demands that each node<span class="note">The root node is an exception, and can be anywhere between empty and full.</span>
      is between half-full<span class="note">The B<sup>*</sup>-tree demands that nodes are at least two-thirds full.</span> and full.
      More precisely, we can define a B-tree in terms of an integer <span class="var">t</span>,
      such that for each node in that tree,
      its number of elements <span class="var">e</span> is such that
      t−1 ≤ e ≤ 2t−1.<span class="note">cormen</span>
    </p>

    <p>
      To illustrate why balance naturally falls out of this,
      consider inserting a value.
      Once we have searched for its position,
      we cannot simply create a new node there,
      as this would not satisfy the restriction on the number of elements.
      Instead the value must be inserted into an existing leaf node.
      If space does not exist at the leaf,
      we create space by splitting the node into two at the same level,
      and inserting the previous median value in the parent using the same technique.
      If the splitting does not reach the root, the depth of the tree is unchanged.
      Otherwise, the root splits, and the depth increases by one for all leaf nodes.
      We can therefore add the additional constraint to the B-tree definition
      that all leaves have the same depth,
      from which we can show that
      the height of a B-tree is Θ(log(<span class="var">n</span>)).
    </p>

    <p>
      Rather than bubble-up the node-splitting,
      most B-tree algorithms actually do this on the downwards traversal
      to the node at which the element will be inserted.
      The procedure is simple: every full node visited is split before moving down one level,
      and the median element inserted into the parent.
      (We can guarantee that the parent is non-full
      precisely due to the top-down order of the procedure.)
      The effect is not equivalent,
      as the top-down procedure splits all full nodes,
      where the bubble-up procedure only splits as many as necessary.
      However, balance is still maintained:
      as before, the only time that new levels are created is when the root is split.
    </p>
  </section>
</section>
  <section>

  <h3>Indexes in the wild</h3>

  <p>
    Performance of the many index algorithms is well-covered.
    However, not all are commonly in use.
    A survey of what's-used-where
    should shed light on
    what characteristics are considered most important.
  </p>

  <ul>
    <li><strong class="item">C++ Standard Template Library</strong>
	The GNU implementation
	uses <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr>s for sets and maps.<span class="note">libstdcpp_stl_tree_h. <q>The insertion and deletion algorithms are based on those in Cormen, Leiserson, and Rivest, <i>Introduction to Algorithms</i></q>.
	  Used to implement <code>std::set</code>, <code>std::multiset</code>, <code>std::map</code>, and <code>std::multimap</code>.</span>
      </li>
    <li><strong class="item">Java Class Library</strong>
	<code>TreeMap</code> uses a <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr>.
	<span class="note">
	  <span class="note">TreeMap_java</span>: <q>This class provides a red-black tree implementation of the SortedMap interface.  <e:lacuna/> The algorithms are adopted from Corman, Leiserson, and Rivest's <i>Introduction to Algorithms</i>.</q>
	</span>
      </li>
    <li><strong class="item">.NET standard library</strong>
	This uses a <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr> for its <code>SortedDictionary</code> and <code>SortedSet</code> classes,
	at least in the Mono Project implementation<span class="note">RBTree_cs</span>.
      </li>
    <li><strong class="item">Linux kernel</strong>
	This uses <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr>s for I/O scheduling and for virtual memory.
	It uses a pseudo-templating style in C, so there's only one implementation: <code>lib/rbtree.c</code>.
	<span class="note">
	  <span class="note">linux_kernel_lib</span>.
	  In the same directory one will find
	  <code>btree.c</code>, implementing a B+tree,
	  and <code>radix-tree.c</code>, implementing a radix tree.
	</span>
      </li>
    <li><strong class="item">ext3 filesystem</strong>This uses a <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr> for directory entries.</li>
    <li><strong class="item">Python</strong>
	The <q>CPython</q> implementation uses a hash.
	<span class="note">
	  <span class="note">python_dictobject_c</span>.
	  In the same directory one will also find <code>dictnotes.txt</code>, an in-depth discussion on optimization of the Python dictionary structure.
	</span>
      </li>
    <li><strong class="item">Ruby</strong>This uses a hashing algorithm for its index.</li>
    <li><strong class="item">mobile telephones ...</strong></li>
  </ul>

  <p>
    It seems that
    most standard libraries
    and low-level codebases
    prefer the <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr>
    to the many alternatives.
  </p>
</section>
  <section>

  <h3>Some predicate definitions</h3>

  <p>
    Earlier, in our index API specification,
    we introduced the predicate <span class="pred_name">Index</span>(<code>i</code>, <span class="constant">I</span>).
    This simply says that <q><code>i</code> represents the index <span class="constant">I</span></q>.
    This was deliberately <em>abstract</em>,
    so that individual index implementations could define it themselves.
    Now we've looked at a few index data structures,
    how can we formally describe them?
  </p>

  <p>
    Our main tool here is <em>separation logic</em>,
    an extension of <em>Hoare logic</em> with practical operators to describe the state of the heap.
    Here, I only specify the set versions of the data structures.
  </p>
</section>
</section>
      <section xml:base="ll/ll.html">

  <h2>Verifying linked lists</h2>

  <p>
    I have chosen to start with the linked list (<abbr title="Linked List" class="smallcaps">LL</abbr>),
    as it is the simplest non-trivial data structure
    and is easy to specify.
    The linked list is a recursive data structure—the structure contains itself.
    We might  define it in C as:
  </p>

  <pre>
    struct List {
    int value;
    struct list * tail;
    };
  </pre>

  <p>
    An instance of <code>List</code> is interpreted as representing a non-empty set.
    The <code>value</code> field is one of the members of that set,
    and all other members are held in the list pointed at by the <code>tail</code> field.
    An empty set is represented by the <code>null</code> pointer.
    We use a pointer to represent an arbitrary set, empty or not.
    Therefore, for any pointer <code>s</code>,
    we should be able to define a predicate <span class="pred_name">Set</span>(<code>s</code>, <span class="constant">S</span>).
  </p>

  <p>
    Translating these statements to separation logic is fairly straightforward.
    Either <code>s</code> is <code>null</code>, or it is not.
    If it is <code>null</code>, then
    <span class="constant">S</span> = ∅ (the empty set),
    and the heap pertinent to the linked list is empty (represented by <b>emp</b>).
    If <code>s</code> is not <code>null</code>,
    then it points to a valid <code>list</code> node:
    <e:fst><code>s</code></e:fst> ↦ <e:snd><code>tail</code>, <span class="var">value</span></e:snd>.
    As <code>tail</code> is a list pointer,
    we can recursively apply the predicate to it:
    <span class="pred_name">Set</span>(<code>tail</code>, <span class="constant">R</span>).
    The node description and the <code>tail</code> description
    are joined with the separating conjunction,
    because the tail does not contain the node pointed at by <code>s</code>
    (if it did, we would be in trouble!).
    Finally, <code>value</code> and the set <span class="constant">R</span>
    together make up the set <span class="constant">S</span>:
    <e:fst><e:fst>R</e:fst> ∪ <e:snd>{ <span class="var">value</span> }</e:snd></e:fst> = <e:snd>S</e:snd>.
    Here's the formal definition:

    <table class="displaymath">
      <tr>
	<td><span class="pred_name">Set</span>(<code>s</code>, S) ≝</td>
	<td>(<e:fst><code>s</code></e:fst> = <e:snd><code>null</code></e:snd> ∧ <e:fst>S</e:fst> = <e:snd>∅</e:snd> ∧ <b>emp</b>) ∨</td>
      </tr>
      <tr>
	<td/>
	<td>
	  (∃<span class="var">tail</span>, <span class="var">value</span>.
	  <e:fst><code>s</code></e:fst> ↦ <e:snd><span class="var">tail</span>, <span class="var">value</span></e:snd>
	  ∗ <span class="pred_name">Set</span>(<code>tail</code>, <e:fst>S</e:fst> ∖ <e:snd>{ <span class="var">value</span> }</e:snd>)
	</td>
      </tr>
    </table>
  </p>
</section>
      <section xml:base="bst/bst.html">
  
  <h2>Verifying the <abbr title="Binary Search Tree" class="smallcaps">BST</abbr></h2>

  <p>
    The first data structure I address in this project is the <abbr title="Binary Search Tree" class="smallcaps">BST</abbr>.
    I begin with a description of the data structure.
    I then verify recursive algorithms for <code>search</code>, <code>insert</code>, and <code>remove</code>.
    Finally, I will verify iterative algorithms for the same procedures.
  </p>

  <section>
  
  <h3>The <abbr title="Binary Search Tree" class="smallcaps">BST</abbr> data structure</h3>

  <p>
    Here's an unordered binary tree representing a set:
  </p>

  <p>
    Here's the ordered <abbr title="Binary Search Tree" class="smallcaps">BST</abbr>:
  </p>

  <table class="displaymath">
    <tbody>
      <tr>
	<td><span class="pred_name">Set</span>(<code>s</code>, S) ≝</td>
	<td>(<code>s</code> = <code>null</code> ∧ S = ∅ ∧ <b>emp</b>) ∨</td>
      </tr>
      <tr>
	<td/>
	<td>
	  ∃<span class="var">l</span>, <span class="var">r</span>, <span class="var">v</span>.<br/>
	  <e:fst>s</e:fst> ↦ <e:snd><span class="var">l</span>, <span class="var">r</span>, <span class="var">v</span></e:snd><br/>
	  ∧ <e:fst>v</e:fst> ∈ <e:snd>S</e:snd><br/>
	  ∗ <span class="pred_name">Set</span>(<span class="var">l</span>, <span class="set math"><e:fst>v′</e:fst> : <e:snd><e:fst>v′</e:fst> ∈ <e:snd>S</e:snd> ∧ v′ &lt; v</e:snd></span>)<br/>
	  ∗ <span class="pred_name">Set</span>(r, <span class="set math"><e:fst>v′</e:fst> : <e:snd><e:fst>v′</e:fst> ∈ <e:snd>S</e:snd> ∧ v′ &gt; v</e:snd></span>)
	</td>
      </tr>
    </tbody>
  </table>

  <p>
    Here is the module defining the structure of a node in the tree:

    <div class="display">
      <section xml:base="../../code/d/html/bst/node.d.html"><pre class="prettyprint">module bst.node;

struct Node {
  int value;   // One value in the set held in this subtree
  Node*[2] c;  // Pointers to the two subtrees (0 is left, 1 is right)

  this(int value) {
    this.value = value;  // The subtree pointers are initialized to null.
  }
} </pre></section>
    </div>
  </p>

  <p>
    Notice the use of a <q>link array</q>:
    rather than separate named <code>left</code> and <code>right</code> pointers,
    these two pointers are held in a two-element array,
    addressed respectively as <code>c[0]</code> and <code>c[1]</code>.
    This enables us to parameterize procedures by the index
    where the symmetry of the tree would otherwise demand two symmetrical blocks of code.
  </p>

  <p>
    We now wish to describe how such a data structure enables us to represent a set.
    Let's start with the easy case: the empty set.
    This is represented simply by a null pointer.
    We can describe that tree like so:

    <table class="displaymath">
      <tbody>
	<tr>
	  <td><span class="pred_name">EmptyTree</span>(<span class="var">n</span>, <span class="var">S</span>) ≝</td>
	  <td><e:fst><span class="var">n</span></e:fst> = <e:snd><code>null</code></e:snd> ∧</td>
	  <td>An empty tree is indicated by a null pointer, </td>
	</tr>
	<tr>
	  <td/>
	  <td><b>emp</b> ∧</td>
	  <td>uses no space on the heap, and</td>
	</tr>
	<tr>
	  <td/>
	  <td><e:fst><span class="var">S</span></e:fst> = <e:snd>∅</e:snd>.</td>
	  <td>represents the empty set.</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    To describe a tree containing more than zero elements,
    we need to describe the ordering on those elements.
    I choose to do this in a separate predicate.
    For some node at location <code>n</code>, call the element stored there <span class="var">v</span>,
    the set stored in its left subtree <span class="st">L</span>,
    and the set stored in its right subtree <span class="st">R</span>.
    The set <span class="st">S</span> stored by the subtree rooted at <code>n</code> is the union of those elements.
    Because the tree is ordered, all elements in <span class="var">L</span> are less than <span class="var">v</span>
    and all elements in <span class="st">R</span> are greater than <span class="var">v</span>.
    We can express the relation between these elements by a predicate
    <span class="pred_name">Compose</span>(<span class="st">L</span>, <span class="var">v</span>, <span class="st">R</span>, <span class="st">S</span>):
    
    <table class="displaymath">
      <tbody>
	<tr>
	  <td><span class="pred_name">Compose</span>(<span class="st">L</span>, <span class="var">v</span>, <span class="st">R</span>, <span class="st">S</span>) ≝</td>
	  <td>
	    <e:fst>
	      <e:fst><span class="st">L</span></e:fst> ∪ <e:snd>
		  <e:fst>{ <span class="var">v</span> }</e:fst> ∪ <e:snd><span class="st">R</span></e:snd>
		</e:snd>
	      </e:fst> = <e:snd><span class="st">S</span></e:snd> ∧
	  </td>
	  <td><span class="st">L</span>, <span class="var">v</span>, and <span class="st">R</span> make up the set <span class="st">S</span>,</td>
	</tr>
	<tr>
	  <td/>
	  <td>
	    ∀<e:fst>
		<e:fst><span class="var">l</span></e:fst> ∈ <e:snd><span class="st">L</span></e:snd>
	      </e:fst>. <e:snd>
		<e:fst><span class="var">l</span></e:fst> &lt; <e:snd><span class="var">v</span></e:snd>
	      </e:snd> ∧
	  </td>
	  <td>all values in <span class="st">L</span> are less than <span class="var">v</span>, and</td>
	</tr>
	<tr>
	  <td/>
	  <td>
	    ∀<e:fst>
		<e:fst><span class="var">r</span></e:fst> ∈ <e:snd><span class="st">R</span></e:snd>
	      </e:fst>. <e:snd>
		<e:fst><span class="var">v</span></e:fst> &lt; <e:snd><span class="var">r</span></e:snd>
	      </e:snd>.
	  </td>
	  <td>conversely for <span class="st">R</span>.</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    From a <span class="pred_name">Compose</span> assertion and some value <span class="var">w</span>,
    we know which subset <span class="var">w</span> is in, if any.
    For instance, if <e:fst><span class="var">w</span></e:fst> = <e:snd><span class="var">v</span></e:snd>,
    then <e:fst><span class="var">w</span></e:fst> ∈ <e:snd><span class="st">S</span></e:snd>:

    <table class="derivation displaymath">

      <tr><td>1.</td><td class=""><span class="pred_name">Compose</span>(<span class="st">L</span>, <span class="var">v</span>, <span class="st">R</span>, <span class="st">S</span>)</td><td>given</td></tr>

      <tr><td>2.</td><td class=""><e:fst><span class="var">w</span></e:fst> = <e:snd><span class="var">v</span></e:snd></td><td>given</td></tr>

      <tr><td>3.</td><td class="">
	  <e:fst><span class="var">w</span></e:fst> ∈ <e:snd>{ <span class="var">w</span> }</e:snd>
	</td><td>some axiom presumably</td></tr>

      <tr><td>4.</td><td class="">
	  <e:fst><span class="var">w</span></e:fst> ∈ <e:snd>{ <span class="var">v</span> }</e:snd>
	</td><td>
	  givenLessThan, wInSetOfw, equality
	</td></tr>

      <tr><td>5.</td><td class="">
	  <e:fst>
	      <e:fst><span class="st">L</span></e:fst> ∪ <e:snd>
		  <e:fst>{ <span class="var">v</span> }</e:fst> ∪ <e:snd><span class="st">R</span></e:snd>
		</e:snd>
	    </e:fst> = <e:snd><span class="st">S</span></e:snd> ∧<br/>

	  ∀<e:fst>
	      <e:fst><span class="var">l</span></e:fst> ∈ <e:snd><span class="st">L</span></e:snd>
	    </e:fst>. <e:snd>
	      <e:fst><span class="var">l</span></e:fst> &lt; <e:snd><span class="var">v</span></e:snd>
	    </e:snd> ∧<br/>

	  ∀<e:fst>
	      <e:fst><span class="var">r</span></e:fst> ∈ <e:snd><span class="st">R</span></e:snd>
	    </e:fst>. <e:snd>
	      <e:fst><span class="var">v</span></e:fst> &lt; <e:snd><span class="var">r</span></e:snd>
	    </e:snd>
	</td><td>
	  givenCompose, open predicate
	</td></tr>

      <tr><td>6.</td><td class="">
	  <e:fst>
	      <e:fst><span class="st">L</span></e:fst> ∪ <e:snd>
		  <e:fst>{ <span class="var">v</span> }</e:fst> ∪ <e:snd><span class="st">R</span></e:snd>
		</e:snd>
	    </e:fst> = <e:snd><span class="st">S</span></e:snd>
	</td><td>
	  openCompose, ∧E
	</td></tr>

      <tr><td>7.</td><td class="">
	  <e:fst>{ <span class="var">v</span> }</e:fst> ⊆ <e:snd><span class="st">S</span></e:snd>
	</td><td>LuvuR, subset</td></tr>

      <tr><td>8.</td><td class=""><e:fst><span class="var">w</span></e:fst> ∈ <e:snd><span class="st">S</span></e:snd></td><td>wInSetOfv, SetOfVInS, ?</td></tr>
    </table>

  </p>

  <p>
    If <e:fst><span class="var">w</span></e:fst> &lt; <e:snd><span class="var">v</span></e:snd>,
    then if <span class="var">w</span> is in <span class="st">S</span> then it must be in <span class="st">L</span>,
    and <i>vice versa</i>:
    <span class="note">The case for <e:fst><span class="var">v</span></e:fst> &lt; <e:snd><span class="var">w</span></e:snd> is obviously symmetrical.</span>

    <table class="derivation displaymath">
      <tr><td>1.</td><td class="">
	  <e:fst>
	      <span class="pred_name">Compose</span>(<span class="st">L</span>, <span class="var">v</span>, <span class="st">R</span>, <span class="st">S</span>)
	    </e:fst> ∧ <e:snd>
	      <e:fst><span class="var">w</span></e:fst> &lt; <e:snd><span class="var">v</span></e:snd>
	    </e:snd>
	</td><td>given</td></tr>

      <tr><td>2.</td><td class=""><span class="pred_name">Compose</span>(<span class="st">L</span>, <span class="var">v</span>, <span class="st">R</span>, <span class="st">S</span>)</td><td>given, ∧E</td></tr>

      <tr><td>3.</td><td class=""><e:fst><span class="var">w</span></e:fst> &lt; <e:snd><span class="var">v</span></e:snd></td><td>given, ∧E</td></tr>

      <tr><td>4.</td><td class="">
	  <e:fst>
	      <e:fst><span class="st">L</span></e:fst> ∪ <e:snd>
		  <e:fst>{ <span class="var">v</span> }</e:fst> ∪ <e:snd><span class="st">R</span></e:snd>
		</e:snd>
	    </e:fst> = <e:snd><span class="st">S</span></e:snd> ∧<br/>

	  ∀<e:fst>
	      <e:fst><span class="var">l</span></e:fst> ∈ <e:snd><span class="st">L</span></e:snd>
	    </e:fst>. <e:snd>
	      <e:fst><span class="var">l</span></e:fst> &lt; <e:snd><span class="var">v</span></e:snd>
	    </e:snd> ∧<br/>

	  ∀<e:fst>
	      <e:fst><span class="var">r</span></e:fst> ∈ <e:snd><span class="st">R</span></e:snd>
	    </e:fst>. <e:snd>
	      <e:fst><span class="var">v</span></e:fst> &lt; <e:snd><span class="var">r</span></e:snd>
	    </e:snd>
	</td><td>compose, open predicate</td></tr>

      <tr><td>5.</td><td class="">
	  <e:fst>
	      <e:fst><span class="st">L</span></e:fst> ∪ <e:snd>
		  <e:fst>{ <span class="var">v</span> }</e:fst> ∪ <e:snd><span class="st">R</span></e:snd>
		</e:snd>
	    </e:fst> = <e:snd><span class="st">S</span></e:snd>
	</td><td>open, ∧E</td></tr>

      <tr><td>6.</td><td class="">
	  <e:fst><span class="st">L</span></e:fst> ⊆ <e:snd><span class="st">S</span></e:snd>
	</td><td>LuvuR, subset</td></tr>

      <tr><td>7.</td><td class="indent1">
	  <e:fst><span class="var">w</span></e:fst> ∈ <e:snd><span class="st">L</span></e:snd>
	</td><td>assume</td></tr>

      <tr><td>8.</td><td class="indent1">
	  <e:fst><span class="var">w</span></e:fst> ∈ <e:snd><span class="st">S</span></e:snd>
	</td><td>LsubsetS, assumewInL, member of subset in set</td></tr>

      <tr><td>9.</td><td class="">
	  <e:fst><e:fst><span class="var">w</span></e:fst> ∈ <e:snd><span class="st">L</span></e:snd></e:fst> → <e:snd><e:fst><span class="var">w</span></e:fst> ∈ <e:snd><span class="st">S</span></e:snd></e:snd>
	</td><td>assumewInL, thenwInS, →I</td></tr>

      <tr><td>10.</td><td class="">
	  <e:fst><span class="var">w</span></e:fst> ≠ <e:snd><span class="var">v</span></e:snd>
	</td><td>lt, weakening</td></tr>

      <tr><td>11.</td><td class="">
	  <e:fst><span class="var">w</span></e:fst> ∉ <e:snd>{ <span class="var">v</span> }</e:snd>
	</td><td>noteq, ?</td></tr>

      <tr><td>12.</td><td class="">
	  ∀<e:fst>
	      <e:fst><span class="var">r</span></e:fst> ∈ <e:snd><span class="st">R</span></e:snd>
	    </e:fst>. <e:snd>
	      <e:fst><span class="var">v</span></e:fst> &lt; <e:snd><span class="var">r</span></e:snd>
	    </e:snd>
	</td><td>open, ∧E</td></tr>

      <tr><td>13.</td><td class="">
	  <e:fst><span class="var">w</span></e:fst> ∉ <e:snd><span class="st">R</span></e:snd>
	</td><td>lt, allInRGreaterThanv, <span class="var">w</span> cannot satisfy membership criterion</td></tr>

      <tr><td>14.</td><td class="">
	  <e:fst><span class="var">w</span></e:fst> ∉ <e:snd>(<e:fst>{ <span class="var">v</span> }</e:fst> ∪ <e:snd><span class="st">R</span></e:snd>)</e:snd>
	</td><td>wNotInSetOfv, wNotInR, not in union</td></tr>

      <tr><td>15.</td><td class="indent1">
	  <e:fst><span class="var">w</span></e:fst> ∈ <e:snd><span class="st">S</span></e:snd>
	</td><td>assume</td></tr>

      <tr><td>16.</td><td class="indent1">
	  <e:fst><span class="var">w</span></e:fst> ∈ <e:snd><span class="st">L</span></e:snd>
	</td><td>LuvuR, wNotInvOrR, assumewInS, ??</td></tr>

      <tr><td>17.</td><td class="">
	  <e:fst>
	      <e:fst><span class="var">w</span></e:fst> ∈ <e:snd><span class="st">S</span></e:snd>
	    </e:fst> → <e:snd>
	      <e:fst><span class="var">w</span></e:fst> ∈ <e:snd><span class="st">L</span></e:snd>
	    </e:snd>
	</td><td>assumewInS, thenwInL, →I</td></tr>

      <tr><td>18.</td><td class="">
	  <e:fst>
	      <e:fst><span class="var">w</span></e:fst> ∈ <e:snd><span class="st">L</span></e:snd>
	    </e:fst> ↔ <e:snd>
	      <e:fst><span class="var">w</span></e:fst> ∈ <e:snd><span class="st">S</span></e:snd>
	    </e:snd>
	</td><td>wInLImplieswInS, wInSImplieswInL, ↔I</td></tr>
    </table>
  </p>

  <p>
    If <span class="var">R</span> is the empty set, then <span class="var">v</span> is the maximum in the set:

    <table class="derivation displaymath">
      <tr><td>1.</td><td class="">
	  <span class="pred_name">Compose</span>(<span class="st">L</span>, <span class="var">v</span>, ∅, <span class="st">S</span>)
	</td><td>given</td></tr>

      <tr><td>2.</td><td class="">
	  <e:fst>
	      <e:fst><span class="var">v</span></e:fst> ∈ <e:snd><span class="st">S</span></e:snd>
	    </e:fst> ∧ <e:snd>∀x∈L. x &lt; v ∧ L = S - {v}</e:snd>
	</td><td/></tr>
    </table>

  </p>

  <p>
    Using our <span class="pred_name">Compose</span> predicate,
    we can describe the top of some tree at <code>n</code>
    that stores the value <span class="var">v</span> at the root and represents the set <span class="var">S</span>.
    (Notice this uses the <span class="pred_name">Tree</span> predicate,
    to be introduced shortly,
    and which describes a tree with any number of nodes):

    <table class="displaymath">
      <tbody>
	<tr>
	  <td><span class="pred_name">TopOfTree</span>(<code>n</code>, <span class="var">v</span>, <span class="st">S</span>) ≝</td>
	  <td>∃<span class="var">l</span>,<span class="var">r</span>,<span class="st">L</span>,<span class="st">R</span>.</td>
	  <td><code>n</code> represents the set <span class="st">S</span> with <span class="var">v</span> at the root if</td>
	</tr>
	<tr>
	  <td/>
	  <td>
	    <e:fst><code>n</code></e:fst> ↦ <e:snd><span class="var">v</span>,<span class="var">l</span>,<span class="var">r</span></e:snd>
	  </td>
	  <td><code>n</code> points to a node with value <span class="var">v</span> and pointers <span class="var">l</span> and <span class="var">r</span></td>
	</tr>
	<tr>
	  <td/>
	  <td>∗ <span class="pred_name">Tree</span>(<span class="var">l</span>, <span class="st">L</span>)</td>
	  <td>where <span class="var">l</span> points to a tree representing the set <span class="st">L</span>, and</td>
	</tr>
	<tr>
	  <td/>
	  <td>∗ <span class="pred_name">Tree</span>(<span class="var">r</span>, <span class="st">R</span>)</td>
	  <td><span class="var">r</span> points to a tree representing <span class="st">R</span>, and</td>
	</tr>
	<tr>
	  <td/>
	  <td>∧ <span class="pred_name">Compose</span>(<span class="st">L</span>, <span class="var">v</span>, <span class="st">R</span>, <span class="st">S</span>).</td>
	  <td>the values in the <span class="st">S</span> are totally ordered.</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    Often, though, we don't know the value at the top of the tree—we just know it's non-empty:

    <table class="displaymath">
      <tbody>
	<tr>
	  <td><span class="pred_name">NonEmptyTree</span>(<code>n</code>, <span class="st">S</span>) ≝</td>
	  <td>∃<span class="var">v</span>. <span class="pred_name">TopOfTree</span>(<code>n</code>, <span class="var">v</span>, <span class="st">S</span>).</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    The <span class="pred_name">Tree</span> predicate describes
    a tree that has any number of nodes.
    That is, it's an <span class="pred_name">EmptyTree</span> or a <span class="pred_name">NonEmptyTree</span>:

    <table class="displaymath">
      <tbody>
	<tr>
	  <td>
	    <span class="pred_name">Tree</span>(<code>n</code>, <span class="st">S</span>) ≝
	  </td>
	  <td>
	    <span class="pred_name">EmptyTree</span>(<code>n</code>, <span class="st">S</span>) ∨
	  </td>
	</tr>
	<tr>
	  <td/>
	  <td><span class="pred_name">NonEmptyTree</span>(<code>n</code>, <span class="st">S</span>).</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    Given a <span class="pred_name">Tree</span> pointer,
    we can find out whether it is an <span class="pred_name">EmptyTree</span> or an <span class="pred_name">NonEmptyTree</span>
    by testing whether the pointer is <code>null</code>.
    That is,
    <e:fst>
	<e:fst><span class="pred_name">Tree</span>(<code>n</code>, <span class="st">S</span>)</e:fst> ∧ <e:snd><e:fst><code>n</code></e:fst> = <e:snd><code>null</code></e:snd></e:snd>
      </e:fst> → <e:snd><span class="pred_name">EmptyTree</span>(<code>n</code>, <span class="st">S</span>)</e:snd>, and
    <e:fst>
	<e:fst><span class="pred_name">Tree</span>(<code>n</code>, <span class="st">S</span>)</e:fst> ∧ <e:snd><e:fst><code>n</code></e:fst> ≠ <e:snd><code>null</code></e:snd></e:snd>
      </e:fst> → <e:snd><span class="pred_name">NonEmptyTree</span>(<code>n</code>, <span class="st">S</span>)</e:snd>.
    This follows from <code>null</code> not being in the domain of the heap; <i>i.e.</i>,
    <e:fst><e:fst><code>n</code></e:fst> ↦ <e:snd>…</e:snd></e:fst> → <e:snd><e:fst><code>n</code></e:fst> ≠ <e:snd><code>null</code></e:snd></e:snd>.
  </p>
</section>
  <section>
  
  <h3>Recursive <abbr title="Binary Search Tree" class="smallcaps">BST</abbr> algorithms</h3>

  <section>
    <h4><code>descend</code>: an algorithm to move down the tree</h4>

    The first algorithm I describe is an auxiliary one that selects a subtree pointer
    depending on a value we are searching for.

    <section xml:base="../../code/d/html/bst/descend.d.html"><pre class="prettyprint">module bst.descend;

import bst.node;


Node* descend(Node* root, in int value) { </pre>
<div class="section"><pre class="indent">  </pre><div class="AssertionParagraph"><div class="expl">Function precondition.
The tree is non-empty and value is not at the root
(so if it's in the set, it's in one of the two subtrees).</div>TopOfTree(root, v, S) ∧ v≠value</div></div>
<pre class="prettyprint">
  int dir = value &gt; root.value;
 </pre>
<div class="section"><pre class="indent">  </pre><div class="AssertionParagraph"><div class="expl">Either &gt; or &lt;.  C semantics render this as an integer.
v≠value is now implied.</div>TopOfTree(root, v, S) ∧ <br/><span class="assertionIndent">   </span>(value &lt; v ∧ dir = 0) ∨<br/><span class="assertionIndent">   </span>(value &gt; v ∧ dir = 1)</div></div>
<pre class="prettyprint">
  Node* o = root.c[dir];
 </pre>
<div class="section"><pre class="indent">  </pre><div class="AssertionParagraph"><div class="expl">Open TopOfTree.  Do both cases of value of `dir`.</div>∃v,l,r,L,R.<br/><span class="assertionIndent">   </span>root↦v,l,r ∗ Tree(l, L) ∗ Tree(r, R)<br/><span class="assertionIndent">   </span>∧ Compose(L, v, R, S)<br/><span class="assertionIndent">   </span>∧ (value &lt; v ∧ o = l) ∨ (value &gt; v ∧ o = r)</div></div>

<div class="section"><pre class="indent">  </pre><div class="AssertionParagraph"><div class="expl">What is true of the subtree pointers is true of `o`.</div>∃v,l,r,L,R.<br/><span class="assertionIndent">   </span>root↦v,l,r ∗ Tree(l, L) ∗ Tree(r, R)<br/><span class="assertionIndent">   </span>∧ Compose(L, v, R, S)<br/><span class="assertionIndent">   </span>∧ (value &lt; v ∧ Tree(o, L)) ∨ (value &gt; v ∧ Tree(o, R))</div></div>

<div class="section"><pre class="indent">  </pre><div class="AssertionParagraph"><div class="expl">From Compose and relation of value and v.</div>∃v,l,r,L,R.<br/><span class="assertionIndent">   </span>root↦v,l,r ∗ Tree(l, L) ∗ Tree(r, R)<br/><span class="assertionIndent">   </span>∧ Compose(L, v, R, S)<br/><span class="assertionIndent">   </span>∧ (Tree(o, L) ∧ (value∈L ↔ value∈S)) ∨ (Tree(o, R) ∧ (value∈R ↔ value∈S))</div></div>

<div class="section"><pre class="indent">  </pre><div class="AssertionParagraph"><div class="expl">Introduce quantification.</div>∃v,l,r,L,R.<br/><span class="assertionIndent">   </span>root↦v,l,r ∗ Tree(l, L) ∗ Tree(r, R)<br/><span class="assertionIndent">   </span>∧ Compose(L, v, R, S)<br/><span class="assertionIndent">   </span>∧ (∃Q. Tree(o, Q) ∧ (value∈Q ↔ value∈S)) ∨ (∃Q. Tree(o, Q) ∧ (value∈Q ↔ value∈S))</div></div>

<div class="section"><pre class="indent">  </pre><div class="AssertionParagraph"><div class="expl">a ∨ a implies a.</div>∃v,l,r,L,R.<br/><span class="assertionIndent">   </span>root↦v,l,r ∗ Tree(l, L) ∗ Tree(r, R)<br/><span class="assertionIndent">   </span>∧ Compose(L, v, R, S)<br/><span class="assertionIndent">   </span>∧ ∃Q. Tree(o, Q) ∧ (value∈Q ↔ value∈S))</div></div>

<div class="section"><pre class="indent">  </pre><div class="AssertionParagraph"><div class="expl">Function postcondition.  Close TopOfTree.</div>TopOfTree(root, v, S)<br/><span class="assertionIndent"> </span>∧ ∃Q. Tree(o, Q) ∧ (value∈Q ↔ value∈S))</div></div>

<div class="section"><pre class="indent">  </pre><div class="CommentParagraph">Note: we want |Q| &lt; |S|
to show termination of other functions.</div></div>
<pre class="prettyprint">
  return o;
} </pre></section>
  </section>

  <section>
    <h4>Recursive <code>search</code></h4>

    <section xml:base="../../code/d/html/bst/search/recursive.d.html"><pre class="prettyprint">module bst.search.recursive;

import bst.node;
import bst.descend;


bool search(Node* root, in int value) { </pre>
<div class="section"><pre class="indent">  </pre><div class="AssertionParagraph"><div class="expl">Function precondition.</div>Tree(root, S)</div></div>
<pre class="prettyprint">  bool o;
  if (root) { </pre>
<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">Assert if-test.</div>Tree(root, S) ∧ root≠null</div></div>

<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">Non-null pointer is non-empty tree (lemma).</div>NonEmptyTree(root, S)</div></div>
<pre class="prettyprint">
    if (root.value == value) { </pre>
<div class="section"><pre class="indent">      </pre><div class="AssertionParagraph"><div class="expl">Assert if-test.  (Need lemma here.)</div>TopOfTree(root, value, S)</div></div>

<div class="section"><pre class="indent">      </pre><div class="AssertionParagraph"><div class="expl">Root value in set (lemma).</div>TopOfTree(root, value, S) ∧ value ∈ S</div></div>

<div class="section"><pre class="indent">      </pre><div class="AssertionParagraph"><div class="expl">Weaken TopOfTree.</div>Tree(root, S) ∧ value ∈ S</div></div>
<pre class="prettyprint">
      o = true;
 </pre>
<div class="section"><pre class="indent">      </pre><div class="AssertionParagraph"><div class="expl">Assignment.</div>Tree(root, S) ∧ value ∈ S ∧ o = true</div></div>

<div class="section"><pre class="indent">      </pre><div class="AssertionParagraph"><div class="expl">???</div>Tree(root, S) ∧ o ↔ (value ∈ S)</div></div>
<pre class="prettyprint">    }
    else { </pre>
<div class="section"><pre class="indent">      </pre><div class="AssertionParagraph"><div class="expl">Deny if-test.</div>TopOfTree(root, v, S) ∧ v ≠ value</div></div>
<pre class="prettyprint">
      Node* next = descend(root, value);
 </pre>
<div class="section"><pre class="indent">      </pre><div class="AssertionParagraph"><div class="expl">Specification of descend.</div>TopOfTree(root, v, S) ∧<br/><span class="assertionIndent"> </span>∃Q. Tree(o, Q) ∧ (value∈Q ↔ value∈S)) ∧ |Q| &lt; |S|</div></div>

<div class="section"><pre class="indent">      </pre><div class="CommentParagraph">Note recursion terminates because |Q| &lt; |S| and |Q| &gt;= 0</div></div>
<pre class="prettyprint">      o = search(next, value);
 </pre>
<div class="section"><pre class="indent">      </pre><div class="AssertionParagraph"><div class="expl">Specification of search.</div>TopOfTree(root, v, S) ∧<br/><span class="assertionIndent"> </span>∃Q. Tree(o, Q) ∧ (value∈Q ↔ value∈S)) ∧ |Q| &lt; |S| ∧ o ↔ (value ∈ Q)</div></div>

<div class="section"><pre class="indent">      </pre><div class="AssertionParagraph"><div class="expl">Transitivity of ↔; escape ∃; weaken TopOfTree.</div>Tree(root, S) ∧ o ↔ (value ∈ S)</div></div>
<pre class="prettyprint">    } </pre>
<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">Transitivity of both if-branches.</div>Tree(root, S) ∧ o ↔ (value ∈ S)</div></div>
<pre class="prettyprint">  }
  else { </pre>
<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">Deny if-test.</div>Tree(root, S) ∧ root=null</div></div>

<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">Null pointer is empty tree (lemma).</div>EmptyTree(root, S)</div></div>

<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">Empty tree is empty set (lemma).</div>EmptyTree(root, S) ∧ S = ∅</div></div>

<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">Element not in empty set.</div>EmptyTree(root, S) ∧ value ∉ S</div></div>
<pre class="prettyprint">
    o = false;
 </pre>
<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">Assignment.</div>EmptyTree(root, S) ∧ value ∉ S ∧ o = false</div></div>

<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">???</div>EmptyTree(root, S) ∧ o ↔ (value ∈ S)</div></div>

<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">Weaken EmptyTree.</div>Tree(root, S) ∧ o ↔ (value ∈ S)</div></div>
<pre class="prettyprint">  } </pre>
<div class="section"><pre class="indent">  </pre><div class="AssertionParagraph"><div class="expl">Function postcondition.
Postcondition of both if-branches.</div>Tree(root, S) ∧ o ↔ (value ∈ S)</div></div>
<pre class="prettyprint">  return o;
} </pre></section>
  </section>

  <section>
    <h4>Recursive <code>insert</code></h4>

    <section xml:base="../../code/d/html/bst/insert/recursive.d.html"><pre class="prettyprint">module bst.insert.recursive;

import bst.node;

Node* insert(Node* root, int value) {
  Node* o;
  if (!root) {
    o = new Node(value);
  }
  else {
    if (root.value == value) {
      o = root;
    }
    else {
      if (value &lt; root.value) {
	root.c[0] = insert(root.c[0], value);
      }
      else {
	root.c[1] = insert(root.c[1], value);
      }
      o = root;
    }
  }
  return o;
} </pre></section>
  </section>

  <section>
    <h4>Recursive <code>remove</code></h4>

    <p>
      Here's <code>removeMax</code>:

      <section xml:base="../../code/d/html/bst/remove/removeMax/recursive.d.html"><pre class="prettyprint">module bst.remove.removeMax.recursive;


import bst.node;
import bst.remove.removeMax.RemoveMaxRet;

import std.stdio;

RemoveMaxRet removeMax(Node* root) { </pre>
<div class="section"><pre class="indent">  </pre><div class="AssertionParagraph"><div class="expl">We can only remove the maximum from a non-empty tree!</div>NonEmptyTree(root, S)</div></div>
<pre class="prettyprint">
  assert(root != null);
 </pre>
<div class="section"><pre class="indent">  </pre><div class="AssertionParagraph"><div class="expl">Expand NonEmptyTree(root).</div>∃v. TopOfTree(root, v, S).</div></div>

<div class="section"><pre class="indent">  </pre><div class="AssertionParagraph"><div class="expl">Expand TopOfTree(root, v, S).</div>∃v,l,r,L,R.<br/><span class="assertionIndent">   </span>root↦v,l,r<br/><span class="assertionIndent">   </span>∗ Tree(l, L)<br/><span class="assertionIndent">   </span>∗ Tree(r, R)<br/><span class="assertionIndent">   </span>∧ Compose(L, v, R, S).</div></div>
<pre class="prettyprint">
  auto r = root.c[1];
 </pre>
<div class="section"><pre class="indent">  </pre><div class="AssertionParagraph"><div class="expl">Take `r` out of quantification.</div>∃v,l,L,R.<br/><span class="assertionIndent">   </span>root↦v,l,r<br/><span class="assertionIndent">   </span>∗ Tree(l, L)<br/><span class="assertionIndent">   </span>∗ Tree(r, R)<br/><span class="assertionIndent">   </span>∧ Compose(L, v, R, S).</div></div>
<pre class="prettyprint">

 </pre>
<div class="section"><pre class="indent">  </pre><div class="CommentParagraph">We're going to put the return values here.</div></div>
<pre class="prettyprint">  int max;
  Node* newRoot;

  if (!r) { </pre>
<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">Assert if-condition.  Discard EmptyTree.</div>∃v,l,L.<br/><span class="assertionIndent">   </span>root↦v,l,null<br/><span class="assertionIndent">   </span>∗ Tree(l, L)<br/><span class="assertionIndent">   </span>∧ Compose(L, v, ∅, S).</div></div>

<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">Found-max (lemma on Compose).  Discard Compose.</div>∃v,l,L.<br/><span class="assertionIndent">   </span>root↦v,l,null<br/><span class="assertionIndent">   </span>∗ Tree(l, L)<br/><span class="assertionIndent">   </span>∧ v∈S ∧ ∀x∈L. x &lt; v ∧ L = S - {v}.</div></div>
<pre class="prettyprint">
    max = root.value;
    newRoot = root.c[0];
 </pre>
<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">Assignment (twice).</div>∃L.<br/><span class="assertionIndent">   </span>root↦max,newRoot,null<br/><span class="assertionIndent">   </span>∗ Tree(newRoot, L)<br/><span class="assertionIndent">   </span>∧ max∈S ∧ ∀x∈L. x &lt; max ∧ L = S - {max}.</div></div>
<pre class="prettyprint">
    delete root;
 </pre>
<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">`root` is dangling.  Rename bound variable.
This gives our function postcondition.</div>∃T.<br/><span class="assertionIndent">   </span>Tree(newRoot, T)<br/><span class="assertionIndent">   </span>∧ max∈S ∧ ∀x∈T. x &lt; max ∧ T = S - {max}.</div></div>
<pre class="prettyprint">  }
  else { </pre>
<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">Negate if-condition.</div>∃v,l,L,R.<br/><span class="assertionIndent">   </span>root↦v,l,r<br/><span class="assertionIndent">   </span>∗ Tree(l, L)<br/><span class="assertionIndent">   </span>∗ Tree(r, R)<br/><span class="assertionIndent">   </span>∧ Compose(L, v, R, S)<br/><span class="assertionIndent">   </span>∧ r.</div></div>

<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">Non-null pointer is non-empty tree (lemma).</div>∃v,l,L,R.<br/><span class="assertionIndent">   </span>root↦v,l,r<br/><span class="assertionIndent">   </span>∗ Tree(l, L)<br/><span class="assertionIndent">   </span>∗ NonEmptyTree(r, R)<br/><span class="assertionIndent">   </span>∧ Compose(L, v, R, S).</div></div>
<pre class="prettyprint">
    auto d = removeMax(r);
    auto rightMax = d.max;
    auto rightRoot = d.root;
 </pre>
<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">removeMax consumes NonEmptyTree(r, R).  `r` is now dangling.</div>∃v,l,L,R,N.<br/><span class="assertionIndent">   </span>root↦v,l,r<br/><span class="assertionIndent">   </span>∗ Tree(l, L)<br/><span class="assertionIndent">   </span>∗ Tree(rightRoot, N)<br/><span class="assertionIndent">   </span>∧ Compose(L, v, R, S)<br/><span class="assertionIndent">   </span>∧ rightMax∈R ∧ ∀x∈N. x &lt; rightMax ∧ N = R - {rightMax}.</div></div>
<pre class="prettyprint">
    root.c[1] = rightRoot;
 </pre>
<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">Assignment.</div>∃v,l,L,R,N.<br/><span class="assertionIndent">   </span>root↦v,l,rightRoot<br/><span class="assertionIndent">   </span>∗ Tree(l, L)<br/><span class="assertionIndent">   </span>∗ Tree(rightRoot, N)<br/><span class="assertionIndent">   </span>∧ Compose(L, v, R, S)<br/><span class="assertionIndent">   </span>∧ rightMax∈R ∧ ∀x∈N. x &lt; rightMax ∧ N = R - {rightMax}.</div></div>

<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">Close TopOfTree.</div>∃v.<br/><span class="assertionIndent">   </span>TopOfTree(root, v, S - {rightMax})<br/><span class="assertionIndent">   </span>∧ rightMax∈S ∧ ∀x∈(S-{rightMax}). x &lt; rightMax.</div></div>

<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">Introduce quantification on S - {rightMax}.</div>∃v, T.<br/><span class="assertionIndent">   </span>TopOfTree(root, v, T)<br/><span class="assertionIndent">   </span>∧ rightMax∈S ∧ ∀x∈T. x &lt; rightMax ∧ T = S - {rightMax}.</div></div>

<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">Close NonEmptyTree.</div>∃T.<br/><span class="assertionIndent">   </span>NonEmptyTree(root, T)<br/><span class="assertionIndent">   </span>∧ rightMax∈S ∧ ∀x∈T. x &lt; rightMax ∧ T = S - {rightMax}.    </div></div>
<pre class="prettyprint">
    max = rightMax;
    newRoot = root;
 </pre>
<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">Assignment.  Gives postcondition.</div>∃T.<br/><span class="assertionIndent">   </span>Tree(newRoot, T)<br/><span class="assertionIndent">   </span>∧ max∈S ∧ ∀x∈T. x &lt; max ∧ T = S - {max}.</div></div>
<pre class="prettyprint">  }
 </pre>
<div class="section"><pre class="indent">  </pre><div class="AssertionParagraph"><div class="expl">Postcondition of both if branches.  
Function postcondition.
`max` is the maximum element in `S`,
and `newRoot` represents `S` with `max` subtracted.</div>∃T.<br/><span class="assertionIndent">   </span>Tree(newRoot, T)<br/><span class="assertionIndent">   </span>∧ max∈S ∧ ∀x∈T. x &lt; max ∧ T = S - {max}.</div></div>
<pre class="prettyprint">

  RemoveMaxRet o = {max: max, root: newRoot};
  return o;
} </pre></section>
    </p>

    <p>
      Here's <code>removeRoot</code>:

      <section xml:base="../../code/d/html/bst/remove/removeRoot.d.html"><pre class="prettyprint">module bst.removeRoot;

import bst.node;
import bst.remove.removeMax.removeMax;
import bst.remove.removeMax.RemoveMaxRet;


Node* removeRoot(Node* root) {
  assert(root != null);

  if (root.c[0] &amp;&amp; root.c[1]) {
    RemoveMaxRet r = removeMax(root.c[0]);
    root.value = r.max;
    root.c[0] = r.root;
  }
  else {
    assert(!root.c[0] || !root.c[1]);
    Node* rem = root;
    if (root.c[0]) {
      root = root.c[0];
    }
    else {
      root = root.c[1];
    } </pre>
<div class="section"><pre class="indent">    </pre><div class="CommentParagraph">delete rem;</div></div>
<pre class="prettyprint">  }
  return root;
}


unittest {
  auto a = new Node(5);
  a = removeRoot(a);
  assert(a == null);
}


unittest {
  auto a = new Node(5);
  a.c[0] = new Node(4);
  a = removeRoot(a);
  assert(a);
  assert(a.value == 4);
  assert(!a.c[0]);
  assert(!a.c[1]);
}


unittest {
  auto a = new Node(5);
  a.c[0] = new Node(4);
  a.c[1] = new Node(6);
  a = removeRoot(a);

  assert(a);
  assert(a.value == 4);
  assert(a.c[0] == null);
  assert(a.c[1]);
  assert(a.c[1].value == 6);
  assert(!a.c[1].c[0]);
  assert(!a.c[1].c[1]);
} </pre></section>
    </p>

    <p>
      Here's <code>remove</code>:

      <section xml:base="../../code/d/html/bst/remove/recursive.d.html"><pre class="prettyprint">module bst.remove.recursive;

import bst.node;
import bst.remove.removeRoot;


Node* remove(Node* root, int value) {
  Node* o;

  if (!root) {
    o = null;
  }
  else {
    if (value == root.value) {
      o = removeRoot(root);
    }
    else {
      o = root;
      int dir = value &gt; root.value;
      o.c[dir] = remove(o.c[dir], value);
    }
  }

  return o;
} </pre></section>
    </p>
  </section>
</section>
  <section>
  
  <h3>Iterative <abbr title="Binary Search Tree" class="smallcaps">BST</abbr> algorithms</h3>


  <section>
    <h4>Iterative <code>search</code></h4>

    <section xml:base="../../code/d/html/bst/search/iterative.d.html"><pre class="prettyprint">module bst.search.iterative;

import bst.node;
import bst.descend;


bool search(Node* root, in int value) { </pre>
<div class="section"><pre class="indent">  </pre><div class="AssertionParagraph"><div class="expl">Function precondition.</div>Tree(root, S)</div></div>
<pre class="prettyprint">
  bool found = false;
 </pre>
<div class="section"><pre class="indent">  </pre><div class="AssertionParagraph"><div class="expl">Assignment.
We're going to return `found`.
That is, the following loop establishes `found ↔ (value ∈ S)`.</div>Tree(root, S) ∧ ¬found</div></div>
<pre class="prettyprint">
  Node* i = root;
 </pre>
<div class="section"><pre class="indent">  </pre><div class="AssertionParagraph"><div class="expl">Assignment.</div>Tree(root, S) ∧ ¬found ∧<br/><span class="assertionIndent"> </span>Tree(i, S)</div></div>

<div class="section"><pre class="indent">  </pre><div class="AssertionParagraph"><div class="expl">a ↔ a</div>Tree(root, S) ∧ ¬found ∧<br/><span class="assertionIndent"> </span>Tree(i, S) ∧ (value ∈ S) ↔ (value ∈ S)</div></div>

<div class="section"><pre class="indent">  </pre><div class="AssertionParagraph"><div class="expl">∃I</div>Tree(root, S) ∧ ¬found ∧<br/><span class="assertionIndent"> </span>∃Q. Tree(i, Q) ∧ (value ∈ Q) ↔ (value ∈ S)</div></div>

<div class="section"><pre class="indent">  </pre><div class="AssertionParagraph"><div class="expl">false → anything (rule?).
This is our loop invariant.</div>Tree(root, S) ∧<br/><span class="assertionIndent"> </span>∃Q. Tree(i, Q) ∧ (value ∈ Q) ↔ (value ∈ S)<br/><span class="assertionIndent"> </span>∧ found → (value ∈ S)</div></div>

<div class="section"><pre class="indent">  </pre><div class="CommentParagraph">The size of Q strictly decreases with each iteration,
and the size of Q &gt;= 0, as the empty set is the smallest possible set.
This shows that the loop terminates.</div></div>
<pre class="prettyprint">
  while (i &amp;&amp; !found) { </pre>
<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">Loop invariant, and assert while-condition.</div>Tree(root, S) ∧<br/><span class="assertionIndent"> </span>∃Q. Tree(i, Q) ∧ (value ∈ Q) ↔ (value ∈ S)<br/><span class="assertionIndent"> </span>∧ found → (value ∈ S)<br/><span class="assertionIndent"> </span>∧ root ∧ ¬found</div></div>

<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">Non-null pointer is non-empty tree (lemma)</div>Tree(root, S) ∧<br/><span class="assertionIndent"> </span>∃Q. NonEmptyTree(i, Q) ∧ (value ∈ Q) ↔ (value ∈ S)<br/><span class="assertionIndent"> </span>∧ found → (value ∈ S)<br/><span class="assertionIndent"> </span>∧ ¬found</div></div>

<div class="section"><pre class="indent">    </pre><div class="AssertionParagraph"><div class="expl">Open NonEmptyTree</div>Tree(root, S) ∧<br/><span class="assertionIndent"> </span>∃Q, v. TopOfTree(i, v, Q) ∧ (value ∈ Q) ↔ (value ∈ S)<br/><span class="assertionIndent"> </span>∧ found → (value ∈ S)<br/><span class="assertionIndent"> </span>∧ ¬found</div></div>
<pre class="prettyprint">
    if (value == i.value) { </pre>
<div class="section"><pre class="indent">      </pre><div class="AssertionParagraph"><div class="expl">Assert if-condition.  Equality.</div>Tree(root, S) ∧<br/><span class="assertionIndent"> </span>∃Q. TopOfTree(i, value, Q) ∧ (value ∈ Q) ↔ (value ∈ S)<br/><span class="assertionIndent"> </span>∧ found → (value ∈ S)<br/><span class="assertionIndent"> </span>∧ ¬found</div></div>

<div class="section"><pre class="indent">      </pre><div class="AssertionParagraph"><div class="expl">Root value in set (lemma).</div>Tree(root, S) ∧<br/><span class="assertionIndent"> </span>∃Q.<br/><span class="assertionIndent">   </span>TopOfTree(i, value, Q) ∧<br/><span class="assertionIndent">   </span>(value ∈ Q) ↔ (value ∈ S) ∧<br/><span class="assertionIndent">   </span>value ∈ Q<br/><span class="assertionIndent"> </span>∧ found → (value ∈ S)<br/><span class="assertionIndent"> </span>∧ ¬found</div></div>

<div class="section"><pre class="indent">      </pre><div class="AssertionParagraph"><div class="expl">→.  Weaken TopOfTree.</div>Tree(root, S) ∧<br/><span class="assertionIndent"> </span>∃Q. Tree(i, Q) ∧ (value ∈ Q) ↔ (value ∈ S)<br/><span class="assertionIndent"> </span>value ∈ S ∧ ¬found</div></div>
<pre class="prettyprint">
      found = true;
 </pre>
<div class="section"><pre class="indent">      </pre><div class="AssertionParagraph"><div class="expl">Assignment.</div>Tree(root, S) ∧<br/><span class="assertionIndent"> </span>∃Q. Tree(i, Q) ∧ (value ∈ Q) ↔ (value ∈ S)<br/><span class="assertionIndent"> </span>value ∈ S ∧ found</div></div>

<div class="section"><pre class="indent">      </pre><div class="AssertionParagraph"><div class="expl">→.  Re-establish invariant.</div>Tree(root, S) ∧<br/><span class="assertionIndent"> </span>∃Q. Tree(i, Q) ∧ (value ∈ Q) ↔ (value ∈ S)<br/><span class="assertionIndent"> </span>∧ found → (value ∈ S)</div></div>
<pre class="prettyprint">    }
    else { </pre>
<div class="section"><pre class="indent">      </pre><div class="AssertionParagraph"><div class="expl">Assert else-condition.  Equality.</div>Tree(root, S) ∧<br/><span class="assertionIndent"> </span>∃Q, v. TopOfTree(i, v, Q) ∧ (value ∈ Q) ↔ (value ∈ S) ∧ v ≠ value<br/><span class="assertionIndent"> </span>∧ found → (value ∈ S)<br/><span class="assertionIndent"> </span>∧ ¬found</div></div>
<pre class="prettyprint">
      Node* next = descend(i, value);
 </pre>
<div class="section"><pre class="indent">      </pre><div class="AssertionParagraph"><div class="expl">Assert else-condition.  Equality.</div>Tree(root, S) ∧<br/><span class="assertionIndent"> </span>∃Q, v. TopOfTree(i, v, Q) ∧ (value ∈ Q) ↔ (value ∈ S) ∧ v ≠ value<br/><span class="assertionIndent"> </span>∧ found → (value ∈ S)<br/><span class="assertionIndent"> </span>∧ ¬found</div></div>
<pre class="prettyprint">
      i = next;
    }
  }
  return found;
}
 </pre></section>
  </section>

  <section>
    <h4>Iterative <code>insert</code></h4>

    <section xml:base="../../code/d/html/bst/insert/iterative.d.html"><pre class="prettyprint">module bst.insert.iterative;

import bst.node;


const bool insert_parent_pointer = true;


static if (insert_parent_pointer) {

  Node* insert(Node * root, int value) {

    Node*  p = null,
      i = root;
    int dir;

    while (i) {
      if (value == i.value) return root;
      else {
	p = i;
	dir = value &gt; i.value;
	i = i.c[dir];
      }
    }
    assert(!i);

    auto n = new Node(value);

    if (p) {
      p.c[dir] = n;
      return root;
    }
    else {
      return n;
    }
  }

} else {  // !insert_parent_pointer

  Node* insert(Node * root, int value) {

    if(!root) {
      root = new Node(value);
    }
    else {
      Node* i = root;
      while (i) {
	if (value == i.value) {
	  return root;
	}
	else {
	  int dir = value &gt; i.value;
	  if (i.c[dir]) i = i.c[dir];
	  else {
	    i.c[dir] = new Node(value);
	    return root;
	  }
	}
      }
    }
    return root;
  }

} </pre></section>
  </section>

  <section>
    <h4>Iterative <code>remove</code></h4>

    <p>
      Here's <code>removeMax</code>:

      <!--<xi:include href="../../code/d/html/bst/remove/removeMax/iterative.d.html" />-->
    </p>

    <p>
      The <code>removeRoot</code> code is the same as in the recursive section.
    </p>

    <p>
      Here's <code>remove</code>:

      <section xml:base="../../code/d/html/bst/remove/iterative.d.html"><pre class="prettyprint">module bst.remove.iterative;

import bst.node;
import bst.remove.removeRoot;


Node * remove(Node * root, int value) {
  Node * o;
  if (!root) {
    o = null;
  }
  else if (value == root.value) {
    o = removeRoot(root);
  }
  else {
    o = root;

    Node* p = o;
    int dir = value &gt; p.value;
    Node* i = p.c[dir];
 </pre>
<div class="section"><pre class="indent">    </pre><div class="CommentParagraph">iterate until i is the node to delete
then set link in p to removeRoot(i).</div></div>
<pre class="prettyprint">    while (i &amp;&amp; i.value != value) {
      p = i;
      dir = value &gt; p.value;
      i = i.c[dir];
    }
    assert(!i || i.value == value);
    assert(dir == (value &gt; p.value));

    if (i) {
      p.c[dir] = removeRoot(i);
    }
  }

  return o;
} </pre></section>
    </p>
  </section>
</section>
</section>
      <section xml:base="rbt/rbt.html">
  
  <h2>Verifying the <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr></h2>

  <p>
    The <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr> inherits ideas from the AVL tree and the B-tree.
    It has the same goals and performance guarantees as the AVL tree,
    and uses the same tree mutation to achieve them: rotations.
    However, it can also be seen as 
    a mapping of a B-tree of degree <span class="var">t</span> = 2 onto a <abbr title="Binary Search Tree" class="smallcaps">BST</abbr>.
    <span class="note">
      <i>i.e.</i>,
      a B-tree where the number of elements <span class="var">e</span> is 1 ≤ <span class="var">e</span> ≤ 3
      (and therefore the number of links <span class="var">l</span> is 2 ≤ <span class="var">l</span> ≤ 4).
    </span>
    This has the advantage over the B-tree that
    adjusting a node does not require copying,
    and less-than-full nodes do not hold unused allocated memory.
  </p>

  <p>
    In such a B-tree,
    a 3-node<span class="note">I use the term $n$-node to describe a node that can contain up to <span class="var">n</span> elements.</span>
    is structured as three element-sized spaces adjacent in memory.
    The <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr> instead uses between one and three 1-nodes.
    The first 1-node, which I shall call the <em>representative-node</em>,
    is representative of the analogous B-tree 3-node.
    It is the target of links from parents.
    It is accompanied by zero, one or two more 1-nodes, which I shall call <em>side-nodes</em>,
    and which contain the other elements in the 3-node.
  </p>

  <p>
    The defining feature of the <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr> is
    the restriction that it places on the colors and black-heights of nodes.
    Before we even look at the tree structure,
    we can actually encode these restrictions on four variables:
    the color and black-height of a node,
    and the color and black-height of its parent.
    Let’s start by defining a predicate on these
    (as well as making the description more intelligible,
    this also makes the full description shorter,
    and makes proofs shorter where they are unconcerned with the <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr> conditions).
  </p>

  <p>
    This says that:

    <ul>
      <li>the color is either <span class="constant">red</span> or <span class="constant">black</span></li>
      <li>if the node is <span class="constant">red</span>, its parent has the same black-height</li>
      <li>if the node is <span class="constant">black</span>, its parent has a greater black-height by 1</li>
      <li>if the node is <span class="constant">red</span>, its parent is <span class="constant">black</span></li>
      <li>a negative black-height is disallowed</li>
    </ul>
  </p>

  <p>
    We now want to define the <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr> recursively.
    We can then describe a node pointer.
  </p>

  <p>
    The representative-node's <code>left</code> and <code>right</code> pointers have two roles.
    Where side-nodes exist,
    the pointers point to these.
    (Note this implies that, if the analogous 3-node is full,
    the representative-node will hold the middle element.)
    Where a side-node is absent,
    the corresponding pointer instead points directly to the appropriate child representative-node.
    <span class="note">
      Herein lies the space-saving and copy-reducing aspects of the <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr>,
      analogous to the benefits of the <abbr title="Binary Search Tree" class="smallcaps">BST</abbr> over an array.
    </span>
    A side-node's pointers must point to a child representative-node.
    (All pointers may instead be to <code>null</code> nodes, at which the tree terminates.)
  </p>

  <p>
    How are we to know whether a pointer leads us to a side-node or a child representative-node?
    The approach of Guibas and Sedgewick was to give the pointer a <em>color</em>:
    pointers to representative-nodes are black,
    and pointers to side-nodes are red.
    In the literature, this has been transformed into the equivalent rule that
    representative-nodes are colored black,
    and side-nodes are colored red.
    This has been shortened to simply <q>red nodes</q> and <q>black nodes</q>.
  </p>

  <p>
    We can now state the properties of the <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr>,
    and relate them to the B-tree:
  </p>

  <ol>
    <li>
      <strong>A node is either red or black.</strong>
      (A 1-node is either a representative-node or a side-node.)
    </li>
    <li>
      <strong>The root is black,</strong>
      as it is representative of the root 3-node.
    </li>
    <li>
      <strong>Leaf nodes are black.</strong>
      This includes <code>null</code> nodes
      (which in practise can be represented by a single sentinel nil node).
    </li>
    <li>
      <strong>Red nodes cannot have red children (the <q>red rule</q>).</strong>
      This is because they must point to child representative-nodes
      (pointing to another side-node would
      extend the number of elements in a node to more than three).
    </li>
    <li>
      <strong>For any node, all simple paths to a descendant leaf have the same number of black nodes (the <q>black rule</q>).</strong>
      This number is the node's <em>black-height</em>.
      This is equivalent to the B-tree rule that all leaves have the same depth.
    </li>
  </ol>

  <p>
    From the B-tree analogy,
    it should already be evident that the <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr> enforces balance.
    However, we can also see this from the last two <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr> properties.
    Precisely, we can show that,
    for any node, the longest path to a descendant leaf
    is no more than double the length of the shortest path to a descendant leaf.
    If the node has black-height <span class="var">h</span>,
    then both the shortest and longest path consist of <span class="var">h</span> black nodes (by property 5), interspersed with red nodes.
    The shortest path will contain no red nodes
    (because excising one maintains the \RBt properties and makes the path shorter),
    and therefore has length <span class="var">h</span>.
    The longest path will contain one red node between each pair of black nodes
    (because introducing another violates property 4),
    and therefore has length 2<span class="var">h</span>−1.
  </p>

  <p>
    <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr> operations feel like B-tree operations.
    When inserting a new node, we color it red,
    and insert it as we would in a <abbr title="Binary Search Tree" class="smallcaps">BST</abbr>.
    Then, if its parent is black, we're done
    (analogous to there being space in a leaf 3-node).
    Otherwise, the parent is red, and we have violated the red rule.
    We know the grandparent is black.
    We check the color of the uncle.
    If the uncle is red, we do a color swap on the parent, grandparent, and uncle,
    and move up the tree to look for a possible red violation.
    This is analogous to a 3-node being full, splitting it, and moving the median up.
    However, if the uncle is black,
    we do a single rotation on the grandparent and some recoloring, and stop.
    This is analogous to there being free space <q>on the other side</q> of the 3-node.
  </p>

  <section>
    <h4>Simplifications of the <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr></h4>

    <p>
      The standard <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr> is sometimes seen as overly complex.
      More precisely,
      the number of violating cases that the algorithms have to rectify
      is seen as too large.
      In response, there are simplifications of the standard <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr>.
      One is the AA-tree,
      which has the additional requirement that
      red nodes must be right children.
      In the B-tree analogy, they are 2-3 trees.
      This reduces seven cases to two.
    </p>

    <p>
      Another is the Left-Leaning Red-Black tree,
      introduced by Sedgewick.
      In a similar spirit,
      it reduces the number of cases,
      enforcing that
      no node may have a black left child and a red right child.
      This means that, in the B-tree analogy,
      a 3-node only has a single representation in the <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr>.
      Unlike the AA-tree, this is still analogous to a 2-3-4 tree.
      The main advantage is code simplicity:
      <code>insert</code> takes 33 lines <i>vs.</i> 150 lines.
    </p>

    <p>
      I find these simplifications unsatisfying.
      The gain in code simplicity results in a loss of conceptual clarity.
      More importantly, the <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr> algorithms can be drastically shortened
      by tackling the symmetric cases using the same code,
      while remaining semantically equivalent.
      A simple technique
      uses a two-element array of child pointers
      instead of a <code>left</code> and a <code>right</code> pointer.
      <span class="note">Julienne Walker, jsw</span>
    </p>

    <p>
      This allows the direction (left or right) to be parameterized,
      encoded as either a <span class="constant">0</span> or <span class="constant">1</span>.
      The direction can thus be reversed with with the C <code>!</code> operator.
    </p>
  </section>

  <p>
    As before, I verify recursive algorithms for <code>search</code>, <code>insert</code>, and <code>remove</code>.
    Finally, I will verify iterative algorithms for the same procedures.
  </p>

<section>
  
  <h3>The <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr> data structure</h3>

  <p>
    We need to define some predicates to describe the state of the tree
    at various points in the procedures—types of valid and <q>invalid</q> trees and subtrees.
    We use the same <span class="pred_name">Compose</span> predicate as before.
  </p>

  <p>
    It is convenient to think of an <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr> as composed of <q>red-rooted</q> trees and <q>black-rooted</q> trees.
    I use separate predicates for each: <span class="pred_name">RT</span> and <span class="pred_name">BT</span>.
  </p>

  <p>
    A red-rooted tree is as follows:
    a red-rooted tree pointed to by `n` represents set S with a tree of black-height `bh` if

    <table class="displaymath">
      <tr>
	<td><span class="pred_name">RT</span>(<code>n</code>, <span class="st">S</span>, <span class="var">bh</span>) =</td>
	<td>
	  ∃ <span class="var">v</span>, <span class="var">c[0]</span>, <span class="var">c[1]</span>, <span class="st">L</span>, <span class="st">R</span>.
	</td>
	<td>there exist element <span class="var">v</span> and sets <span class="st">L</span> and <span class="st">R</span></td>
      </tr>
      <tr>
	<td/>
	<td><span class="pred_name">Compose</span>(<span class="st">L</span>, <span class="var">v</span>, <span class="st">R</span>, <span class="st">S</span>) ∧</td>
	<td>such that <span class="st">L</span>, <span class="var">v</span> and <span class="st">R</span> make up <span class="st">S</span>, and</td>
      </tr>
      <tr>
	<td/>
	<td>
	  <e:fst><code>n</code></e:fst> ↦ <e:snd><span class="var">v</span>, <span class="var">c[0]</span>, <span class="var">c[1]</span>, <span class="constant">false</span></e:snd> ∗
	</td>
	<td><code>n</code> points to a red node containing <span class="var">v</span> and child pointers</td>
      </tr>
      <tr>
	<td/>
	<td>
	  <span class="pred_name">BT</span>(<span class="var">c[0]</span>, <span class="st">L</span>, <span class="var">bh</span>) ∗
	</td>
	<td>to black trees representing <span class="st">L</span></td>
      </tr>
      <tr>
	<td/>
	<td>
	  <span class="pred_name">BT</span>(<span class="var">c[1]</span>, <span class="st">R</span>, <span class="var">bh</span>)
	</td>
	<td>and <span class="st">R</span>, with the same black height.</td>
      </tr>
    </table>
  </p>

  <p>
    There's only one kind of RT, as the rules demand both children are black.
    However, there are multiple types of BT, analogous to the multiple node types in a 2,3,4-tree.
    There are two-nodes, in which both children are also black.
    There are three-nodes, in which one child is black (a BT) and one is red (an RT).
    That is, the RBT rules have two representations of a three-node:
    where the left child is the RT (<q>left-leaning</q>),
    and where the right child is the RT (<q>right-leaning</q>).
    Finally, there are four-nodes, where both children are RTs.
  </p>

  <p>
    First, two-nodes (2T).
    Two distinct types of two-node exist: empty and non-empty.
    The empty node is easiest:

    <table class="displaymath">
      <tbody>
	<tr>
	  <td><span class="pred_name">ET</span>(<code>n</code>, <span class="st">S</span>, <span class="var">bh</span>) =</td>
	  <td><e:fst><code>n</code></e:fst> = <e:snd><code>null</code></e:snd> ∧</td>
	  <td><span class="var">n</span> is <code>null</code>,</td>
	</tr>
	<tr>
	  <td/>
	  <td><e:fst><span class="st">S</span></e:fst> = <e:snd>∅</e:snd> ∧</td>
          <td>the tree represents the empty set,</td>
	</tr>
	<tr>
	  <td/>
	  <td><b>emp</b> ∧</td>
          <td>the heap is empty,</td>
	</tr>
	<tr>
	  <td/>
	  <td><e:fst><span class="var">bh</span></e:fst> = <e:snd><span class="constant">1</span></e:snd></td>
          <td>and we have a black-height of 1.</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    Next we capture the non-empty two-node,
    which represents set <span class="st">S</span> with black-height <span class="var">bh</span> if

    <table class="displaymath">
      <tbody>
	<tr>
	  <td><span class="pred_name">N2T</span>(<code>n</code>, <span class="st">S</span>, <span class="var">bh</span>) =</td>
	  <td>∃ <span class="var">v</span>, <span class="var">c[0]</span>, <span class="var">c[1]</span>, <span class="st">L</span>, <span class="st">R</span>.</td>
	  <td>there exist element <span class="var">v</span> and sets <span class="st">L</span> and <span class="st">R</span></td>
	</tr>
	<tr>
	  <td/>
	  <td><span class="pred_name">Compose</span>(<span class="st">L</span>, <span class="var">v</span>, <span class="st">R</span>, <span class="st">S</span>) ∧</td>
	  <td>such that <span class="st">L</span>, <span class="var">v</span> and <span class="st">R</span> make up <span class="st">S</span>, and</td>
	</tr>
	<tr>
	  <td/>
	  <td><e:fst><code>n</code></e:fst> ↦ <e:snd><span class="var">v</span>, <span class="var">c[0]</span>, <span class="var">c[1]</span>, <span class="constant">true</span></e:snd> ∗</td>
	  <td><code>n</code> points to a black node containing <span class="var">v</span> and pointers</td>
	</tr>
	<tr>
	  <td/>
	  <td><span class="pred_name">BT</span>(<span class="var">c[0]</span>, <span class="st">L</span>, <e:fst><span class="var">bh</span></e:fst> − <e:snd>1</e:snd>) ∗</td>
	  <td>to black trees representing <span class="st">L</span> and <span class="st">R</span>,</td>
	</tr>
	<tr>
	  <td/>
	  <td><span class="pred_name">BT</span>(<span class="var">c[1]</span>, <span class="st">R</span>, <e:fst><span class="var">bh</span></e:fst> − <e:snd>1</e:snd>)</td>
          <td>which have one less black height.</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    A general <span class="pred_name">2T</span> is either empty or non-empty:

    <div class="displaymath">
      <span class="pred_name">2T</span>(<code>n</code>, <span class="st">S</span>, <span class="var">bh</span>) =
      <e:fst><span class="pred_name">ET</span>(<code>n</code>, <span class="st">S</span>, <span class="var">bh</span>)</e:fst> ∨ <e:snd><span class="pred_name">N2T</span>(<code>n</code>, <span class="st">S</span>, <span class="var">bh</span>)</e:snd>
    </div>
  </p>

  <p>
    Next, three-nodes.
    We could create predicates <span class="pred_name">LeftLeaning3T</span> and <span class="pred_name">RightLeaning3T</span>,
    but then we lose the benefit of parameterizing the link direction.
    So we parameterize the predicate.
    Here's the left-leaning three-node:
    <span class="note">The right-leaning node is symmetrical, with link direction 1 and the children's colors swapped.</span>

    <table class="displaymath">
      <tbody>
	<tr>
	  <td><span class="pred_name">3T</span>(n, S, bh, 0) =</td>
	  <td>∃ v, c[0], c[1], L, R.</td>
	  
	</tr>
	<tr>
	  <td/>
	  <td>Compose(L, v, R, S)  ∧</td>
	</tr>
	<tr>
	  <td/>
	  <td>n↦v,c[0],c[1],true ∗</td>
	</tr>
	<tr>
	  <td/>
	  <td>RT(c[0], L, bh-1) ∗</td>
	</tr>
	<tr>
	  <td/>
	  <td>BT(c[1], R, bh-1).</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    A general three-node is simply one that's left-leaning or right-leaning:

    <table class="displaymath">
      <tbody>
	<tr>
	  <td>3T(n, S, bh) =</td>
	  <td>3T(n, S, bh, 0) ||</td>
	</tr>
	<tr>
	  <td/>
	  <td>3T(n, S, bh, 1).</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    Four-nodes are easier, as there is only one case:

    <table class="displaymath">
      <tbody>
	<tr>
	  <td>4T(n, S, bh, 0) =</td>
	  <td>∃ v, c[0], c[1], L, R.</td>
	</tr>
	<tr>
	  <td/>
	  <td>Compose(L, v, R, S)  ∧</td>
	</tr>
	<tr>
	  <td/>
	  <td>n↦v,c[0],c[1],true ∗</td>
	</tr>
	<tr>
	  <td/>
	  <td>RT(c[0], L, bh-1) ∗</td>
	</tr>
	<tr>
	  <td/>
	  <td>RT(c[1], R, bh-1)</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    We define a general black tree (BT) as one of the valid pseudo-node types:

    <table class="displaymath">
      <tbody>
	<tr>
	  <td>BT(n, S, bh) =</td>
	  <td>2T(n, S, bh) ||</td>
	</tr>
	<tr>
	  <td/>
	  <td>3T(n, S, bh) ||</td>
	</tr>
	<tr>
	  <td/>
	  <td>4T(n, S, bh).</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    We wrap things up with a separate RBT predicate:

    <div class="displaymath">
      RBT(n, S) = ∃ bh. BT(n, S, bh).
    </div>
  </p>

  <p>
    The above predicates describe valid parts of an RBT.
    Through the procedures, however, we have trees that are invalid, but have some guarantees.
    A red-violated tree is one with a red root and one RT as a child.
    As with the three-node, it swings both ways, so requires parameterization:

    <table class="displaymath">
      <tbody>
	RVT(n, S, bh, 0) =        // left-leaning red-violated tree
	∃ v, c[0], c[1], L, R.
	Compose(L, v, R, S)  ∧
	n↦v,c[0],c[1],false ∗
	RT(c[0], L, bh) ∗
	BT(c[1], R, bh).
      </tbody>
    </table>
  </p>

<!--


  RVT(n, S, bh, 1) =        // right-leaning red-violated tree
    ∃ v, c[0], c[1], L, R.
    Compose(L, v, R, S)  ∧
    n↦v,c[0],c[1],false ∗
    BT(c[0], L, bh) ∗
    RT(c[1], R, bh).
-->

</section>
<section>
  
  <h3>Recursive <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr> algorithms</h3>

  <p>
    As the <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr> data structure is just an augmentation of the <abbr title="Binary Search Tree" class="smallcaps">BST</abbr> data structure,
    the <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr> <code>search</code> algorithm
    is basically identical to the <abbr title="Binary Search Tree" class="smallcaps">BST</abbr> <code>search</code> algorithm,
    in both recursive and iterative versions,
    so I exclude it here.
  </p>

  <section>
    <h4>A recursive <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr> <code>insert</code> algorithm</h4>

    <section xml:base="../../code/d/html/rb/insert/recursive.d.html"><pre class="prettyprint">module rb.insert.recursive;

import rb.node;
import rb.rotate;

Node* insert_aux(Node* root, int value) {

  Node* o; </pre>
<div class="section"><pre class="indent">  </pre><div class="CommentParagraph">We are going to return o.</div></div>
<pre class="prettyprint">
  if (root == null) { </pre>
<div class="section"><pre class="indent">    </pre><div class="CommentParagraph">insertion into the empty set is just a red node.</div></div>
<pre class="prettyprint">    o = new Node(value);
  }
  else if (value == root.value) { </pre>
<div class="section"><pre class="indent">    </pre><div class="CommentParagraph">the tree already contains the value. Already a valid tree. No adjustment required.</div></div>
<pre class="prettyprint">    o = root;
  }
  else { </pre>
<div class="section"><pre class="indent">    </pre><div class="CommentParagraph">We have to insert value into a subtree.</div></div>
<pre class="prettyprint">
    int dir = root.value &lt; value;  // We need to insert in that subtree.

    Node** into = &amp;root.c[dir];

    *into = insert_aux(*into, value); // Do the insert.
 </pre>
<div class="section"><pre class="indent">    </pre><div class="CommentParagraph">Now, insert may have passed up a red node.
If we have room, make a home for it here; otherwise pass up again.</div></div>
<pre class="prettyprint">
    if (red(*into)) { </pre>
<div class="section"><pre class="indent">      </pre><div class="CommentParagraph">A red node was passed up.  Make room, or pass it up again.</div></div>
<pre class="prettyprint">
      Node ** sibling = &amp;root.c[!dir];

      if (red(*sibling)) { </pre>
<div class="section"><pre class="indent">        </pre><div class="CommentParagraph">The sibling is red at height N-1.  Implies root is black, at height N.</div></div>
<pre class="prettyprint">
        (*sibling).black = true;  // Turn sibling into black tree (height N).
        (*into).black = true;     // Set passed-up node black.  If it passed by an RV'd tree, that's fixed by it.  Is now BT(N).
        root.black = false;       // Then turn `root` into red tree at height N.  We've pushed the red up the tree.
      }
      else { </pre>
<div class="section"><pre class="indent">        </pre><div class="CommentParagraph">The sibling is black.  root maybe red.</div></div>
<pre class="prettyprint">        Node** far_child = &amp;(*into).c[dir];
        if (red(*far_child)) { </pre>
<div class="section"><pre class="indent">          </pre><div class="CommentParagraph">into is red, far child is red.  RV.  sibling is black.</div></div>

<div class="section"><pre class="indent">          </pre><div class="CommentParagraph">        root, R/B  &lt;== was previously either BT(N) or RT(N-1)
      /           \
     /             \
sibling, B(N-1)   into, RVT(dir, N-1)
                   /       \
                  /         \
    near child, B(TN-1)    far child, R(N-1)</div></div>
<pre class="prettyprint">
          assert(!red(root));   // WHY???

          rb.rotate.single_ptr(&amp;root, !dir);
 </pre>
<div class="section"><pre class="indent">          </pre><div class="CommentParagraph">           --into, B(N)--
          /              \
         /                \
       root, R(N-1)    far child, R(N-1)
      /           \
     /             \
 sibling, B(N-1)   near child, BT(N-1)</div></div>

<div class="section"><pre class="indent">          </pre><div class="CommentParagraph">Rebalancing stops here.</div></div>
<pre class="prettyprint">        }
        else { </pre>
<div class="section"><pre class="indent">          </pre><div class="CommentParagraph">far child is black.</div></div>
<pre class="prettyprint">          Node** near_child = &amp;(*into).c[!dir];
          if (red(*near_child)) {

            assert(!red(root));   // WHY???
 </pre>
<div class="section"><pre class="indent">            </pre><div class="CommentParagraph">near child is red.</div></div>

<div class="section"><pre class="indent">            </pre><div class="CommentParagraph">        root, R/B  &lt;== was previously either BT(N) or RT(N-1)
      /           \
     /             \
sibling, B(N-1)   into, RVT(!dir, N-1)
                   /           \
                  /             \
       near_child, RT(N-1)     far child, BT(N-1)
         /             \
        /               \
 near_gc, BT(N-1)  far_gc, BT(N-1)</div></div>
<pre class="prettyprint">
            rb.rotate.dbl_ptr(&amp;root, !dir);
 </pre>
<div class="section"><pre class="indent">            </pre><div class="CommentParagraph">           near child, BT(N)
          /                \
         /                  \
    root, RT(N-1)        into, RT(N-1)
   /         \            /       \
sibling,   near gc,    far gc,     far child,
BT(N-1)    BT(N-1)     BT(N-1)     BT(N-1)</div></div>

<div class="section"><pre class="indent">            </pre><div class="CommentParagraph">Rebalancing stops here.</div></div>
<pre class="prettyprint">          }
          else { </pre>
<div class="section"><pre class="indent">            </pre><div class="CommentParagraph">near child is black.</div></div>

<div class="section"><pre class="indent">            </pre><div class="CommentParagraph">        root, RVT(dir, N-1) or BT(N)
      /           \
     /             \
sibling, B(N-1)   into, RT(N-1)
                   /           \
                  /             \
       near_child, BT(N-1)     far child, BT(N-1)</div></div>

<div class="section"><pre class="indent">            </pre><div class="CommentParagraph">Either root is black, and rebalancing stops here, or root is red, and we have an RVT to pass up.</div></div>
<pre class="prettyprint">          }
        }
      }
    }
    else { </pre>
<div class="section"><pre class="indent">      </pre><div class="CommentParagraph">No red was passed up.  We're OK.</div></div>
<pre class="prettyprint">    }

    o = root;
  }

  return o;
}


Node* insert(Node* root, int value) {
  Node* r = insert_aux(root, value);
  r.black = true;
  return r;
} </pre></section>    
  </section>

  <section>
    <h4>A recursive <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr> <code>remove</code> algorithm</h4>

    <!-- <xi:include href="../../code/d/html/rb/remove/recursive.d.html" /> -->
  </section>
</section>
<!--      <xi:include href="iterative.html" /> -->
</section>
      <section xml:base="concurrent/concurrent.html">

  <h2>Concurrent indexes</h2>

  <section>

  <h3>What is a concurrent index?</h3>

  <p>
    The previous algorithms and data structures
    are designed for sequential access.
    Performing concurrent operations on them results in undefined behavior.
  </p>

  <p>
    One naive implementation of a concurrent index
    might simply enforce that, at any one time,
    at most one operation from { <code>search</code>, <code>insert</code>, <code>remove</code> } is running.
    A slightly better implementation
    might restrict to either any number of <code>read</code>s,
    or one of { <code>insert</code>, <code>remove</code> }.
  </p>

  <p>
    This is still too restrictive:
    looking at the various indexing algorithms,
    many of them should, with minimal modification, permit
    multiple concurrent <code>insert</code> operations—the <abbr title="Binary Search Tree" class="smallcaps">BST</abbr>, for example.
    With no knowledge of implementation,
    what restrictions should we expect from an index?
    We might make the observation that, conceptually,
    the keys in an index are independent.
    The fact that key <code>k</code> is in the index or not,
    or that it has some value in the index,
    provides no information about key <code>l</code>
    (where <code>k</code> ≠  <code>l</code>).
    Therefore, we might expect restrictions to be placed only individual keys,
    rather than on the entire index.
    For example, we might have the only restriction that,
    for any key <code>k</code>,
    at most one operation from { <code>search(k)</code>, <code>insert(k, _)</code>, <code>remove(k)</code> } is running.
  </p>

  <section>
    <h4>A concurrent index API specification</h4>

    <table>
      <tbody>
	<tr>
	  <!-- search where key is in the index -->
	  <td><span class="cond math"><span class="pred_name">In</span>(<code>i</code>, <code>k</code>, <span class="var">v</span>)</span></td>
	  <td><code>r = i-&gt;search(k);</code></td>
	  <td>
	    <span class="cond math">
	      <e:fst>
		  <span class="pred_name">In</span>(<code>i</code>, <code>k</code>, <span class="var">v</span>)
		</e:fst> ∧ <e:snd>
		<e:fst><code>r</code></e:fst> = <e:snd><span class="var">v</span></e:snd>
		</e:snd>
	    </span>
	  </td>
	</tr>
	<tr>
	  <!-- search where key is not in the index -->
	  <td><span class="cond math"><span class="pred_name">Out</span>(<code>i</code>, <code>k</code>)</span></td>
	  <td><code>r = i-&gt;search(k);</code></td>
	  <td>
	    <span class="cond math">
	      <e:fst>
		  <span class="pred_name">Out</span>(<code>i</code>, <code>k</code>)
		</e:fst> ∧ <e:snd>
		  <e:fst><code>r</code></e:fst> = <e:snd><code>null</code></e:snd>
		</e:snd>
	    </span>
	  </td>
	</tr>
	<tr>
	  <!-- insert where key is in the index -->
	  <td><span class="cond math"><span class="pred_name">In</span>(<code>i</code>, <code>k</code>, <span class="var">v′</span>)</span></td>
	  <td><code>i-&gt;insert(k, v);</code></td>
	  <td><span class="cond math"><span class="pred_name">In</span>(<code>i</code>, <code>k</code>, <span class="var">v′</span>)</span></td>
	</tr>
	<tr>
	  <!-- insert where key is not in the index -->
	  <td><span class="cond math"><span class="pred_name">Out</span>(<code>i</code>, <code>k</code>)</span></td>
	  <td><code>i-&gt;insert(k, v);</code></td>
	  <td><span class="cond math"><span class="pred_name">In</span>(<code>i</code>, <code>k</code>, <code>v</code>)</span></td>
	</tr>
	<tr>
	  <!-- remove where key is in the index -->
	  <td><span class="cond math"><span class="pred_name">In</span>(<code>i</code>, <code>k</code>, <span class="var">v</span>)</span></td>
	  <td><code>i-&gt;remove(k);</code></td>
	  <td><span class="cond math"><span class="pred_name">Out</span>(<code>i</code>, <code>k</code>)</span></td>
	</tr>
	<tr>
	  <!-- remove where key is not in the index -->
	  <td><span class="cond math"><span class="pred_name">Out</span>(<code>i</code>, <code>k</code>)</span></td>
	  <td><code>i-&gt;remove(k);</code></td>
	  <td><span class="cond math"><span class="pred_name">Out</span>(<code>i</code>, <code>k</code>)</span></td>
	</tr>
      </tbody>
    </table>
  </section>
</section>
  <section>

  <h3>Concurrent index algorithms</h3>

  <p>
    The <q>array</q> approach to indexing,
    with one <q>slot</q> for every possible key in the universe of keys,
    would provide this,
    but carries its usual disadvantages.
    The hash table might provide a similar level of concurrency—one
    <code>remove</code> operation per hash value—but again carries its usual disadvantages.
  </p>

  <p>
    What about the <abbr title="Binary Search Tree" class="smallcaps">BST</abbr>?
    We might expect highly concurrent
    <code>search</code>,
    as this does not mutate the tree.
    Our <code>insert</code> operations may also be,
    as they only mutate leaves.
    The <code>remove</code> operation only mutates
    the removed node and its in-order predecessor,
    and so might only lock these.
    It seems the <abbr title="Binary Search Tree" class="smallcaps">BST</abbr> offers good support for highly concurrent operations.
  </p>

  <p>
    Can this support carry through to balanced tree algorithms?
    The basic reason the <abbr title="Binary Search Tree" class="smallcaps">BST</abbr> is promising is that
    the tree is highly static and operations are highly <q>local</q>.
    We can, then, dismiss variations like the splay tree,
    where every operation performs rotations
    at every level down to the key under consideration,
    which must lead to horrendous locking considerations
    (and to my knowledge, no concurrent splay tree algorithms have been attempted).
    But at first glance,
    <em>all</em> strictly balanced trees have the same problem:
    maintaining the invariant that promises balance
    can require fixing-up the tree all the way along one path from the root to a leaf.
  </p>

  <p>
    The way most concurrent balanced trees tackle this
    is to <q>relax</q> the balancing invariant:
    simply, the tree is allowed to be in states that break the guarantee of balance.
    The balancing logic is moved into a separate operation
    which can be performed independently of the <abbr title="Application Programming Interface" class="smallcaps">API</abbr> operations—<i>e.g.</i>, in a separate thread.
  </p>

  <ul>
    <li><strong class="item">AVL tree</strong>Many concurrent AVL tree algorithms exist %% \cite{bronson_avl} proposes a relaxed.</li>
    <li><strong class="item">Red-Black tree</strong>...</li>
  </ul>

  <section>
    <h4>Concurrent Red-Black trees</h4>

    <p>
      There’s more than one way to make a <q>concurrent <abbr title="Red-Black Tree" class="smallcaps">RBT</abbr></q>.
    </p>

    <section>
      <h5>Chromatic trees</h5>

      <p>
	Introduced by Nurmi and Soisalon-Soininen in 1991/95.
	Their tree only stores values in the leaves,
	and the internal nodes are merely <q>routers</q>.
	<span class="note">
	  This seems like a really important change!
	  Is there an isomorphism between a standard RB-tree and one that stores everything in the leaves?
	  And how important is this from a performance POV?
	</span>
	Their paper uses the red/black edge interpretation of the RB tree.
      </p>

      <p>
	Instead of two states red/black,
	each edge is given a weight (an unsigned integer).
	Red=0 and black=1.  Values &lt; 0 impossible.  Values &gt; 1 termed <q>overweighted</q>.
      </p>

      <p>
	The <q>equal number of black nodes on any path</q> rule
	is transformed into:
	<q>equal sum of weights on any path</q>.
	Without overweighting,
	this is equivalent (due to the values of red/black).
      </p>

      <p>
	The <q>no two red nodes</q> rule is transformed into:
	<q>the parent edges of the leaves are not red</q>.
      </p>

      <p>
	The data structure spec now provides no guarantees of balancedness.
	The two rules of the sequential RB tree together guarantee that
	longest path length / shortest path length less than or equal to 2.
	The chromatic tree may have any lengths,
	in the case that all weights are zero (i.e. all edges are <q>red</q>) except for those of the leaves (which &gt;0).
      </p>

      <p>
	Note also that the B-tree isomorphism also disappears.
	(Or does it?  In an arbitrarily-long run of reds, is there an analogous B-tree?)
      </p>

      <p>
	Insertion/deletion perform no rebalancing,
	and maintain the CRB properties.
	However, they may introduce violations of the red rule (consecutive reds).
      </p>

      <p>
	Rebalancing is done by a separate thread.
	Where the sequential RB tree balancing is done bottom-up
	(we insert the new node at a leaf,
	then rebalance moving towards the root),
	the chromatic rebalancing algorithm is top-down.
      </p>

      <p>
	Concurrency control is done by three kinds of lock: r, w, x.
	For any given node, the following patterns are possible:

	<table>
	  <thead>
	    <tr><td>R</td><td>W</td><td>X</td></tr>
	  </thead>
	  <tbody>
	    <tr><td>0</td><td>0</td><td>0</td></tr>
	    <tr><td>1...inf</td><td>0</td><td>0</td></tr>
	  </tbody>
	</table>
      </p>

      <p>
	Each thread, whether reading, writing or updating,
	locks nodes as it traverses the tree.
	Rebalancing is done purely by changing node contents.
	This is the locking scheme of Ellis for AVL trees\cite{ellis},
	with modifications.
	E.g., Ellis proposes that writers w-lock the entire path,
	so that global balancing can be done;
	the decoupling makes w-lock coupling sufficient.
      </p>
    </section>

    <section>
      <h5>Larsen's tree\cite{larsen}</h5>

      <p>
	This builds on the chromatic tree,
	with simplifications to the rebalancing.
	It requires a \enquote{problem queue}.
	Hanke finds that Larsen’s tree,
	due to the queue and due to bottom-up conflict handling,
	does not perform as well as the chromatic tree.
      </p>
    </section>

    <section>
      <h5>Hyperred-Black trees</h5>

      <p>
	Gabarro et al criticize the Chromatic tree:
	in a run of red nodes, only the top pair may be updated.
	This is because the rebalancing rules require that
	the grandparent is black (recall that this is a guarantee with the sequential RB tree).
	Runs of red nodes may well happen:
	sorted insertion is common,
	and all new nodes are colored red.
	(BUT in the chromatic tree paper above, leaf nodes (parent edges) are black!)
	The suggested change is that
	as well as being hyperblack (<q>overweighted</q>),
	nodes may be hyperred (<q>underweighted</q>),
	i.e., weights ≤ 0 are degrees of red,
	and weights ≥ 1 are degrees of black.
	The ‘blackness’ definition is maintained.
	The authors have proofs of correctness.
	However, they have experimental results
	that show a less-than-impressive performance <i>vs.</i> the chromatic tree.
      </p>
    </section>
  </section>
</section>
  <section xmlns="">
  <h3>Concurrent indexes in the wild</h3>
</section>
  <section xmlns="">
  <h3>Some predicate definitions</h3>
</section>

</section>
    </section>
  </body>
</html>
