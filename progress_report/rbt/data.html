<section xmlns="http://www.w3.org/1999/xhtml"
	 xmlns:xi="http://www.w3.org/2001/XInclude"
	 xmlns:e="http://eegg.github.com/htmlx"
	 xmlns:m="http://eegg.github.com/macro">
  
  <h3>The <m:rbt /> data structure</h3>

  <p>
    We need to define some predicates to describe the state of the tree
    at various points in the procedures—types of valid and <q>invalid</q> trees and subtrees.
    We use the same <e:predicate>Compose</e:predicate> predicate as before.
  </p>

  <p>
    It is convenient to think of an <m:rbt/> as composed of <q>red-rooted</q> trees and <q>black-rooted</q> trees.
    I use separate predicates for each: <e:predicate>RT</e:predicate> and <e:predicate>BT</e:predicate>.
  </p>

  <p>
    A red-rooted tree is as follows:
    a red-rooted tree pointed to by `n` represents set S with a tree of black-height `bh` if

    <table class="displaymath">
      <tr>
	<td><e:pred name="RT"><code>n</code>, <e:st n="S"/>, <e:var n="bh"/></e:pred> =</td>
	<td>
	  ∃ <e:var n="v"/>, <e:var n="c[0]"/>, <e:var n="c[1]"/>, <e:st n="L"/>, <e:st n="R"/>.
	</td>
	<td>there exist element <e:var n="v"/> and sets <e:st n="L"/> and <e:st n="R"/></td>
      </tr>
      <tr>
	<td></td>
	<td><e:pred name="Compose"><e:st n="L"/>, <e:var n="v"/>, <e:st n="R"/>, <e:st n="S"/></e:pred> ∧</td>
	<td>such that <e:st n="L"/>, <e:var n="v"/> and <e:st n="R"/> make up <e:st n="S"/>, and</td>
      </tr>
      <tr>
	<td></td>
	<td>
	  <e:fcell>
	    <e:fst><code>n</code></e:fst>
	    <e:snd><e:var n="v"/>, <e:var n="c[0]"/>, <e:var n="c[1]"/>, <e:const n="false"/></e:snd>
	  </e:fcell> ∗
	</td>
	<td><code>n</code> points to a red node containing <e:var n="v"/> and child pointers</td>
      </tr>
      <tr>
	<td></td>
	<td>
	  <e:pred name="BT"><e:var n="c[0]"/>, <e:st n="L"/>, <e:var n="bh"/></e:pred> ∗
	</td>
	<td>to black trees representing <e:st n="L"/></td>
      </tr>
      <tr>
	<td></td>
	<td>
	  <e:pred name="BT"><e:var n="c[1]"/>, <e:st n="R"/>, <e:var n="bh"/></e:pred>
	</td>
	<td>and <e:st n="R"/>, with the same black height.</td>
      </tr>
    </table>
  </p>

  <p>
    There's only one kind of RT, as the rules demand both children are black.
    However, there are multiple types of BT, analogous to the multiple node types in a 2,3,4-tree.
    There are two-nodes, in which both children are also black.
    There are three-nodes, in which one child is black (a BT) and one is red (an RT).
    That is, the RBT rules have two representations of a three-node:
    where the left child is the RT (<q>left-leaning</q>),
    and where the right child is the RT (<q>right-leaning</q>).
    Finally, there are four-nodes, where both children are RTs.
  </p>

  <p>
    First, two-nodes (2T).
    Two distinct types of two-node exist: empty and non-empty.
    The empty node is easiest:

    <table class="displaymath">
      <tbody>
	<tr>
	  <td><e:pred name="ET"><code>n</code>, <e:st n="S"/>, <e:var n="bh"/></e:pred> =</td>
	  <td><e:eq><e:fst><code>n</code></e:fst><e:snd><code>null</code></e:snd></e:eq> ∧</td>
	  <td><e:var n="n"/> is <code>null</code>,</td>
	</tr>
	<tr>
	  <td></td>
	  <td><e:eq><e:fst><e:st n="S"/></e:fst><e:snd><m:scemp/></e:snd></e:eq> ∧</td>
          <td>the tree represents the empty set,</td>
	</tr>
	<tr>
	  <td></td>
	  <td><m:hemp/> ∧</td>
          <td>the heap is empty,</td>
	</tr>
	<tr>
	  <td></td>
	  <td><e:eq><e:fst><e:var n="bh"/></e:fst><e:snd><e:const n="1"/></e:snd></e:eq></td>
          <td>and we have a black-height of 1.</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    Next we capture the non-empty two-node,
    which represents set <e:st n="S"/> with black-height <e:var n="bh"/> if

    <table class="displaymath">
      <tbody>
	<tr>
	  <td><e:pred name="N2T"><code>n</code>, <e:st n="S"/>, <e:var n="bh"/></e:pred> =</td>
	  <td>∃ <e:var n="v"/>, <e:var n="c[0]"/>, <e:var n="c[1]"/>, <e:st n="L"/>, <e:st n="R"/>.</td>
	  <td>there exist element <e:var n="v"/> and sets <e:st n="L"/> and <e:st n="R"/></td>
	</tr>
	<tr>
	  <td></td>
	  <td><e:pred name="Compose"><e:st n="L"/>, <e:var n="v"/>, <e:st n="R"/>, <e:st n="S"/></e:pred> ∧</td>
	  <td>such that <e:st n="L"/>, <e:var n="v"/> and <e:st n="R"/> make up <e:st n="S"/>, and</td>
	</tr>
	<tr>
	  <td></td>
	  <td><e:fcell><e:fst><code>n</code></e:fst><e:snd><e:var n="v"/>, <e:var n="c[0]"/>, <e:var n="c[1]"/>, <e:const n="true"/></e:snd></e:fcell> ∗</td>
	  <td><code>n</code> points to a black node containing <e:var n="v"/> and pointers</td>
	</tr>
	<tr>
	  <td></td>
	  <td><e:pred name="BT"><e:var n="c[0]"/>, <e:st n="L"/>, <e:minus><e:fst><e:var n="bh"/></e:fst><e:snd>1</e:snd></e:minus></e:pred> ∗</td>
	  <td>to black trees representing <e:st n="L"/> and <e:st n="R"/>,</td>
	</tr>
	<tr>
	  <td></td>
	  <td><e:pred name="BT"><e:var n="c[1]"/>, <e:st n="R"/>, <e:minus><e:fst><e:var n="bh"/></e:fst><e:snd>1</e:snd></e:minus></e:pred></td>
          <td>which have one less black height.</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    A general <e:predicate>2T</e:predicate> is either empty or non-empty:

    <div class="displaymath">
      <e:pred name="2T"><code>n</code>, <e:st n="S"/>, <e:var n="bh"/></e:pred> =
      <e:or>
	<e:fst><e:pred name="ET"><code>n</code>, <e:st n="S"/>, <e:var n="bh"/></e:pred></e:fst>
	<e:snd><e:pred name="N2T"><code>n</code>, <e:st n="S"/>, <e:var n="bh"/></e:pred></e:snd>
      </e:or>
    </div>
  </p>

  <p>
    Next, three-nodes.
    We could create predicates <e:predicate>LeftLeaning3T</e:predicate> and <e:predicate>RightLeaning3T</e:predicate>,
    but then we lose the benefit of parameterizing the link direction.
    So we parameterize the predicate.
    Here's the left-leaning three-node:
    <e:note>The right-leaning node is symmetrical, with link direction 1 and the children's colors swapped.</e:note>

    <table class="displaymath">
      <tbody>
	<tr>
	  <td><e:pred name="3T">n, S, bh, 0</e:pred> =</td>
	  <td>∃ v, c[0], c[1], L, R.</td>
	  
	</tr>
	<tr>
	  <td></td>
	  <td>Compose(L, v, R, S)  ∧</td>
	</tr>
	<tr>
	  <td></td>
	  <td>n↦v,c[0],c[1],true ∗</td>
	</tr>
	<tr>
	  <td></td>
	  <td>RT(c[0], L, bh-1) ∗</td>
	</tr>
	<tr>
	  <td></td>
	  <td>BT(c[1], R, bh-1).</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    A general three-node is simply one that's left-leaning or right-leaning:

    <table class="displaymath">
      <tbody>
	<tr>
	  <td>3T(n, S, bh) =</td>
	  <td>3T(n, S, bh, 0) ||</td>
	</tr>
	<tr>
	  <td></td>
	  <td>3T(n, S, bh, 1).</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    Four-nodes are easier, as there is only one case:

    <table class="displaymath">
      <tbody>
	<tr>
	  <td>4T(n, S, bh, 0) =</td>
	  <td>∃ v, c[0], c[1], L, R.</td>
	</tr>
	<tr>
	  <td></td>
	  <td>Compose(L, v, R, S)  ∧</td>
	</tr>
	<tr>
	  <td></td>
	  <td>n↦v,c[0],c[1],true ∗</td>
	</tr>
	<tr>
	  <td></td>
	  <td>RT(c[0], L, bh-1) ∗</td>
	</tr>
	<tr>
	  <td></td>
	  <td>RT(c[1], R, bh-1)</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    We define a general black tree (BT) as one of the valid pseudo-node types:

    <table class="displaymath">
      <tbody>
	<tr>
	  <td>BT(n, S, bh) =</td>
	  <td>2T(n, S, bh) ||</td>
	</tr>
	<tr>
	  <td></td>
	  <td>3T(n, S, bh) ||</td>
	</tr>
	<tr>
	  <td></td>
	  <td>4T(n, S, bh).</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    We wrap things up with a separate RBT predicate:

    <div class="displaymath">
      RBT(n, S) = ∃ bh. BT(n, S, bh).
    </div>
  </p>

  <p>
    The above predicates describe valid parts of an RBT.
    Through the procedures, however, we have trees that are invalid, but have some guarantees.
    A red-violated tree is one with a red root and one RT as a child.
    As with the three-node, it swings both ways, so requires parameterization:

    <table class="displaymath">
      <tbody>
	RVT(n, S, bh, 0) =        // left-leaning red-violated tree
	∃ v, c[0], c[1], L, R.
	Compose(L, v, R, S)  ∧
	n↦v,c[0],c[1],false ∗
	RT(c[0], L, bh) ∗
	BT(c[1], R, bh).
      </tbody>
    </table>
  </p>

<!--


  RVT(n, S, bh, 1) =        // right-leaning red-violated tree
    ∃ v, c[0], c[1], L, R.
    Compose(L, v, R, S)  ∧
    n↦v,c[0],c[1],false ∗
    BT(c[0], L, bh) ∗
    RT(c[1], R, bh).
-->

</section>
