<section xmlns="http://www.w3.org/1999/xhtml"
	 xmlns:xi="http://www.w3.org/2001/XInclude"
	 xmlns:e="http://eegg.github.com/htmlx"
	 xmlns:m="http://eegg.github.com/macro">
  
  <h3>The <m:rbt /> data structure</h3>

  <p>
    We need to define some predicates to describe the state of the tree
    at various points in the procedures—types of valid and <q>invalid</q> trees and subtrees.
    We use the same <e:predicate>Compose</e:predicate> predicate as before.
  </p>

  <p>
    It is convenient to think of an <m:rbt/> as composed of <q>red-rooted</q> trees and <q>black-rooted</q> trees.
    I use separate predicates for each: <e:predicate>RT</e:predicate> and <e:predicate>BT</e:predicate>.
  </p>

  <p>
    A red-rooted tree is as follows:
    a red-rooted tree pointed to by `n` represents set S with a tree of black-height `bh` if

    <table class="displaymath">
      <tr>
	<td><e:pred name="RT"><code>n</code>, <e:st n="S"/>, <e:var n="bh"/></e:pred> =</td>
	<td>
	  ∃ <e:var n="v"/>, <e:var n="c[0]"/>, <e:var n="c[1]"/>, <e:st n="L"/>, <e:st n="R"/>.
	</td>
	<td>there exist element <e:var n="v"/> and sets <e:st n="L"/> and <e:st n="R"/></td>
      </tr>
      <tr>
	<td></td>
	<td><e:pred name="Compose"><e:st n="L"/>, <e:var n="v"/>, <e:st n="R"/>, <e:st n="S"/></e:pred> ∧</td>
	<td>such that <e:st n="L"/>, <e:var n="v"/> and <e:st n="R"/> make up <e:st n="S"/>, and</td>
      </tr>
      <tr>
	<td></td>
	<td>
	  <e:fcell>
	    <e:fst><code>n</code></e:fst>
	    <e:snd><e:var n="v"/>, <e:var n="c[0]"/>, <e:var n="c[1]"/>, <e:const n="false"/></e:snd>
	  </e:fcell> ∗
	</td>
	<td><code>n</code> points to a red node containing <e:var n="v"/> and child pointers</td>
      </tr>
      <tr>
	<td></td>
	<td>
	  <e:pred name="BT"><e:var n="c[0]"/>, <e:st n="L"/>, <e:var n="bh"/></e:pred> ∗
	</td>
	<td>to black trees representing <e:st n="L"/></td>
      </tr>
      <tr>
	<td></td>
	<td>
	  <e:pred name="BT"><e:var n="c[1]"/>, <e:st n="R"/>, <e:var n="bh"/></e:pred>
	</td>
	<td>and <e:st n="R"/>, with the same black height.</td>
      </tr>
    </table>
  </p>

  <p>
    There's only one kind of RT, as the rules demand both children are black.
    However, there are multiple types of BT, analogous to the multiple node types in a 2,3,4-tree.
    There are two-nodes, in which both children are also black.
    There are three-nodes, in which one child is black (a BT) and one is red (an RT).
    That is, the RBT rules have two representations of a three-node:
    where the left child is the RT (<q>left-leaning</q>),
    and where the right child is the RT (<q>right-leaning</q>).
    Finally, there are four-nodes, where both children are RTs.
  </p>

  <p>
    First, two-nodes (2T).
    Here, we capture that the empty set is represented by the null pointer
    (the null pointer is a 2T and only a 2T).
    // a two-node pointed to by `n` represents set S with black-height `bh` if

    <table class="displaymath">
      <tbody>
	<tr>
	  <td>2T(n, S, bh) =</td>
	  <td>n == NULL  ∧</td>
	  <td>`n` is null, in which case</td>
	</tr>
	<tr>
	  <td></td>
	  <td>S == {} ∧</td>
          <td>it represents the empty set,</td>
	</tr>
	<tr>
	  <td></td>
	  <td>emp ∧</td>
          <td>the heap is empty,</td>
	</tr>
	<tr>
	  <td></td>
	  <td>bh == 1</td>
          <td>and we have a black-height of 1;</td>
	</tr>
	<tr>
	  <td>||</td>
          <td></td>
	  <td>or `n` is not null, so</td>
	</tr>
	<tr>
	  <td></td>
	  <td>∃ v, c[0], c[1], L, R.</td>
	  <td>there exist element `v` and sets L and R</td>
	</tr>
	<tr>
	  <td></td>
	  <td>Compose(L, v, R, S) ∧</td>
	  <td>such that L, v and R make up S, and</td>
	</tr>
	<tr>
	  <td></td>
	  <td>n↦v,c[0],c[1],true ∗</td>
	  <td>`n` points to (implies not null) a valid black node (i.e., black==false) containing `v` and child pointers</td>
	</tr>
	<tr>
	  <td></td>
	  <td>BT(c[0], L, bh-1) ∗</td>
	  <td>to black trees representing L and R,</td>
	</tr>
	<tr>
	  <td></td>
	  <td>BT(c[1], R, bh-1)</td>
          <td>with one less black height (as they do not contain this black node).</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    Next, three-nodes.
    We could create predicates LeftLeaning3T and RightLeaning3T,
    but then we lose the benefit of parameterizing the link direction.
    So we parameterize the predicate.
    Here's the left-leaning three-node:
    <e:note>The right-leaning node is symmetrical, with link direction 1 and the children's colors swapped.</e:note>

    <table class="displaymath">
      <tbody>
	<tr>
	  <td>3T(n, S, bh, 0) =</td>
	  <td>∃ v, c[0], c[1], L, R.</td>
	</tr>
	<tr>
	  <td></td>
	  <td>Compose(L, v, R, S)  ∧</td>
	</tr>
	<tr>
	  <td></td>
	  <td>n↦v,c[0],c[1],true ∗</td>
	</tr>
	<tr>
	  <td></td>
	  <td>RT(c[0], L, bh-1) ∗</td>
	</tr>
	<tr>
	  <td></td>
	  <td>BT(c[1], R, bh-1).</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    A general three-node is simply one that's left-leaning or right-leaning:

    <table class="displaymath">
      <tbody>
	<tr>
	  <td>3T(n, S, bh) =</td>
	  <td>3T(n, S, bh, 0) ||</td>
	</tr>
	<tr>
	  <td></td>
	  <td>3T(n, S, bh, 1).</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    Four-nodes are easier, as there is only one case:

    <table class="displaymath">
      <tbody>
	<tr>
	  <td>4T(n, S, bh, 0) =</td>
	  <td>∃ v, c[0], c[1], L, R.</td>
	</tr>
	<tr>
	  <td></td>
	  <td>Compose(L, v, R, S)  ∧</td>
	</tr>
	<tr>
	  <td></td>
	  <td>n↦v,c[0],c[1],true ∗</td>
	</tr>
	<tr>
	  <td></td>
	  <td>RT(c[0], L, bh-1) ∗</td>
	</tr>
	<tr>
	  <td></td>
	  <td>RT(c[1], R, bh-1)</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    We define a general black tree (BT) as one of the valid pseudo-node types:

    <table class="displaymath">
      <tbody>
	<tr>
	  <td>BT(n, S, bh) =</td>
	  <td>2T(n, S, bh) ||</td>
	</tr>
	<tr>
	  <td></td>
	  <td>3T(n, S, bh) ||</td>
	</tr>
	<tr>
	  <td></td>
	  <td>4T(n, S, bh).</td>
	</tr>
      </tbody>
    </table>
  </p>

  <p>
    We wrap things up with a separate RBT predicate:

    <div class="displaymath">
      RBT(n, S) = ∃ bh. BT(n, S, bh).
    </div>
  </p>

  <p>
    The above predicates describe valid parts of an RBT.
    Through the procedures, however, we have trees that are invalid, but have some guarantees.
    A red-violated tree is one with a red root and one RT as a child.
    As with the three-node, it swings both ways, so requires parameterization:

    <table class="displaymath">
      <tbody>
	RVT(n, S, bh, 0) =        // left-leaning red-violated tree
	∃ v, c[0], c[1], L, R.
	Compose(L, v, R, S)  ∧
	n↦v,c[0],c[1],false ∗
	RT(c[0], L, bh) ∗
	BT(c[1], R, bh).
      </tbody>
    </table>
  </p>

<!--


  RVT(n, S, bh, 1) =        // right-leaning red-violated tree
    ∃ v, c[0], c[1], L, R.
    Compose(L, v, R, S)  ∧
    n↦v,c[0],c[1],false ∗
    BT(c[0], L, bh) ∗
    RT(c[1], R, bh).
-->
  </p>

</section>
