<section xmlns="http://www.w3.org/1999/xhtml"
	 xmlns:xi="http://www.w3.org/2001/XInclude"
	 xmlns:e="http://eegg.github.com/htmlx"
	 xmlns:m="http://eegg.github.com/macro">
  
  <h2>Verifying the <m:rbt /></h2>

  <p>
    The <m:rbt /> inherits ideas from the AVL tree and the B-tree.
    It has the same goals and performance guarantees as the AVL tree,
    and uses the same tree mutation to achieve them: rotations.
    However, it can also be seen as 
    a mapping of a B-tree of degree <e:var n="t"/> = 2 onto a <m:bst />.
    <e:note>
      <m:ie />,
      a B-tree where the number of elements <e:var n="e"/> is 1 ≤ <e:var n="e"/> ≤ 3
      (and therefore the number of links <e:var n="l"/> is 2 ≤ <e:var n="l"/> ≤ 4).
    </e:note>
    This has the advantage over the B-tree that
    adjusting a node does not require copying,
    and less-than-full nodes do not hold unused allocated memory.
  </p>

  <p>
    In such a B-tree,
    a 3-node<e:note>I use the term $n$-node to describe a node that can contain up to <e:var n="n"/> elements.</e:note>
    is structured as three element-sized spaces adjacent in memory.
    The <m:rbt /> instead uses between one and three 1-nodes.
    The first 1-node, which I shall call the <e:jargon>representative-node</e:jargon>,
    is representative of the analogous B-tree 3-node.
    It is the target of links from parents.
    It is accompanied by zero, one or two more 1-nodes, which I shall call <e:jargon>side-nodes</e:jargon>,
    and which contain the other elements in the 3-node.
  </p>

  <p>
    The defining feature of the <m:rbt/> is
    the restriction that it places on the colors and black-heights of nodes.
    Before we even look at the tree structure,
    we can actually encode these restrictions on four variables:
    the color and black-height of a node,
    and the color and black-height of its parent.
    Let&#x2019;s start by defining a predicate on these
    (as well as making the description more intelligible,
    this also makes the full description shorter,
    and makes proofs shorter where they are unconcerned with the <m:rbt/> conditions).
  </p>

  <p>
    This says that:

    <ul>
      <li>the color is either <e:const n="red"/> or <e:const n="black"/></li>
      <li>if the node is <e:const n="red"/>, its parent has the same black-height</li>
      <li>if the node is <e:const n="black"/>, its parent has a greater black-height by 1</li>
      <li>if the node is <e:const n="red"/>, its parent is <e:const n="black"/></li>
      <li>a negative black-height is disallowed</li>
    </ul>
  </p>

  <p>
    We now want to define the <m:rbt /> recursively.
    We can then describe a node pointer.
  </p>

  <p>
    The representative-node's <code>left</code> and <code>right</code> pointers have two roles.
    Where side-nodes exist,
    the pointers point to these.
    (Note this implies that, if the analogous 3-node is full,
    the representative-node will hold the middle element.)
    Where a side-node is absent,
    the corresponding pointer instead points directly to the appropriate child representative-node.
    <e:note>
      Herein lies the space-saving and copy-reducing aspects of the <m:rbt />,
      analogous to the benefits of the <m:bst /> over an array.
    </e:note>
    A side-node's pointers must point to a child representative-node.
    (All pointers may instead be to <code>null</code> nodes, at which the tree terminates.)
  </p>

  <p>
    How are we to know whether a pointer leads us to a side-node or a child representative-node?
    The approach of Guibas and Sedgewick was to give the pointer a <e:jargon>color</e:jargon>:
    pointers to representative-nodes are black,
    and pointers to side-nodes are red.
    In the literature, this has been transformed into the equivalent rule that
    representative-nodes are colored black,
    and side-nodes are colored red.
    This has been shortened to simply <q>red nodes</q> and <q>black nodes</q>.
  </p>

  <p>
    We can now state the properties of the <m:rbt />,
    and relate them to the B-tree:
  </p>

  <ol>
    <li>
      <strong>A node is either red or black.</strong>
      (A 1-node is either a representative-node or a side-node.)
    </li>
    <li>
      <strong>The root is black,</strong>
      as it is representative of the root 3-node.
    </li>
    <li>
      <strong>Leaf nodes are black.</strong>
      This includes <code>null</code> nodes
      (which in practise can be represented by a single sentinel nil node).
    </li>
    <li>
      <strong>Red nodes cannot have red children (the <q>red rule</q>).</strong>
      This is because they must point to child representative-nodes
      (pointing to another side-node would
      extend the number of elements in a node to more than three).
    </li>
    <li>
      <strong>For any node, all simple paths to a descendant leaf have the same number of black nodes (the <q>black rule</q>).</strong>
      This number is the node's <e:jargon>black-height</e:jargon>.
      This is equivalent to the B-tree rule that all leaves have the same depth.
    </li>
  </ol>

  <p>
    From the B-tree analogy,
    it should already be evident that the <m:rbt /> enforces balance.
    However, we can also see this from the last two <m:rbt /> properties.
    Precisely, we can show that,
    for any node, the longest path to a descendant leaf
    is no more than double the length of the shortest path to a descendant leaf.
    If the node has black-height <e:var n="h"/>,
    then both the shortest and longest path consist of <e:var n="h"/> black nodes (by property 5), interspersed with red nodes.
    The shortest path will contain no red nodes
    (because excising one maintains the \RBt properties and makes the path shorter),
    and therefore has length <e:var n="h"/>.
    The longest path will contain one red node between each pair of black nodes
    (because introducing another violates property 4),
    and therefore has length 2<e:var n="h"/>−1.
  </p>

  <p>
    <m:rbt /> operations feel like B-tree operations.
    When inserting a new node, we color it red,
    and insert it as we would in a <m:bst />.
    Then, if its parent is black, we're done
    (analogous to there being space in a leaf 3-node).
    Otherwise, the parent is red, and we have violated the red rule.
    We know the grandparent is black.
    We check the color of the uncle.
    If the uncle is red, we do a color swap on the parent, grandparent, and uncle,
    and move up the tree to look for a possible red violation.
    This is analogous to a 3-node being full, splitting it, and moving the median up.
    However, if the uncle is black,
    we do a single rotation on the grandparent and some recoloring, and stop.
    This is analogous to there being free space <q>on the other side</q> of the 3-node.
  </p>

  <section>
    <h4>Simplifications of the <m:rbt /></h4>

    <p>
      The standard <m:rbt /> is sometimes seen as overly complex.
      More precisely,
      the number of violating cases that the algorithms have to rectify
      is seen as too large.
      In response, there are simplifications of the standard <m:rbt />.
      One is the AA-tree,
      which has the additional requirement that
      red nodes must be right children.
      In the B-tree analogy, they are 2-3 trees.
      This reduces seven cases to two.
    </p>

    <p>
      Another is the Left-Leaning Red-Black tree,
      introduced by Sedgewick.
      In a similar spirit,
      it reduces the number of cases,
      enforcing that
      no node may have a black left child and a red right child.
      This means that, in the B-tree analogy,
      a 3-node only has a single representation in the <m:rbt />.
      Unlike the AA-tree, this is still analogous to a 2-3-4 tree.
      The main advantage is code simplicity:
      <code>insert</code> takes 33 lines <m:vs /> 150 lines.
    </p>

    <p>
      I find these simplifications unsatisfying.
      The gain in code simplicity results in a loss of conceptual clarity.
      More importantly, the <m:rbt /> algorithms can be drastically shortened
      by tackling the symmetric cases using the same code,
      while remaining semantically equivalent.
      A simple technique
      uses a two-element array of child pointers
      instead of a <code>left</code> and a <code>right</code> pointer.
      <e:cite>Julienne Walker, jsw</e:cite>
    </p>

    <p>
      This allows the direction (left or right) to be parameterized,
      encoded as either a <e:const n="0"/> or <e:const n="1"/>.
      The direction can thus be reversed with with the C <code>!</code> operator.
    </p>
  </section>

  <p>
    As before, I verify recursive algorithms for <code>search</code>, <code>insert</code>, and <code>remove</code>.
    Finally, I will verify iterative algorithms for the same procedures.
  </p>

<xi:include href="data.html" />
<xi:include href="recursive.html" />
<!--      <xi:include href="iterative.html" /> -->
</section>
